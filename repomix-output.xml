This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/.env.example
backend/.gitignore
backend/app.py
backend/config.py
backend/requirements.txt
backend/routes/__init__.py
backend/routes/analysis_routes.py
backend/routes/chat_routes.py
backend/routes/location_routes.py
backend/services/__init__.py
backend/services/chat_agent.py
backend/services/competitor_service.py
backend/services/latlong_service.py
backend/services/places_service.py
backend/services/relevance_service.py
backend/services/validation_service.py
backend/utils/__init__.py
backend/utils/score_calculator.py
DESIGN.md
frontend/.env.example
frontend/.gitignore
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/public/favicon.svg
frontend/public/hotspot-logo.png
frontend/public/icons/bank.svg
frontend/public/icons/bar.svg
frontend/public/icons/book.svg
frontend/public/icons/building.svg
frontend/public/icons/bus.svg
frontend/public/icons/cafe.svg
frontend/public/icons/clothing.svg
frontend/public/icons/college.svg
frontend/public/icons/electronics.svg
frontend/public/icons/gym.svg
frontend/public/icons/hospital.svg
frontend/public/icons/house.svg
frontend/public/icons/location-pin.svg
frontend/public/icons/mall.svg
frontend/public/icons/marker.svg
frontend/public/icons/metro.svg
frontend/public/icons/office.svg
frontend/public/icons/park.svg
frontend/public/icons/pharmacy.svg
frontend/public/icons/restaurant.svg
frontend/public/icons/salon.svg
frontend/public/icons/school.svg
frontend/public/icons/search.svg
frontend/public/icons/star.svg
frontend/public/icons/store.svg
frontend/public/icons/temple.svg
frontend/public/logo.svg
frontend/repomix-output.xml
frontend/src/App.jsx
frontend/src/components/Chat/ChatBot.jsx
frontend/src/components/Chat/index.js
frontend/src/components/common/Icon.jsx
frontend/src/components/common/index.js
frontend/src/components/Dashboard/AnalysisPanel.jsx
frontend/src/components/Dashboard/Charts/CompetitorChart.jsx
frontend/src/components/Dashboard/Charts/index.js
frontend/src/components/Dashboard/Charts/LandmarkRadar.jsx
frontend/src/components/Dashboard/Charts/ScoreGauge.jsx
frontend/src/components/Dashboard/CompetitorCard.jsx
frontend/src/components/Dashboard/index.js
frontend/src/components/Dashboard/LandmarksCard.jsx
frontend/src/components/Dashboard/LoadingProgress.jsx
frontend/src/components/Dashboard/MetricsGrid.jsx
frontend/src/components/Dashboard/RecommendedSpotsCard.jsx
frontend/src/components/Dashboard/ScoreCard.jsx
frontend/src/components/Filters/BusinessTypeSelector.jsx
frontend/src/components/Filters/index.js
frontend/src/components/Filters/ProximityFilters.jsx
frontend/src/components/Layout/Header.jsx
frontend/src/components/Layout/index.js
frontend/src/components/Map/HeatmapOverlay.jsx
frontend/src/components/Map/index.js
frontend/src/components/Map/MapView.jsx
frontend/src/components/Search/index.js
frontend/src/components/Search/SearchBar.jsx
frontend/src/hooks/index.js
frontend/src/hooks/useAnalysis.js
frontend/src/hooks/useFilters.js
frontend/src/hooks/useLocation.js
frontend/src/index.css
frontend/src/main.jsx
frontend/src/services/api.js
frontend/tailwind.config.js
frontend/vite.config.js
Hotspot_Logo-removebg-preview.png
README.md
repomix-output.md
TASKS.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
index.html
package.json
postcss.config.js
public/favicon.svg
public/hotspot-logo.png
public/icons/bank.svg
public/icons/bar.svg
public/icons/book.svg
public/icons/building.svg
public/icons/bus.svg
public/icons/cafe.svg
public/icons/clothing.svg
public/icons/college.svg
public/icons/electronics.svg
public/icons/gym.svg
public/icons/hospital.svg
public/icons/house.svg
public/icons/location-pin.svg
public/icons/mall.svg
public/icons/marker.svg
public/icons/metro.svg
public/icons/office.svg
public/icons/park.svg
public/icons/pharmacy.svg
public/icons/restaurant.svg
public/icons/salon.svg
public/icons/school.svg
public/icons/search.svg
public/icons/star.svg
public/icons/store.svg
public/icons/temple.svg
public/logo.svg
src/App.jsx
src/components/Chat/ChatBot.jsx
src/components/Chat/index.js
src/components/common/Icon.jsx
src/components/common/index.js
src/components/Dashboard/AnalysisPanel.jsx
src/components/Dashboard/Charts/CompetitorChart.jsx
src/components/Dashboard/Charts/index.js
src/components/Dashboard/Charts/LandmarkRadar.jsx
src/components/Dashboard/Charts/ScoreGauge.jsx
src/components/Dashboard/CompetitorCard.jsx
src/components/Dashboard/index.js
src/components/Dashboard/LandmarksCard.jsx
src/components/Dashboard/LoadingProgress.jsx
src/components/Dashboard/MetricsGrid.jsx
src/components/Dashboard/RecommendedSpotsCard.jsx
src/components/Dashboard/ScoreCard.jsx
src/components/Filters/BusinessTypeSelector.jsx
src/components/Filters/index.js
src/components/Filters/ProximityFilters.jsx
src/components/Layout/Header.jsx
src/components/Layout/index.js
src/components/Map/HeatmapOverlay.jsx
src/components/Map/index.js
src/components/Map/MapView.jsx
src/components/Search/index.js
src/components/Search/SearchBar.jsx
src/hooks/index.js
src/hooks/useAnalysis.js
src/hooks/useFilters.js
src/hooks/useLocation.js
src/index.css
src/main.jsx
src/services/api.js
tailwind.config.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Frontend Environment Variables
VITE_API_BASE_URL=http://localhost:5000/api
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/
build/

# Environment
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Cache
.cache/
.eslintcache
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hotspot IQ - Location Intelligence</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  </head>
  <body class="bg-canvas-deep text-slate-50 font-sans">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "hotspot-iq-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "leaflet": "^1.9.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-leaflet": "^4.2.1",
    "recharts": "^2.10.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "vite": "^5.0.8"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="public/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32">
  <defs>
    <linearGradient id="heatGrad" x1="0%" y1="100%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#F7B731"/>
      <stop offset="100%" style="stop-color:#EB5B3C"/>
    </linearGradient>
    <linearGradient id="pinGrad" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#1E3A5F"/>
      <stop offset="100%" style="stop-color:#0F2439"/>
    </linearGradient>
  </defs>
  
  <!-- Heatmap base -->
  <ellipse cx="16" cy="25" rx="14" ry="5" fill="#F7B731" opacity="0.9"/>
  <ellipse cx="16" cy="24" rx="10" ry="4" fill="#F5A623"/>
  <ellipse cx="16" cy="23" rx="6" ry="2.5" fill="#EB5B3C"/>
  
  <!-- Pin -->
  <path d="M16 3 C10.5 3 6 7.5 6 13 C6 18.5 16 26 16 26 C16 26 26 18.5 26 13 C26 7.5 21.5 3 16 3 Z" 
        fill="url(#pinGrad)"/>
  
  <!-- Inner circles -->
  <circle cx="16" cy="12" r="5" fill="white"/>
  <circle cx="16" cy="12" r="2.5" fill="#F5A623"/>
</svg>
</file>

<file path="public/icons/bank.svg">
<!-- Bank/ATM icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 16v4h56v-4L32 4zM8 24v28h8V24H8zm16 0v28h8V24h-8zm16 0v28h8V24h-8zm16 0v28h8V24h-8zM4 56v4h56v-4H4z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/bar.svg">
<!-- Bar/Drink icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 8v8l20 24v16H16v4h32v-4H36V40l20-24V8H8zm8 4h32l-16 20L16 12z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/book.svg">
<!-- Book icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M12 8v48c0 2.2 1.8 4 4 4h36V8H16c-2.2 0-4 1.8-4 4zm8 4h28v40H20V12zm4 8v4h20v-4H24zm0 8v4h20v-4H24z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/building.svg">
<!-- Building/Other icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 4v56h20V48h8v12h20V4H8zm8 8h8v8h-8v-8zm16 0h8v8h-8v-8zm16 0h8v8h-8v-8zM16 28h8v8h-8v-8zm16 0h8v8h-8v-8zm16 0h8v8h-8v-8z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/bus.svg">
<!-- Bus icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M12 8c-2.2 0-4 1.8-4 4v36c0 2.2 1.8 4 4 4h4v4h8v-4h16v4h8v-4h4c2.2 0 4-1.8 4-4V12c0-2.2-1.8-4-4-4H12zm4 8h32v16H16V16zm0 24c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm32 0c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/cafe.svg">
<!-- Cafe icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M48 16H12c-2.2 0-4 1.8-4 4v8c0 8.8 7.2 16 16 16h8c8.8 0 16-7.2 16-16v-4h4c2.2 0 4-1.8 4-4s-1.8-4-4-4h-4zm0 8h4v-4h-4v4zM8 52h48v4H8z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/clothing.svg">
<!-- Clothing icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M24 4l-16 12v12l8-4v36h32V24l8 4V16L40 4h-4c0 4.4-3.6 8-8 8s-8-3.6-8-8h-4v8c0 2.2 1.8 4 4 4h8c2.2 0 4-1.8 4-4V4h-8z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/college.svg">
<!-- College/University icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 18l28 14 28-14L32 4zM8 24v4l24 12 24-12v-4L32 36 8 24zm4 12v16l20 8 20-8V36l-20 10-20-10z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/electronics.svg">
<!-- Electronics icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M16 4c-2.2 0-4 1.8-4 4v40c0 2.2 1.8 4 4 4h4v4c0 2.2 1.8 4 4 4h16c2.2 0 4-1.8 4-4v-4h4c2.2 0 4-1.8 4-4V8c0-2.2-1.8-4-4-4H16zm4 8h24v28H20V12zm12 32c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/gym.svg">
<!-- Gym/Fitness icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M4 24v16h4v-4h4v4h4V24h-4v4H8v-4H4zm48 0v16h4v-4h4v4h4V24h-4v4h-4v-4h-4zM16 28v8h32v-8H16z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/hospital.svg">
<!-- Hospital icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 8v48h48V8H8zm20 8h8v12h12v8H36v12h-8V36H16v-8h12V16z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/house.svg">
<!-- House/Residential icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 32h8v24h16V40h8v16h16V32h8L32 4zm0 12l12 12v20H36V32h-8v16H20V28l12-12z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/location-pin.svg">
<!-- Location pin icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <defs>
    <linearGradient id="pinGrad" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#1E3A5F"/>
      <stop offset="100%" style="stop-color:#0F2439"/>
    </linearGradient>
  </defs>
  <path d="M32 4C20 4 10 14 10 26c0 16 22 34 22 34s22-18 22-34c0-12-10-22-22-22z" fill="url(#pinGrad)"/>
  <circle cx="32" cy="24" r="10" fill="white"/>
  <circle cx="32" cy="24" r="5" fill="#F5A623"/>
</svg>
</file>

<file path="public/icons/mall.svg">
<!-- Mall/Shopping icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M20 8l-4 16H8v4h48v-4h-8l-4-16H20zm-4 24v24h8V40h16v16h8V32H16zm8-20h16l2 8H22l2-8z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/marker.svg">
<!-- Competitor/Store marker icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4C20 4 10 14 10 26c0 16 22 34 22 34s22-18 22-34c0-12-10-22-22-22zm0 30c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/metro.svg">
<!-- Metro/Train icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M16 4c-4.4 0-8 3.6-8 8v32c0 4.4 3.6 8 8 8l-4 8h4l4-8h24l4 8h4l-4-8c4.4 0 8-3.6 8-8V12c0-4.4-3.6-8-8-8H16zm0 8h32v16H16V12zm4 24c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm24 0c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/office.svg">
<!-- Office/Building icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M12 4v56h16V48h8v12h16V4H12zm8 8h8v8h-8v-8zm16 0h8v8h-8v-8zm-16 16h8v8h-8v-8zm16 0h8v8h-8v-8z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/park.svg">
<!-- Park/Tree icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4c-8 0-16 8-16 20h-4l12 16h-6l14 20h4V44h-6l12-16h-4C44 12 40 4 32 4z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/pharmacy.svg">
<!-- Pharmacy/Medical icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M24 4v16H8v24h16v16h16V44h16V20H40V4H24zm4 20h8v8h8v8h-8v8h-8v-8h-8v-8h8v-8z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/restaurant.svg">
<!-- Restaurant icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M20 4c-1.1 0-2 .9-2 2v20c0 3.3 2.7 6 6 6v26c0 1.1.9 2 2 2h4c1.1 0 2-.9 2-2V32c3.3 0 6-2.7 6-6V6c0-1.1-.9-2-2-2s-2 .9-2 2v16h-4V6c0-1.1-.9-2-2-2s-2 .9-2 2v16h-4V6c0-1.1-.9-2-2-2zm24 0c-1.1 0-2 .9-2 2v22c0 2.8 1.6 5.2 4 6.3V58c0 1.1.9 2 2 2h4c1.1 0 2-.9 2-2V6c0-7.7-8-2-10-2z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/salon.svg">
<!-- Salon icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4C20 4 12 16 12 28c0 8 4 15 10 19v9c0 2.2 1.8 4 4 4h12c2.2 0 4-1.8 4-4v-9c6-4 10-11 10-19C52 16 44 4 32 4zm-4 28c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4zm8 0c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/school.svg">
<!-- School icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 20v4l28-12 28 12v-4L32 4zM8 28v28h16V40h16v16h16V28l-24-10L8 28z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/search.svg">
<!-- Search icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M28 8C16.96 8 8 16.96 8 28s8.96 20 20 20c4.44 0 8.56-1.48 11.9-3.96L51.04 55.2l5.66-5.66-11.14-11.14C48.04 35.06 48 31.58 48 28c0-11.04-8.96-20-20-20zm0 8c6.62 0 12 5.38 12 12s-5.38 12-12 12-12-5.38-12-12 5.38-12 12-12z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/star.svg">
<!-- Star/Recommended icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4l-9.17 18.58L4 25.82l13.42 13.08L14.17 58 32 48.42 49.83 58l-3.25-19.1L60 25.82l-18.83-3.24L32 4z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/store.svg">
<!-- Store/Retail icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 8v8l4 8v32h40V24l4-8V8H8zm8 16h8v16h-8V24zm16 0h8v16h-8V24z" fill="currentColor"/>
</svg>
</file>

<file path="public/icons/temple.svg">
<!-- Temple icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4l-4 8h-4l-8 12H8v4h4v28h8V36h24v20h8V28h4v-4h-8l-8-12h-4l-4-8zm0 12c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="public/logo.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
  <!-- Heatmap base (yellow to orange gradient rings) -->
  <defs>
    <linearGradient id="heatGradient" x1="0%" y1="100%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#F7B731;stop-opacity:1" />
      <stop offset="50%" style="stop-color:#F5A623;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#EB5B3C;stop-opacity:1" />
    </linearGradient>
    <linearGradient id="pinGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#1E3A5F;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#0F2439;stop-opacity:1" />
    </linearGradient>
  </defs>
  
  <!-- Heatmap rings (perspective transformed) -->
  <ellipse cx="50" cy="75" rx="45" ry="18" fill="#F7B731" opacity="0.9"/>
  <ellipse cx="50" cy="72" rx="35" ry="14" fill="#F5A623" opacity="0.95"/>
  <ellipse cx="50" cy="69" rx="25" ry="10" fill="#EB5B3C" opacity="1"/>
  <ellipse cx="50" cy="66" rx="15" ry="6" fill="#E74C3C" opacity="1"/>
  
  <!-- Location Pin -->
  <path d="M50 12 C35 12 24 23 24 38 C24 53 50 70 50 70 C50 70 76 53 76 38 C76 23 65 12 50 12 Z" 
        fill="url(#pinGradient)" 
        stroke="#1E3A5F" 
        stroke-width="1"/>
  
  <!-- Inner circle (white) -->
  <circle cx="50" cy="36" r="14" fill="white"/>
  
  <!-- Center dot (orange) -->
  <circle cx="50" cy="36" r="7" fill="#F5A623"/>
</svg>
</file>

<file path="src/App.jsx">
/**
 * App.jsx - Main Application Component
 * Hotspot IQ - Location Intelligence Platform
 */

import { useState, useCallback, useEffect } from 'react';

// Layout
import { Header } from './components/Layout';

// Components
import { BusinessTypeSelector } from './components/Filters';
import { SearchBar } from './components/Search';
import { MapView } from './components/Map';
import { AnalysisPanel, LoadingProgress } from './components/Dashboard';
import { ChatBot } from './components/Chat';

// Hooks
import { useAnalysis } from './hooks';

// API
import { geocodeLocation, reverseGeocode } from './services/api';

// Toast notification component
function Toast({ message, type = 'error', onClose }) {
  useEffect(() => {
    const timer = setTimeout(onClose, 8000); // Auto-close after 8 seconds
    return () => clearTimeout(timer);
  }, [onClose]);

  const bgColor = type === 'error'
    ? 'bg-red-500/95 border-red-400'
    : type === 'warning'
      ? 'bg-amber-500/95 border-amber-400'
      : 'bg-emerald-500/95 border-emerald-400';

  const icon = type === 'error' ? (
    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </svg>
  ) : type === 'warning' ? (
    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  ) : (
    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
    </svg>
  );

  return (
    <div className={`fixed top-20 left-1/2 transform -translate-x-1/2 z-50 ${bgColor} text-white px-6 py-4 rounded-xl shadow-2xl border-2 flex items-center gap-4 max-w-lg animate-slide-down`}>
      {icon}
      <div className="flex-1">
        <p className="font-semibold text-sm uppercase tracking-wide opacity-90">
          {type === 'error' ? 'Location Invalid' : type === 'warning' ? 'Warning' : 'Success'}
        </p>
        <p className="text-white/95 mt-1">{message}</p>
      </div>
      <button
        onClick={onClose}
        className="text-white/80 hover:text-white transition-colors p-1"
      >
        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
  );
}

export default function App() {
  // Theme state - default to dark mode
  const [isDarkMode, setIsDarkMode] = useState(() => {
    // Check localStorage for saved preference, default to dark
    const saved = localStorage.getItem('hotspotiq-theme');
    return saved ? saved === 'dark' : true;
  });

  // Toggle theme and save preference
  const toggleTheme = useCallback(() => {
    setIsDarkMode(prev => {
      const newMode = !prev;
      localStorage.setItem('hotspotiq-theme', newMode ? 'dark' : 'light');
      return newMode;
    });
  }, []);

  // Apply theme class to document
  useEffect(() => {
    if (isDarkMode) {
      document.documentElement.classList.add('dark');
      document.documentElement.classList.remove('light');
    } else {
      document.documentElement.classList.add('light');
      document.documentElement.classList.remove('dark');
    }
  }, [isDarkMode]);

  // Step 1: Business Type
  const [businessType, setBusinessType] = useState(null);

  // Step 2: Proximity Filters
  const [selectedFilters, setSelectedFilters] = useState([]);
  // Step 2.5: Radius
  const [radius, setRadius] = useState(1000);

  // Step 3: Selected Location
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [isGeocoding, setIsGeocoding] = useState(false);
  // Toast notification state
  const [toast, setToast] = useState(null);
  // Analysis state
  const {
    analysis,
    isochrone,
    isLoading,
    error,
    loadingStatus,
    analyze,
    clearAnalysis
  } = useAnalysis();

  // Panel state
  const [isPanelOpen, setIsPanelOpen] = useState(false);
  // Map display toggles
  const [showLandmarks, setShowLandmarks] = useState(true);
  const [showCompetitors, setShowCompetitors] = useState(true);
  const [isChatOpen, setIsChatOpen] = useState(false);

  // Handle location selection - geocode if needed
  const handleLocationSelect = useCallback(async (location) => {
    // If location already has coordinates, use it directly
    if (location.lat != null && location.lng != null) {
      setSelectedLocation(location);
      return;
    }

    // Otherwise, geocode the location name to get coordinates
    setIsGeocoding(true);
    try {
      const geocoded = await geocodeLocation(location.name);
      if (geocoded && geocoded.lat && geocoded.lng) {
        setSelectedLocation({
          name: location.name,
          lat: geocoded.lat,
          lng: geocoded.lng,
          address: geocoded.address,
          geoid: location.geoid,
          is_major: location.is_major || false,  // Preserve major area flag
          is_area: location.is_area || false,
        });
      } else {
        console.error('Geocoding returned no coordinates');
        // Show an alert or set an error state
        alert('Could not find coordinates for this location. Please try a different search.');
      }
    } catch (error) {
      console.error('Geocode error:', error);
      alert('Could not find coordinates for this location. Please try a different search.');
    } finally {
      setIsGeocoding(false);
    }
  }, []);

  // Handle map click - reverse geocode to get address
  const handleMapClick = useCallback(async (coords) => {
    // Set immediately with coordinates for responsiveness
    const tempName = `${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}`;
    setSelectedLocation({
      name: tempName,
      lat: coords.lat,
      lng: coords.lng,
    });

    // Reverse geocode using the selected radius to get area name for the whole region
    try {
      // Use the current radius for area-based reverse geocoding
      const result = await reverseGeocode(coords.lat, coords.lng, radius);
      if (result) {
        // Use area_name for display (cleaner, shows just the locality)
        // Fall back to formatted_address if area_name is not available
        const displayName = result.area_name || result.formatted_address || tempName;
        setSelectedLocation({
          name: displayName,
          lat: coords.lat,
          lng: coords.lng,
          pincode: result.pincode,
          landmark: result.landmark,
          fullAddress: result.formatted_address, // Keep full address for reference
          areasInRadius: result.areas_in_radius, // All areas found in the radius
        });
      }
    } catch (error) {
      console.error('Reverse geocode failed:', error);
      // Keep the coordinate-based name if reverse geocode fails
    }
  }, [radius]);

  // Update area name when radius changes (if we have a selected location)
  useEffect(() => {
    const updateAreaName = async () => {
      if (!selectedLocation?.lat || !selectedLocation?.lng) return;
      
      try {
        const result = await reverseGeocode(selectedLocation.lat, selectedLocation.lng, radius);
        if (result?.area_name) {
          setSelectedLocation(prev => ({
            ...prev,
            name: result.area_name,
            areasInRadius: result.areas_in_radius,
          }));
        }
      } catch (error) {
        console.error('Failed to update area name for new radius:', error);
      }
    };
    
    // Debounce the update to avoid too many API calls while sliding
    const timeoutId = setTimeout(updateAreaName, 500);
    return () => clearTimeout(timeoutId);
  }, [radius, selectedLocation?.lat, selectedLocation?.lng]);

  // Handle analyze button click
  const handleAnalyze = useCallback(async () => {
    if (!selectedLocation || !businessType) return;

    // Ensure we have coordinates
    if (selectedLocation.lat == null || selectedLocation.lng == null) {
      setToast({
        message: 'Location coordinates are missing. Please select a location from the search results.',
        type: 'warning'
      });
      return;
    }

    // Clear any existing toast
    setToast(null);

    // Run analysis (this clears markers internally before fetching)
    const result = await analyze(selectedLocation, businessType, selectedFilters, radius);

    // Handle validation errors
    if (!result.success) {
      if (result.isValidationError) {
        // Show validation error toast - map remains clear
        setToast({
          message: result.errorMessage,
          type: 'error'
        });
        // Don't open the panel on validation error
        return;
      }
      // For other errors, show warning toast
      setToast({
        message: result.errorMessage || 'Analysis failed. Please try again.',
        type: 'warning'
      });
      return;
    }

    // Success - open the panel
    setIsPanelOpen(true);
  }, [selectedLocation, businessType, selectedFilters, analyze, radius]);

  // Handle viewing a recommended spot on the map
  const handleViewSpot = useCallback((spot) => {
    // This will cause the map to pan to the spot location
    // We can show a temporary marker or highlight
    console.log('View spot:', spot);
    // The spot marker is already on the map, just close the panel so user can see it
    setIsPanelOpen(false);
  }, []);

  // Check if ready to analyze - need coordinates
  const canAnalyze = businessType && selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null && !isLoading && !isGeocoding;

  return (
    <div className="h-screen bg-canvas-base overflow-hidden">
      {/* Toast Notification for Validation Errors */}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          onClose={() => setToast(null)}
        />
      )}

      {/* Floating Header - Above everything */}
      <Header isDarkMode={isDarkMode} onToggleTheme={toggleTheme} />

      {/* Full-screen Map Layer */}
      <div className="absolute inset-0">
        <MapView
          selectedLocation={selectedLocation}
          competitors={analysis?.competitors?.nearby || []}
          landmarks={analysis?.landmarks?.list || []}
          recommendedSpots={analysis?.recommended_spots || []}
          isochrone={isochrone}
          onMapClick={handleMapClick}
          onSpotClick={handleViewSpot}
          showLandmarks={showLandmarks}
          showCompetitors={showCompetitors}
          setShowLandmarks={setShowLandmarks}
          setShowCompetitors={setShowCompetitors}
          businessType={businessType}
          radius={radius}
          analysis={analysis}
          onOpenPanel={() => setIsPanelOpen(true)}
          isLoading={isLoading}
          isDarkMode={isDarkMode}
        />
      </div>

      {/* Loading Progress - Fixed Top Right (above map controls) */}
      {(isLoading || loadingStatus.step === 'complete' || loadingStatus.step === 'error') && (
        <LoadingProgress status={loadingStatus} isLoading={isLoading} />
      )}

      {/* Command Panel - Left Sidebar */}
      <div className="fixed left-6 top-20 bottom-6 w-[340px] z-20 pointer-events-none">
        <div className="h-full backdrop-blur-xl bg-slate-900/80 border border-white/10 rounded-3xl shadow-2xl shadow-black/30 pointer-events-auto overflow-hidden flex flex-col">
          {/* Sidebar Header */}
          <div className="p-5 border-b border-white/5">
            <h2 className="text-lg font-semibold text-white flex items-center gap-2">
              <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-emerald-500 to-cyan-500 flex items-center justify-center">
                <svg className="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                </svg>
              </div>
              Location Analysis
            </h2>
            <p className="text-xs text-slate-500 mt-1">Configure your business search parameters</p>
          </div>

          {/* Scrollable Content */}
          <div className="flex-1 overflow-y-auto p-5 space-y-5">
            {/* Step 1: Location Search - Spotlight Style */}
            <div className="relative z-30">
              <SearchBar
                onLocationSelect={handleLocationSelect}
                disabled={false}
                selectedLocation={selectedLocation}
              />
            </div>

            {/* Step 2: Search Radius Slider */}
            <div className="space-y-3">
              <div className="flex justify-between items-center">
                <label className="text-sm font-medium text-slate-300">Search Radius</label>
                <span className="text-sm font-mono text-emerald-400 bg-emerald-500/10 px-3 py-1 rounded-full border border-emerald-500/20">
                  {radius >= 1000 ? `${(radius / 1000).toFixed(1)} km` : `${radius} m`}
                </span>
              </div>
              <input
                type="range"
                min="500"
                max="5000"
                step="100"
                value={radius}
                onChange={(e) => setRadius(parseInt(e.target.value))}
                className="w-full h-2 bg-slate-700/50 rounded-full appearance-none cursor-pointer accent-emerald-500"
              />
              <div className="flex justify-between text-[10px] text-slate-500">
                <span>0.5 km</span>
                <span>2.5 km</span>
                <span>5.0 km</span>
              </div>
            </div>

            {/* Step 3: Business Type - Icon Grid */}
            <div className="relative z-10">
              <BusinessTypeSelector
                value={businessType}
                onChange={(value) => {
                  setBusinessType(value);
                  clearAnalysis();
                }}
              />
            </div>
          </div>

          {/* Fixed Footer - Analyze Button */}
          <div className="p-5 border-t border-white/5 bg-slate-900/50">
            {selectedLocation ? (
              <button
                onClick={handleAnalyze}
                disabled={!canAnalyze}
                className={`
                  w-full py-4 rounded-xl text-base font-semibold transition-all duration-300
                  flex items-center justify-center gap-2
                  ${canAnalyze 
                    ? 'bg-gradient-to-r from-emerald-500 to-cyan-500 text-white hover:shadow-lg hover:shadow-emerald-500/25 hover:scale-[1.02] active:scale-[0.98]' 
                    : 'bg-slate-800 text-slate-500 cursor-not-allowed'}
                `}
              >
                {isLoading ? (
                  <>
                    <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    <span>Analyzing...</span>
                  </>
                ) : isGeocoding ? (
                  <>
                    <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    <span>Finding location...</span>
                  </>
                ) : (
                  <>
                    <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                    <span>Analyze Location</span>
                  </>
                )}
              </button>
            ) : (
              <div className="text-center text-sm text-slate-500 py-3">
                <p>Select a business type and location to begin</p>
              </div>
            )}
          </div>
        </div>
      </div>



      {/* Analysis Panel */}
      <AnalysisPanel
        analysis={analysis}
        isLoading={isLoading}
        isOpen={isPanelOpen}
        onClose={() => setIsPanelOpen(false)}
        onViewSpot={handleViewSpot}
        onOpenChat={() => setIsChatOpen(true)}
      />

      {/* Chat Bot */}
      <ChatBot
        selectedLocation={selectedLocation}
        businessType={businessType}
        analysis={analysis}
        isOpen={isChatOpen}
        onClose={() => setIsChatOpen(false)}
      />
    </div>
  );
}
</file>

<file path="src/components/Chat/ChatBot.jsx">
import React, { useState, useRef, useEffect } from 'react';
import { chat } from '../../services/api';

export const ChatBot = ({ selectedLocation, businessType, analysis, isOpen, onClose }) => {
    const [messages, setMessages] = useState([
        {
            role: 'assistant',
            content: 'Hi! I\'m Hotspot IQ. I can help you analyze locations and answer questions about your business expansion. How can I help you today?'
        }
    ]);
    const [input, setInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const messagesEndRef = useRef(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    useEffect(() => {
        if (isOpen) {
            scrollToBottom();
        }
    }, [messages, isOpen]);

    const handleSend = async (e) => {
        e.preventDefault();
        if (!input.trim()) return;

        const userMessage = input.trim();
        setInput('');
        setMessages(prev => [...prev, { role: 'user', content: userMessage }]);
        setIsLoading(true);

        try {
            const context = {
                lat: selectedLocation?.lat,
                lng: selectedLocation?.lng,
                business_type: businessType,
                analysis_data: analysis
            };

            const response = await chat(userMessage, context);

            setMessages(prev => [...prev, {
                role: 'assistant',
                content: response.response,
                isAi: response.ai_powered
            }]);
        } catch (error) {
            setMessages(prev => [...prev, {
                role: 'assistant',
                content: 'Sorry, I encountered an error. Please try again later.',
                isError: true
            }]);
        } finally {
            setIsLoading(false);
        }
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center pointer-events-auto">
            {/* Backdrop */}
            <div
                className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                onClick={onClose}
            />

            {/* Chat Window */}
            <div className="relative w-full max-w-lg h-[600px] glass-panel flex flex-col shadow-2xl animate-in zoom-in-95 fade-in duration-200 mx-4">
                {/* Header */}
                <div className="p-4 border-b border-surface-border flex justify-between items-center bg-surface-elevated/50">
                    <div className="flex items-center gap-2">
                        <div className="w-2 h-2 rounded-full bg-emerald-400 animate-pulse" />
                        <h3 className="font-semibold text-white">Hotspot IQ Assistant</h3>
                    </div>
                    <button
                        onClick={onClose}
                        className="text-slate-400 hover:text-white transition-colors"
                    >
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                {/* Messages */}
                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                    {messages.map((msg, idx) => (
                        <div
                            key={idx}
                            className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
                        >
                            <div
                                className={`
                max-w-[80%] p-3 rounded-2xl text-sm
                ${msg.role === 'user'
                                        ? 'bg-primary-glow/20 text-white rounded-tr-sm border border-primary-glow/30'
                                        : 'bg-surface-elevated text-slate-200 rounded-tl-sm border border-surface-border'
                                    }
                ${msg.isError ? 'border-destructive-glow/50 text-destructive-glow' : ''}
              `}
                            >
                                <p className="whitespace-pre-wrap">{msg.content}</p>
                                {msg.isAi && (
                                    <div className="mt-1 flex items-center gap-1 opacity-50">
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                                        </svg>
                                        <span className="text-[10px]">AI Powered</span>
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}
                    {isLoading && (
                        <div className="flex justify-start">
                            <div className="bg-surface-elevated p-3 rounded-2xl rounded-tl-sm border border-surface-border">
                                <div className="flex gap-1">
                                    <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                                    <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                                    <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                                </div>
                            </div>
                        </div>
                    )}
                    <div ref={messagesEndRef} />
                </div>

                {/* Input */}
                <form onSubmit={handleSend} className="p-4 border-t border-surface-border bg-surface-elevated/30">
                    <div className="relative">
                        <input
                            type="text"
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            placeholder="Ask about this location..."
                            className="w-full bg-surface-base border border-surface-border rounded-xl py-3 pl-4 pr-12 text-sm text-white placeholder-slate-500 focus:outline-none focus:border-primary-glow focus:ring-1 focus:ring-primary-glow transition-all"
                            disabled={isLoading}
                        />
                        <button
                            type="submit"
                            disabled={!input.trim() || isLoading}
                            className="absolute right-2 top-1/2 -translate-y-1/2 p-1.5 text-primary-glow hover:text-white disabled:opacity-50 disabled:hover:text-primary-glow transition-colors"
                        >
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                            </svg>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};
</file>

<file path="src/components/Chat/index.js">
export { ChatBot } from './ChatBot';
</file>

<file path="src/components/common/Icon.jsx">
/**
 * Icon Component
 * Renders SVG icons from the public/icons folder
 */

// Icon mapping for business types
export const BUSINESS_ICONS = {
  cafe: '/icons/cafe.svg',
  restaurant: '/icons/restaurant.svg',
  retail: '/icons/store.svg',
  gym: '/icons/gym.svg',
  pharmacy: '/icons/pharmacy.svg',
  salon: '/icons/salon.svg',
  electronics: '/icons/electronics.svg',
  clothing: '/icons/clothing.svg',
  bookstore: '/icons/book.svg',
  other: '/icons/building.svg',
};

// Icon mapping for proximity filters
export const PROXIMITY_ICONS = {
  near_metro: '/icons/metro.svg',
  near_bus: '/icons/bus.svg',
  near_school: '/icons/school.svg',
  near_college: '/icons/college.svg',
  near_hospital: '/icons/hospital.svg',
  near_mall: '/icons/mall.svg',
  near_office: '/icons/office.svg',
  near_residential: '/icons/house.svg',
  near_temple: '/icons/temple.svg',
  near_park: '/icons/park.svg',
  near_atm: '/icons/bank.svg',
  near_bar: '/icons/bar.svg',
};

// General icons
export const GENERAL_ICONS = {
  search: '/icons/search.svg',
  marker: '/icons/marker.svg',
  locationPin: '/icons/location-pin.svg',
  star: '/icons/star.svg',
};

/**
 * Icon component - renders SVG icons with customizable size and color
 */
export default function Icon({ 
  name, 
  src, 
  size = 24, 
  className = '',
  color = 'currentColor',
  style = {}
}) {
  // Determine the icon source
  const iconSrc = src || BUSINESS_ICONS[name] || PROXIMITY_ICONS[name] || GENERAL_ICONS[name];
  
  if (!iconSrc) {
    console.warn(`Icon not found: ${name}`);
    return null;
  }

  return (
    <img 
      src={iconSrc} 
      alt={name || 'icon'}
      width={size}
      height={size}
      className={`inline-block ${className}`}
      style={{ 
        filter: color !== 'currentColor' ? 'brightness(0) saturate(100%)' : undefined,
        ...style 
      }}
    />
  );
}

/**
 * Colored Icon component - applies color filter to SVG
 */
export function ColoredIcon({ 
  name, 
  src, 
  size = 24, 
  color = '#F5A623',
  className = '' 
}) {
  const iconSrc = src || BUSINESS_ICONS[name] || PROXIMITY_ICONS[name] || GENERAL_ICONS[name];
  
  if (!iconSrc) {
    return null;
  }

  // Convert hex color to CSS filter
  const getColorFilter = (hexColor) => {
    // Common color mappings
    const colorFilters = {
      '#F5A623': 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)', // orange
      '#10b981': 'invert(64%) sepia(44%) saturate(533%) hue-rotate(109deg) brightness(93%) contrast(88%)', // green
      '#f43f5e': 'invert(42%) sepia(93%) saturate(1352%) hue-rotate(326deg) brightness(99%) contrast(97%)', // red
      '#3b82f6': 'invert(47%) sepia(98%) saturate(1953%) hue-rotate(207deg) brightness(98%) contrast(94%)', // blue
      '#8b5cf6': 'invert(44%) sepia(94%) saturate(2670%) hue-rotate(243deg) brightness(95%) contrast(94%)', // purple
      '#ffffff': 'brightness(0) invert(1)', // white
      '#1E3A5F': 'invert(19%) sepia(29%) saturate(1039%) hue-rotate(178deg) brightness(92%) contrast(87%)', // dark blue
    };
    return colorFilters[hexColor] || '';
  };

  return (
    <img 
      src={iconSrc} 
      alt={name || 'icon'}
      width={size}
      height={size}
      className={`inline-block ${className}`}
      style={{ 
        filter: getColorFilter(color)
      }}
    />
  );
}
</file>

<file path="src/components/common/index.js">
/**
 * Common Components Index
 */

export { default as Icon, ColoredIcon, BUSINESS_ICONS, PROXIMITY_ICONS, GENERAL_ICONS } from './Icon';
</file>

<file path="src/components/Dashboard/AnalysisPanel.jsx">
/**
 * Analysis Panel Component
 * Combines all analysis cards in a slide-out panel
 */

import RecommendedSpotsCard from './RecommendedSpotsCard';
import CompetitorCard from './CompetitorCard';
import LandmarksCard from './LandmarksCard';

export default function AnalysisPanel({
  analysis,
  isLoading,
  isOpen,
  onClose,
  onViewSpot,
  onOpenChat
}) {
  if (!isOpen) return null;

  return (
    <>
      {/* Clickable backdrop - transparent, no blur to keep map visible */}
      <div
        className="fixed inset-0 z-40"
        onClick={onClose}
      />

      {/* Panel */}
      <div className="fixed right-0 top-0 h-full w-full max-w-md bg-slate-950/95 backdrop-blur-md border-l border-white/10 z-50 overflow-hidden flex flex-col animate-slide-in-right shadow-2xl shadow-black/50">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-white/10 bg-slate-900">
          <div>
            <h2 className="text-lg font-semibold text-slate-100">
              Location Analysis
            </h2>
            {analysis?.location && (
              <p className="text-sm text-slate-400 truncate max-w-[280px]">
                {analysis.location.name || analysis.address?.formatted_address || `${analysis.location.lat?.toFixed(4)}, ${analysis.location.lng?.toFixed(4)}`}
              </p>
            )}
          </div>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-surface-secondary transition-colors text-slate-400 hover:text-slate-200"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {/* Summary stats */}
          {!isLoading && analysis && (
            <div className="grid grid-cols-3 gap-2">
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-emerald-400">
                  {analysis?.recommended_spots?.length || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Optimal Spots
                </div>
              </div>
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-rose-400">
                  {analysis?.competitors?.count || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Competitors
                </div>
              </div>
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-cyan-400">
                  {analysis?.landmarks?.total || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Landmarks
                </div>
              </div>
            </div>
          )}

          {/* Recommended Spots - Primary focus */}
          <RecommendedSpotsCard
            spots={analysis?.recommended_spots || []}
            isLoading={isLoading}
            onViewSpot={onViewSpot}
          />

          {/* Competitors */}
          <CompetitorCard
            competitors={analysis?.competitors?.nearby || []}
            isLoading={isLoading}
          />

          {/* Landmarks */}
          <LandmarksCard
            landmarks={analysis?.landmarks?.list || []}
            isLoading={isLoading}
          />

          {/* DIGIPIN */}
          {!isLoading && analysis?.location?.digipin && (
            <div className="glass-panel p-4">
              <h3 className="text-sm font-medium text-slate-400 mb-2 flex items-center gap-2">
                <img src="/icons/location-pin.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
                DIGIPIN
              </h3>
              <div className="bg-surface-secondary rounded-lg p-3">
                <p className="font-mono text-primary-glow text-lg tracking-wider text-center">
                  {analysis.location.digipin}
                </p>
              </div>
              <p className="text-xs text-slate-500 mt-2 text-center">
                India Post digital address
              </p>
            </div>
          )}
        </div>

        {/* Footer actions */}
        <div className="p-4 border-t border-surface-border bg-surface-elevated">
          <div className="grid grid-cols-2 gap-3">
            <button className="px-4 py-2 bg-surface-secondary text-slate-300 rounded-lg hover:bg-slate-700 transition-colors text-sm">
              Export Report
            </button>
            <button
              onClick={onOpenChat}
              className="btn-primary text-sm"
            >
              Ask AI Assistant
            </button>
          </div>
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/components/Dashboard/Charts/CompetitorChart.jsx">
/**
 * Competitor Chart Component
 * Bar chart showing competitor distribution by category
 */

import { useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  Cell,
} from 'recharts';

// Category colors
const CATEGORY_COLORS = {
  cafe: '#10b981',
  restaurant: '#f59e0b',
  retail: '#3b82f6',
  gym: '#8b5cf6',
  pharmacy: '#ec4899',
  salon: '#14b8a6',
  electronics: '#6366f1',
  clothing: '#f43f5e',
  default: '#64748b',
};

// Custom tooltip
const CustomTooltip = ({ active, payload }) => {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;
  return (
    <div className="bg-canvas-base border border-surface-border rounded-lg p-3 shadow-glass">
      <p className="text-slate-200 font-medium">{data.name}</p>
      <p className="text-sm text-slate-400">
        <span className="text-destructive-glow font-semibold">{data.count}</span> competitors
      </p>
    </div>
  );
};

export default function CompetitorChart({ competitors = [], isLoading }) {
  // Safely convert to array
  const competitorList = Array.isArray(competitors) ? competitors : [];
  
  // Group competitors by category
  const chartData = useMemo(() => {
    const grouped = competitorList.reduce((acc, competitor) => {
      const category = competitor.category?.toLowerCase() || 'other';
      if (!acc[category]) {
        acc[category] = { name: category, count: 0 };
      }
      acc[category].count++;
      return acc;
    }, {});

    return Object.values(grouped)
      .sort((a, b) => b.count - a.count)
      .slice(0, 6); // Top 6 categories
  }, [competitorList]);

  if (isLoading) {
    return (
      <div className="glass-panel p-4">
        <div className="h-4 bg-slate-700 rounded w-32 mb-4 animate-pulse" />
        <div className="h-48 bg-slate-700/30 rounded animate-pulse" />
      </div>
    );
  }

  if (competitorList.length === 0) {
    return (
      <div className="glass-panel p-4">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/store.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
          Competitor Distribution
        </h3>
        <div className="h-48 flex items-center justify-center text-slate-500">
          <div className="text-center">
            <img src="/icons/star.svg" alt="" className="w-8 h-8 mx-auto mb-2" style={{ filter: 'invert(74%) sepia(52%) saturate(579%) hue-rotate(93deg) brightness(95%) contrast(88%)' }} />
            <p>No competitors to show</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="glass-panel p-4">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <img src="/icons/store.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
        Competitor Distribution
      </h3>
      
      <div className="h-48">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            layout="vertical"
            margin={{ top: 0, right: 0, bottom: 0, left: 0 }}
          >
            <XAxis 
              type="number" 
              hide 
              domain={[0, 'dataMax + 1']}
            />
            <YAxis
              type="category"
              dataKey="name"
              width={80}
              tick={{ fill: '#94a3b8', fontSize: 12 }}
              axisLine={false}
              tickLine={false}
              tickFormatter={(value) => 
                value.charAt(0).toUpperCase() + value.slice(1)
              }
            />
            <Tooltip content={<CustomTooltip />} cursor={false} />
            <Bar
              dataKey="count"
              radius={[0, 4, 4, 0]}
              maxBarSize={24}
            >
              {chartData.map((entry, index) => (
                <Cell
                  key={`cell-${index}`}
                  fill={CATEGORY_COLORS[entry.name] || CATEGORY_COLORS.default}
                  fillOpacity={0.8}
                />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </div>
      
      {/* Legend */}
      <div className="flex flex-wrap gap-2 mt-3 pt-3 border-t border-surface-border">
        {chartData.map((item) => (
          <div key={item.name} className="flex items-center gap-1.5 text-xs">
            <div
              className="w-2.5 h-2.5 rounded-sm"
              style={{ backgroundColor: CATEGORY_COLORS[item.name] || CATEGORY_COLORS.default }}
            />
            <span className="text-slate-500 capitalize">{item.name}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Dashboard/Charts/index.js">
export { default as CompetitorChart } from './CompetitorChart';
export { default as LandmarkRadar } from './LandmarkRadar';
export { default as ScoreGauge } from './ScoreGauge';
</file>

<file path="src/components/Dashboard/Charts/LandmarkRadar.jsx">
/**
 * Landmark Radar Chart Component
 * Radar chart showing landmark category distribution
 */

import { useMemo } from 'react';
import {
  RadarChart,
  PolarGrid,
  PolarAngleAxis,
  PolarRadiusAxis,
  Radar,
  ResponsiveContainer,
  Tooltip,
} from 'recharts';

// Category configuration
const CATEGORY_CONFIG = {
  metro_station: { label: 'Metro', maxScore: 5 },
  bus_stop: { label: 'Bus', maxScore: 10 },
  school: { label: 'School', maxScore: 8 },
  college: { label: 'College', maxScore: 5 },
  hospital: { label: 'Hospital', maxScore: 5 },
  mall: { label: 'Mall', maxScore: 3 },
  office: { label: 'Office', maxScore: 10 },
  residential: { label: 'Residential', maxScore: 15 },
  temple: { label: 'Temple', maxScore: 5 },
  park: { label: 'Park', maxScore: 5 },
};

// Custom tooltip
const CustomTooltip = ({ active, payload }) => {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;
  return (
    <div className="bg-canvas-base border border-surface-border rounded-lg p-3 shadow-glass">
      <p className="text-slate-200 font-medium">{data.fullLabel}</p>
      <p className="text-sm text-slate-400">
        <span className="text-primary-glow font-semibold">{data.count}</span> nearby
      </p>
    </div>
  );
};

export default function LandmarkRadar({ landmarks = [], isLoading }) {
  // Safely convert to array
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  
  // Process landmarks into radar data
  const chartData = useMemo(() => {
    // Count landmarks by category
    const counts = landmarkList.reduce((acc, landmark) => {
      const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'other';
      acc[category] = (acc[category] || 0) + 1;
      return acc;
    }, {});

    // Convert to chart format with normalized values
    return Object.entries(CATEGORY_CONFIG).map(([key, config]) => {
      const count = counts[key] || 0;
      const normalized = Math.min(100, (count / config.maxScore) * 100);
      return {
        category: config.label,
        fullLabel: config.label,
        value: normalized,
        count,
      };
    });
  }, [landmarkList]);

  if (isLoading) {
    return (
      <div className="glass-panel p-4">
        <div className="h-4 bg-slate-700 rounded w-32 mb-4 animate-pulse" />
        <div className="h-64 bg-slate-700/30 rounded-full animate-pulse mx-auto w-64" />
      </div>
    );
  }

  if (landmarkList.length === 0) {
    return (
      <div className="glass-panel p-4">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Landmark Coverage
        </h3>
        <div className="h-64 flex items-center justify-center text-slate-500">
          <div className="text-center">
            <img src="/icons/marker.svg" alt="" className="w-8 h-8 mx-auto mb-2 opacity-50" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
            <p>No landmarks detected</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="glass-panel p-4">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <img src="/icons/star.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
        Landmark Coverage
      </h3>
      
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <RadarChart data={chartData} margin={{ top: 20, right: 30, bottom: 20, left: 30 }}>
            <PolarGrid 
              stroke="#334155" 
              strokeOpacity={0.5}
            />
            <PolarAngleAxis
              dataKey="category"
              tick={{ fill: '#94a3b8', fontSize: 11 }}
              tickLine={false}
            />
            <PolarRadiusAxis
              angle={90}
              domain={[0, 100]}
              tick={false}
              axisLine={false}
            />
            <Tooltip content={<CustomTooltip />} />
            <Radar
              name="Coverage"
              dataKey="value"
              stroke="#10b981"
              fill="#10b981"
              fillOpacity={0.3}
              strokeWidth={2}
            />
          </RadarChart>
        </ResponsiveContainer>
      </div>
      
      {/* Summary */}
      <div className="mt-3 pt-3 border-t border-surface-border">
        <div className="flex items-center justify-between text-xs">
          <span className="text-slate-500">Total landmarks detected</span>
          <span className="text-primary-glow font-semibold">{landmarkList.length}</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Dashboard/Charts/ScoreGauge.jsx">
/**
 * Score Gauge Component
 * Circular gauge visualization for opportunity score
 */

import { useMemo } from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer } from 'recharts';

export default function ScoreGauge({ score = 0, size = 'md', showLabel = true, isLoading }) {
  const normalizedScore = Math.min(100, Math.max(0, score));
  
  // Determine color based on score
  const scoreColor = useMemo(() => {
    if (normalizedScore >= 70) return '#10b981'; // Green - Excellent
    if (normalizedScore >= 50) return '#06b6d4'; // Cyan - Good
    if (normalizedScore >= 30) return '#f59e0b'; // Amber - Fair
    return '#f43f5e'; // Rose - Poor
  }, [normalizedScore]);

  const scoreLabel = useMemo(() => {
    if (normalizedScore >= 70) return 'Excellent';
    if (normalizedScore >= 50) return 'Good';
    if (normalizedScore >= 30) return 'Fair';
    return 'Poor';
  }, [normalizedScore]);

  // Chart data for gauge effect
  const data = [
    { name: 'score', value: normalizedScore },
    { name: 'remaining', value: 100 - normalizedScore },
  ];

  // Size configurations
  const sizes = {
    sm: { width: 100, height: 100, inner: 35, outer: 45, fontSize: 'text-xl' },
    md: { width: 160, height: 160, inner: 55, outer: 70, fontSize: 'text-3xl' },
    lg: { width: 200, height: 200, inner: 70, outer: 90, fontSize: 'text-4xl' },
  };

  const config = sizes[size] || sizes.md;

  if (isLoading) {
    return (
      <div 
        className="relative flex items-center justify-center"
        style={{ width: config.width, height: config.height }}
      >
        <div 
          className="absolute rounded-full border-8 border-slate-700 animate-pulse"
          style={{ 
            width: config.outer * 2, 
            height: config.outer * 2,
          }}
        />
        <div className="w-8 h-8 border-2 border-slate-600 border-t-primary-glow rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div 
      className="relative"
      style={{ width: config.width, height: config.height }}
    >
      <ResponsiveContainer width="100%" height="100%">
        <PieChart>
          <Pie
            data={data}
            cx="50%"
            cy="50%"
            startAngle={180}
            endAngle={0}
            innerRadius={config.inner}
            outerRadius={config.outer}
            paddingAngle={0}
            dataKey="value"
            stroke="none"
          >
            <Cell fill={scoreColor} />
            <Cell fill="#1e293b" />
          </Pie>
        </PieChart>
      </ResponsiveContainer>
      
      {/* Center content */}
      <div className="absolute inset-0 flex flex-col items-center justify-center">
        <span 
          className={`font-bold ${config.fontSize} transition-colors duration-500`}
          style={{ color: scoreColor }}
        >
          {normalizedScore}
        </span>
        {showLabel && (
          <span 
            className="text-xs font-medium transition-colors duration-500 -mt-1"
            style={{ color: scoreColor }}
          >
            {scoreLabel}
          </span>
        )}
      </div>
      
      {/* Scale markers */}
      <div className="absolute bottom-0 left-0 right-0 flex justify-between px-2 text-xs text-slate-600">
        <span>0</span>
        <span>50</span>
        <span>100</span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Dashboard/CompetitorCard.jsx">
/**
 * Competitor Card Component
 * Displays nearby competitors with distance information
 */

import { useState } from 'react';

export default function CompetitorCard({ competitors = [], isLoading }) {
  const [showAll, setShowAll] = useState(false);
  
  // Ensure competitors is an array
  const competitorList = Array.isArray(competitors) ? competitors : [];
  
  // Sort by distance (closest first)
  const sortedCompetitors = [...competitorList].sort((a, b) => 
    (a.distance || 9999) - (b.distance || 9999)
  );
  
  // Show first 20 or all based on toggle
  const displayCount = showAll ? sortedCompetitors.length : Math.min(20, sortedCompetitors.length);
  const displayedCompetitors = sortedCompetitors.slice(0, displayCount);

  const getDistanceColor = (distance) => {
    if (distance <= 200) return 'text-destructive-glow';
    if (distance <= 500) return 'text-warning-glow';
    return 'text-slate-400';
  };

  const getDistanceLabel = (distance) => {
    if (distance >= 1000) {
      return `${(distance / 1000).toFixed(1)}km`;
    }
    return `${distance}m`;
  };

  return (
    <div className="glass-panel p-5">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <img src="/icons/store.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(42%) sepia(93%) saturate(1352%) hue-rotate(326deg) brightness(99%) contrast(97%)' }} />
          Nearby Competitors
        </h3>
        {!isLoading && (
          <span className="text-xs bg-destructive-glow/20 text-destructive-glow px-2 py-1 rounded-full">
            {competitors.length} found
          </span>
        )}
      </div>

      {isLoading ? (
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="flex items-center gap-3">
              <div className="w-8 h-8 bg-slate-700 rounded-full animate-pulse" />
              <div className="flex-1">
                <div className="h-4 bg-slate-700 rounded animate-pulse w-3/4 mb-1" />
                <div className="h-3 bg-slate-700/50 rounded animate-pulse w-1/2" />
              </div>
            </div>
          ))}
        </div>
      ) : competitors.length === 0 ? (
        <div className="text-center py-6">
          <img src="/icons/star.svg" alt="" className="w-8 h-8 mx-auto mb-2" style={{ filter: 'invert(74%) sepia(52%) saturate(579%) hue-rotate(93deg) brightness(95%) contrast(88%)' }} />
          <p className="text-slate-400 text-sm">No competitors nearby!</p>
          <p className="text-slate-500 text-xs mt-1">Great opportunity zone</p>
        </div>
      ) : (
        <div className="space-y-2">
          <div className="max-h-80 overflow-y-auto space-y-2 pr-1">
            {displayedCompetitors.map((competitor, index) => (
              <div 
                key={index}
                className="flex items-start gap-3 p-2 rounded-lg hover:bg-surface-secondary transition-colors"
              >
                {/* Index badge */}
                <div className="w-6 h-6 bg-destructive-glow/20 text-destructive-glow rounded-full flex items-center justify-center text-xs font-medium flex-shrink-0">
                  {index + 1}
                </div>
                
                {/* Competitor info */}
                <div className="flex-1 min-w-0">
                  <p className="text-slate-200 text-sm truncate">{competitor.name}</p>
                  <p className="text-slate-500 text-xs truncate">{competitor.category}</p>
                </div>
                
                {/* Distance */}
                {competitor.distance !== undefined && (
                  <span className={`text-xs font-mono flex-shrink-0 ${getDistanceColor(competitor.distance)}`}>
                    {getDistanceLabel(competitor.distance)}
                  </span>
                )}
              </div>
            ))}
          </div>
          
          {/* Show more/less toggle */}
          {sortedCompetitors.length > 20 && (
            <button
              onClick={() => setShowAll(!showAll)}
              className="w-full text-center text-xs text-primary-glow hover:text-primary-glow/80 py-2 transition-colors"
            >
              {showAll 
                ? ` Show less` 
                : ` Show all ${sortedCompetitors.length} competitors`}
            </button>
          )}
        </div>
      )}
      
      {/* Competition density indicator */}
      {!isLoading && competitors.length > 0 && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <div className="flex items-center justify-between text-xs">
            <span className="text-slate-500">Competition Level</span>
            <span className={
              competitors.length >= 10 ? 'text-destructive-glow' :
              competitors.length >= 5 ? 'text-warning-glow' :
              'text-primary-glow'
            }>
              {competitors.length >= 10 ? 'High' : competitors.length >= 5 ? 'Medium' : 'Low'}
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Dashboard/index.js">
export { default as ScoreCard } from './ScoreCard';
export { default as CompetitorCard } from './CompetitorCard';
export { default as LandmarksCard } from './LandmarksCard';
export { default as AnalysisPanel } from './AnalysisPanel';
export { default as MetricsGrid } from './MetricsGrid';
export { default as LoadingProgress } from './LoadingProgress';
export { default as RecommendedSpotsCard } from './RecommendedSpotsCard';
export * from './Charts';
</file>

<file path="src/components/Dashboard/LandmarksCard.jsx">
/**
 * Landmarks Card Component
 * Displays nearby landmarks grouped by category with footfall indicators
 */

import { useState } from 'react';

// Landmark category icons and weights - using SVG icons
const CATEGORY_CONFIG = {
  metro_station: { icon: '/icons/metro.svg', label: 'Metro Station', weight: 5 },
  metro: { icon: '/icons/metro.svg', label: 'Metro Station', weight: 5 },
  bus_stop: { icon: '/icons/bus.svg', label: 'Bus Stop', weight: 3 },
  bus: { icon: '/icons/bus.svg', label: 'Bus Stop', weight: 3 },
  railway_station: { icon: '/icons/metro.svg', label: 'Railway', weight: 5 },
  railway: { icon: '/icons/metro.svg', label: 'Railway', weight: 5 },
  school: { icon: '/icons/school.svg', label: 'School', weight: 4 },
  college: { icon: '/icons/college.svg', label: 'College', weight: 4 },
  university: { icon: '/icons/college.svg', label: 'University', weight: 4 },
  hospital: { icon: '/icons/hospital.svg', label: 'Hospital', weight: 4 },
  clinic: { icon: '/icons/hospital.svg', label: 'Clinic', weight: 3 },
  mall: { icon: '/icons/mall.svg', label: 'Mall', weight: 5 },
  office: { icon: '/icons/office.svg', label: 'Office', weight: 4 },
  residential: { icon: '/icons/house.svg', label: 'Residential', weight: 3 },
  temple: { icon: '/icons/temple.svg', label: 'Temple/Church', weight: 3 },
  church: { icon: '/icons/temple.svg', label: 'Church', weight: 3 },
  mosque: { icon: '/icons/temple.svg', label: 'Mosque', weight: 3 },
  park: { icon: '/icons/park.svg', label: 'Park', weight: 2 },
  atm: { icon: '/icons/bank.svg', label: 'ATM', weight: 2 },
  bank: { icon: '/icons/bank.svg', label: 'Bank', weight: 3 },
  bar: { icon: '/icons/bar.svg', label: 'Bar/Pub', weight: 3 },
  pub: { icon: '/icons/bar.svg', label: 'Bar/Pub', weight: 3 },
  restaurant: { icon: '/icons/restaurant.svg', label: 'Restaurant', weight: 3 },
  cafe: { icon: '/icons/cafe.svg', label: 'Cafe', weight: 3 },
  hotel: { icon: '/icons/building.svg', label: 'Hotel', weight: 4 },
  pharmacy: { icon: '/icons/pharmacy.svg', label: 'Pharmacy', weight: 3 },
  gym: { icon: '/icons/gym.svg', label: 'Gym', weight: 3 },
  supermarket: { icon: '/icons/mall.svg', label: 'Supermarket', weight: 3 },
  nearby: { icon: '/icons/marker.svg', label: 'Nearby Places', weight: 2 },
  // Default fallback
  default: { icon: '/icons/marker.svg', label: 'Other', weight: 1 },
};

export default function LandmarksCard({ landmarks = [], isLoading }) {
  const [showAllLandmarks, setShowAllLandmarks] = useState(false);
  
  // Ensure landmarks is an array
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  
  // Group landmarks by category
  const groupedLandmarks = landmarkList.reduce((acc, landmark) => {
    const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
    if (!acc[category]) {
      acc[category] = [];
    }
    acc[category].push(landmark);
    return acc;
  }, {});

  // Sort categories by weight (highest first)
  const sortedCategories = Object.entries(groupedLandmarks).sort((a, b) => {
    const configA = CATEGORY_CONFIG[a[0]] || CATEGORY_CONFIG.default;
    const configB = CATEGORY_CONFIG[b[0]] || CATEGORY_CONFIG.default;
    return configB.weight - configA.weight;
  });

  // Calculate total footfall value
  const totalFootfallValue = landmarkList.reduce((total, landmark) => {
    const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
    const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
    return total + config.weight;
  }, 0);

  const getFootfallLevel = (value) => {
    if (value >= 30) return { label: 'High', color: 'text-primary-glow' };
    if (value >= 15) return { label: 'Medium', color: 'text-accent-glow' };
    return { label: 'Low', color: 'text-warning-glow' };
  };

  return (
    <div className="glass-panel p-5">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <img src="/icons/building.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)' }} />
          Nearby Landmarks
        </h3>
        {!isLoading && (
          <span className="text-xs bg-primary-glow/20 text-primary-glow px-2 py-1 rounded-full">
            {landmarkList.length} found
          </span>
        )}
      </div>

      {isLoading ? (
        <div className="space-y-3">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="flex items-center gap-3">
              <div className="w-8 h-8 bg-slate-700 rounded-lg animate-pulse" />
              <div className="flex-1">
                <div className="h-4 bg-slate-700 rounded animate-pulse w-20 mb-1" />
                <div className="h-3 bg-slate-700/50 rounded animate-pulse w-12" />
              </div>
            </div>
          ))}
        </div>
      ) : landmarkList.length === 0 ? (
        <div className="text-center py-6">
          <img src="/icons/marker.svg" alt="" className="w-8 h-8 mx-auto mb-2 opacity-50" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
          <p className="text-slate-400 text-sm">No landmarks nearby</p>
          <p className="text-slate-500 text-xs mt-1">May indicate low footfall area</p>
        </div>
      ) : (
        <div className="space-y-2">
          {/* Category Summary */}
          <div className="space-y-2 max-h-48 overflow-y-auto">
            {sortedCategories.map(([category, items]) => {
              const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
              return (
                <div 
                  key={category}
                  className="flex items-center gap-3 p-2 rounded-lg hover:bg-surface-secondary transition-colors"
                >
                  {/* Category icon */}
                  <div className="w-8 h-8 bg-surface-secondary rounded-lg flex items-center justify-center">
                    <img 
                      src={config.icon} 
                      alt="" 
                      className="w-5 h-5"
                      style={{ filter: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)' }}
                    />
                  </div>
                  
                  {/* Category info */}
                  <div className="flex-1 min-w-0">
                    <p className="text-slate-200 text-sm">{config.label}</p>
                    <p className="text-slate-500 text-xs">{items.length} nearby</p>
                  </div>
                  
                  {/* Weight indicator */}
                  <div className="flex gap-0.5">
                    {[1, 2, 3, 4, 5].map((dot) => (
                      <div
                        key={dot}
                        className={`w-1.5 h-1.5 rounded-full ${
                          dot <= config.weight ? 'bg-primary-glow' : 'bg-slate-700'
                        }`}
                      />
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
          
          {/* Show All Landmarks Button */}
          {showAllLandmarks ? (
            <div className="mt-3 pt-3 border-t border-surface-border">
              <button
                onClick={() => setShowAllLandmarks(false)}
                className="text-xs text-primary-glow hover:text-primary-glow/80 mb-2"
              >
                 Hide individual landmarks
              </button>
              <div className="space-y-1 max-h-48 overflow-y-auto">
                {landmarkList.map((landmark, idx) => {
                  const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
                  const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
                  return (
                    <div key={idx} className="flex items-center gap-2 p-1.5 text-xs rounded hover:bg-surface-secondary">
                      <img 
                        src={config.icon} 
                        alt="" 
                        className="w-4 h-4 flex-shrink-0"
                        style={{ filter: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)' }}
                      />
                      <span className="text-slate-300 truncate flex-1">{landmark.name}</span>
                      {landmark.distance && (
                        <span className="text-slate-500">{landmark.distance}m</span>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <button
              onClick={() => setShowAllLandmarks(true)}
              className="w-full text-xs text-primary-glow hover:text-primary-glow/80 mt-2 py-1"
            >
               Show all {landmarkList.length} landmarks
            </button>
          )}
        </div>
      )}
      
      {/* Footfall value indicator */}
      {!isLoading && landmarkList.length > 0 && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <div className="flex items-center justify-between text-xs">
            <span className="text-slate-500">Footfall Potential</span>
            <span className={getFootfallLevel(totalFootfallValue).color}>
              {getFootfallLevel(totalFootfallValue).label}
              <span className="text-slate-600 ml-1">({totalFootfallValue} pts)</span>
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Dashboard/LoadingProgress.jsx">
/**
 * LoadingProgress Component - Compact Top-Right Loader
 * Glass-morphic floating card showing dynamic step-by-step progress
 */

// Define all analysis steps in order
const ANALYSIS_STEPS = [
  { id: 'validation', label: 'Validating location', icon: '' },
  { id: 'boundary', label: 'Area boundary loaded', icon: '' },
  { id: 'analysis', label: 'Analyzing location', icon: '' },
  { id: 'competitors', label: 'Competitors found', icon: '' },
  { id: 'landmarks', label: 'Landmarks identified', icon: '' },
  { id: 'digipin', label: 'Location code retrieved', icon: '' },
  { id: 'spots', label: 'Optimal spots found', icon: '' },
];

// Get step index for comparison
const getStepIndex = (stepId) => {
  const index = ANALYSIS_STEPS.findIndex(s => s.id === stepId);
  return index === -1 ? -1 : index;
};

export default function LoadingProgress({ status, isLoading }) {
  if (!isLoading && status.step === '') return null;

  const { step, message, progress, details } = status;

  // Don't render if complete and not loading
  if (step === 'complete' && !isLoading) return null;

  const currentStepIndex = getStepIndex(step);

  return (
    <div className="fixed top-6 right-6 z-50 animate-fadeIn">
      <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 shadow-2xl shadow-black/30 min-w-[300px] max-w-[340px]">
        {/* Header with spinner */}
        <div className="flex items-center gap-3 mb-3">
          {/* Spinning Emerald Ring */}
          {isLoading && step !== 'complete' && step !== 'error' && (
            <div className="relative w-10 h-10 flex-shrink-0">
              <div className="absolute inset-0 rounded-full border-2 border-emerald-500/20" />
              <div className="absolute inset-0 rounded-full border-2 border-transparent border-t-emerald-400 animate-spin" />
              <div className="absolute inset-2 rounded-full bg-emerald-500/10 flex items-center justify-center">
                <div className="w-2 h-2 rounded-full bg-emerald-400 animate-pulse" />
              </div>
            </div>
          )}
          
          {/* Completion icon */}
          {step === 'complete' && (
            <div className="w-10 h-10 rounded-full bg-emerald-500/20 border border-emerald-500/30 flex items-center justify-center flex-shrink-0">
              <svg className="w-5 h-5 text-emerald-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            </div>
          )}
          
          {/* Error icon */}
          {step === 'error' && (
            <div className="w-10 h-10 rounded-full bg-rose-500/20 border border-rose-500/30 flex items-center justify-center flex-shrink-0">
              <svg className="w-5 h-5 text-rose-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </div>
          )}

          {/* Status text */}
          <div className="flex-1 min-w-0">
            <p className="text-sm font-medium text-white truncate">
              {step === 'complete' ? 'Analysis Complete!' : step === 'error' ? 'Analysis Failed' : 'Processing...'}
            </p>
            <p className="text-xs text-slate-400 truncate">{message}</p>
          </div>

          {/* Progress percentage */}
          <div className="text-right flex-shrink-0">
            <span className="text-lg font-bold text-emerald-400">{progress}%</span>
          </div>
        </div>

        {/* Progress Bar */}
        <div className="h-1.5 bg-slate-800 rounded-full overflow-hidden mb-3">
          <div 
            className="h-full bg-gradient-to-r from-emerald-500 via-cyan-400 to-emerald-500 transition-all duration-500 ease-out rounded-full"
            style={{ width: `${progress}%` }}
          />
        </div>

        {/* Step-by-step checklist */}
        <div className="space-y-1.5 max-h-[200px] overflow-y-auto">
          {ANALYSIS_STEPS.map((analysisStep, index) => {
            const stepIndex = getStepIndex(analysisStep.id);
            const isCompleted = currentStepIndex > stepIndex || step === 'complete';
            const isCurrent = currentStepIndex === stepIndex && step !== 'complete' && step !== 'error';
            const isPending = currentStepIndex < stepIndex && step !== 'complete';
            
            // Get dynamic detail from the details array for completed steps
            const detail = details.find(d => d.includes(analysisStep.icon));
            const displayLabel = detail ? detail.replace(analysisStep.icon, '').trim() : analysisStep.label;
            
            return (
              <div 
                key={analysisStep.id} 
                className={`flex items-center gap-2.5 text-xs py-1 px-2 rounded-lg transition-all duration-300 ${
                  isCompleted ? 'bg-emerald-500/10 text-emerald-400' :
                  isCurrent ? 'bg-cyan-500/10 text-cyan-400' :
                  'bg-transparent text-slate-500'
                }`}
              >
                {/* Status indicator */}
                <div className="flex-shrink-0 w-5 h-5 flex items-center justify-center">
                  {isCompleted ? (
                    <div className="w-4 h-4 rounded-full bg-emerald-500/30 border border-emerald-400/50 flex items-center justify-center">
                      <svg className="w-2.5 h-2.5 text-emerald-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
                      </svg>
                    </div>
                  ) : isCurrent ? (
                    <div className="w-4 h-4 rounded-full border-2 border-cyan-400/50 border-t-cyan-400 animate-spin" />
                  ) : (
                    <div className="w-3 h-3 rounded-full border border-slate-600 bg-slate-800/50" />
                  )}
                </div>
                
                {/* Icon */}
                <span className="flex-shrink-0">{analysisStep.icon}</span>
                
                {/* Label */}
                <span className={`truncate ${isCompleted ? 'font-medium' : ''}`}>
                  {displayLabel}
                </span>
              </div>
            );
          })}
        </div>

        {/* Completion hint */}
        {step === 'complete' && (
          <p className="text-xs text-emerald-400/80 mt-3 pt-2 border-t border-white/5">
             Click anywhere to view detailed results 
          </p>
        )}
        
        {/* Error hint */}
        {step === 'error' && (
          <p className="text-xs text-rose-400/80 mt-3 pt-2 border-t border-white/5">
             Please try again with a different location.
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Dashboard/MetricsGrid.jsx">
/**
 * Metrics Grid Component
 * Displays key metrics in a compact grid layout
 */

// Icon paths for metrics
const METRIC_ICONS = {
  footfall: '/icons/marker.svg',
  competitors: '/icons/store.svg',
  landmarks: '/icons/building.svg',
  density: '/icons/marker.svg',
};

// Icon color filters
const ICON_FILTERS = {
  primary: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)',
  destructive: 'invert(42%) sepia(93%) saturate(1352%) hue-rotate(326deg) brightness(99%) contrast(97%)',
  accent: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)',
  warning: 'invert(74%) sepia(57%) saturate(579%) hue-rotate(10deg) brightness(103%) contrast(101%)',
};

export default function MetricsGrid({ analysis, isLoading }) {
  const metrics = [
    {
      id: 'footfall',
      label: 'Footfall Index',
      value: analysis?.footfall_index || 0,
      max: 100,
      icon: METRIC_ICONS.footfall,
      color: 'primary',
      description: 'Estimated foot traffic potential',
    },
    {
      id: 'competitors',
      label: 'Competitors',
      value: analysis?.competitors?.length || 0,
      suffix: ' nearby',
      icon: METRIC_ICONS.competitors,
      color: 'destructive',
      description: 'Same category businesses',
    },
    {
      id: 'landmarks',
      label: 'Landmarks',
      value: analysis?.landmarks?.length || 0,
      suffix: ' found',
      icon: METRIC_ICONS.landmarks,
      color: 'accent',
      description: 'Key locations nearby',
    },
    {
      id: 'density',
      label: 'Competition Density',
      value: analysis?.competitor_density?.toFixed(1) || '0.0',
      suffix: '/km',
      icon: METRIC_ICONS.density,
      color: 'warning',
      description: 'Competitors per square km',
    },
  ];

  const getColorClasses = (color) => {
    const colors = {
      primary: 'text-primary-glow bg-primary-glow/10 border-primary-glow/30',
      destructive: 'text-destructive-glow bg-destructive-glow/10 border-destructive-glow/30',
      accent: 'text-accent-glow bg-accent-glow/10 border-accent-glow/30',
      warning: 'text-warning-glow bg-warning-glow/10 border-warning-glow/30',
    };
    return colors[color] || colors.primary;
  };

  if (isLoading) {
    return (
      <div className="grid grid-cols-2 gap-3">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="glass-card p-4 animate-pulse">
            <div className="flex items-center gap-2 mb-2">
              <div className="w-8 h-8 bg-slate-700 rounded-lg" />
              <div className="h-4 bg-slate-700 rounded w-20" />
            </div>
            <div className="h-6 bg-slate-700 rounded w-16 mb-1" />
            <div className="h-3 bg-slate-700/50 rounded w-24" />
          </div>
        ))}
      </div>
    );
  }

  return (
    <div className="grid grid-cols-2 gap-3">
      {metrics.map((metric) => (
        <div
          key={metric.id}
          className="glass-card p-4 hover:bg-surface-elevated transition-colors group"
        >
          {/* Header */}
          <div className="flex items-center gap-2 mb-2">
            <div className={`w-8 h-8 rounded-lg flex items-center justify-center border ${getColorClasses(metric.color)}`}>
              <img 
                src={metric.icon} 
                alt="" 
                className="w-5 h-5"
                style={{ filter: ICON_FILTERS[metric.color] }}
              />
            </div>
            <span className="text-xs text-slate-500 font-medium uppercase tracking-wide">
              {metric.label}
            </span>
          </div>
          
          {/* Value */}
          <div className="flex items-baseline gap-1">
            <span className={`text-2xl font-bold ${getColorClasses(metric.color).split(' ')[0]}`}>
              {metric.value}
            </span>
            {metric.suffix && (
              <span className="text-sm text-slate-500">{metric.suffix}</span>
            )}
            {metric.max && (
              <span className="text-sm text-slate-600">/{metric.max}</span>
            )}
          </div>
          
          {/* Description (on hover) */}
          <p className="text-xs text-slate-600 mt-1 group-hover:text-slate-500 transition-colors">
            {metric.description}
          </p>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/Dashboard/RecommendedSpotsCard.jsx">
/**
 * Recommended Spots Card Component
 * Displays optimal locations for setting up a business based on analysis
 */

import { useState } from 'react';

// Rating badge component
const RatingBadge = ({ rating, color }) => {
  const colorClasses = {
    green: 'bg-emerald-500/20 text-emerald-400 border-emerald-500/30',
    cyan: 'bg-cyan-500/20 text-cyan-400 border-cyan-500/30',
    yellow: 'bg-amber-500/20 text-amber-400 border-amber-500/30',
    orange: 'bg-orange-500/20 text-orange-400 border-orange-500/30',
  };
  
  return (
    <span className={`px-2 py-0.5 text-xs font-medium rounded-full border ${colorClasses[color] || colorClasses.cyan}`}>
      {rating}
    </span>
  );
};

// Individual spot card
const SpotItem = ({ spot, index, isExpanded, onToggle, onViewOnMap }) => {
  const rankColors = {
    1: 'from-emerald-500 to-emerald-600',
    2: 'from-cyan-500 to-cyan-600',
    3: 'from-blue-500 to-blue-600',
    4: 'from-purple-500 to-purple-600',
    5: 'from-slate-500 to-slate-600',
  };

  return (
    <div 
      className={`rounded-lg border transition-all duration-200 ${
        isExpanded 
          ? 'bg-surface-elevated border-primary-glow/30' 
          : 'bg-surface-secondary border-surface-border hover:border-slate-600'
      }`}
    >
      {/* Header - always visible */}
      <button
        onClick={onToggle}
        className="w-full flex items-center gap-3 p-3 text-left"
      >
        {/* Rank badge */}
        <div className={`w-8 h-8 rounded-lg bg-gradient-to-br ${rankColors[spot.rank] || rankColors[5]} flex items-center justify-center text-white font-bold text-sm shadow-lg`}>
          {spot.rank}
        </div>
        
        {/* Location info */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-slate-200 font-medium">Spot #{spot.rank}</span>
            <RatingBadge rating={spot.rating} color={spot.rating_color} />
          </div>
          <p className="text-xs text-slate-500 font-mono truncate">
            {spot.lat}, {spot.lng}
          </p>
        </div>
        
        {/* Score */}
        <div className="text-right">
          <div className="text-lg font-bold text-primary-glow">{Math.round(spot.score)}</div>
          <div className="text-[10px] text-slate-500 uppercase tracking-wide">Score</div>
        </div>
        
        {/* Expand indicator */}
        <svg 
          className={`w-4 h-4 text-slate-500 transition-transform ${isExpanded ? 'rotate-180' : ''}`} 
          fill="none" 
          viewBox="0 0 24 24" 
          stroke="currentColor"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      
      {/* Expanded content */}
      {isExpanded && (
        <div className="px-3 pb-3 space-y-3 border-t border-surface-border pt-3">
          {/* Stats row */}
          <div className="grid grid-cols-2 gap-2">
            <div className="bg-surface-secondary rounded-lg p-2 text-center">
              <div className="text-rose-400 font-semibold">{spot.nearby_competitors}</div>
              <div className="text-[10px] text-slate-500">Competitors Nearby</div>
            </div>
            <div className="bg-surface-secondary rounded-lg p-2 text-center">
              <div className="text-cyan-400 font-semibold">{spot.nearby_landmarks}</div>
              <div className="text-[10px] text-slate-500">Landmarks</div>
            </div>
          </div>
          
          {/* Distance to nearest competitor */}
          {spot.min_competitor_distance && (
            <div className="flex items-center gap-2 text-xs">
              <span className="text-slate-500">Nearest competitor:</span>
              <span className={`font-medium ${spot.min_competitor_distance > 300 ? 'text-emerald-400' : 'text-amber-400'}`}>
                {spot.min_competitor_distance}m away
              </span>
            </div>
          )}
          
          {/* Reasons */}
          <div className="space-y-1.5">
            <p className="text-xs text-slate-400 font-medium">Why this spot:</p>
            <ul className="space-y-1">
              {spot.reasons.map((reason, i) => (
                <li key={i} className="flex items-start gap-2 text-xs text-slate-300">
                  <svg className="w-3 h-3 text-emerald-400 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
          
          {/* Action button */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              onViewOnMap(spot);
            }}
            className="w-full py-2 bg-primary-glow/10 hover:bg-primary-glow/20 text-primary-glow text-xs font-medium rounded-lg transition-colors flex items-center justify-center gap-2"
          >
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            View on Map
          </button>
        </div>
      )}
    </div>
  );
};

export default function RecommendedSpotsCard({ spots = [], isLoading, onViewSpot }) {
  const [expandedIndex, setExpandedIndex] = useState(0); // First spot expanded by default

  if (isLoading) {
    return (
      <div className="glass-panel p-5">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Recommended Locations
        </h3>
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="bg-surface-secondary rounded-lg p-4 animate-pulse">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 rounded-lg bg-slate-700" />
                <div className="flex-1">
                  <div className="h-4 bg-slate-700 rounded w-24 mb-2" />
                  <div className="h-3 bg-slate-700/50 rounded w-32" />
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (!spots || spots.length === 0) {
    return (
      <div className="glass-panel p-5">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Recommended Locations
        </h3>
        <div className="text-center py-8">
          <img src="/icons/search.svg" alt="" className="w-12 h-12 mx-auto mb-3 opacity-50" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
          <p className="text-slate-400 text-sm">
            No optimal spots found in this area.
          </p>
          <p className="text-slate-500 text-xs mt-1">
            Try expanding the search radius or selecting a different area.
          </p>
        </div>
      </div>
    );
  }

  const topSpot = spots[0];

  return (
    <div className="glass-panel p-5">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Recommended Locations
        </h3>
        <span className="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-xs rounded-full font-medium">
          {spots.length} spots found
        </span>
      </div>
      
      {/* Best spot highlight */}
      {topSpot && (
        <div className="mb-4 p-3 rounded-lg bg-gradient-to-r from-emerald-500/10 to-cyan-500/10 border border-emerald-500/20">
          <div className="flex items-center gap-2 mb-1">
            <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(74%) sepia(52%) saturate(579%) hue-rotate(93deg) brightness(95%) contrast(88%)' }} />
            <span className="text-emerald-400 font-semibold text-sm">Best Location Found</span>
          </div>
          <p className="text-xs text-slate-300">
            {topSpot.reasons[0] || 'Optimal balance of low competition and good footfall'}
          </p>
        </div>
      )}
      
      {/* Spots list */}
      <div className="space-y-2 max-h-[400px] overflow-y-auto custom-scrollbar">
        {spots.map((spot, index) => (
          <SpotItem
            key={`spot-${spot.rank}`}
            spot={spot}
            index={index}
            isExpanded={expandedIndex === index}
            onToggle={() => setExpandedIndex(expandedIndex === index ? -1 : index)}
            onViewOnMap={onViewSpot}
          />
        ))}
      </div>
      
      {/* Legend */}
      <div className="mt-4 pt-3 border-t border-surface-border">
        <p className="text-[10px] text-slate-500 text-center">
          Spots are ranked by opportunity score: low competition + high footfall = better
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Dashboard/ScoreCard.jsx">
/**
 * Score Card Component
 * Displays the Opportunity Score with a radial progress ring
 */

export default function ScoreCard({ score, label, isLoading }) {
  // Score should be 0-100
  const normalizedScore = Math.min(100, Math.max(0, score || 0));
  
  // Calculate stroke-dasharray for progress ring
  const radius = 45;
  const circumference = 2 * Math.PI * radius;
  const strokeDashoffset = circumference - (normalizedScore / 100) * circumference;
  
  // Determine color based on score
  const getScoreColor = (score) => {
    if (score >= 70) return '#10b981'; // Green - Excellent
    if (score >= 50) return '#06b6d4'; // Cyan - Good
    if (score >= 30) return '#f59e0b'; // Amber - Fair
    return '#f43f5e'; // Rose - Poor
  };
  
  const getScoreLabel = (score) => {
    if (score >= 70) return 'Excellent';
    if (score >= 50) return 'Good';
    if (score >= 30) return 'Fair';
    return 'Poor';
  };
  
  const scoreColor = getScoreColor(normalizedScore);
  const scoreLabel = getScoreLabel(normalizedScore);

  return (
    <div className="glass-panel p-5">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
        Opportunity Score
      </h3>
      
      <div className="flex items-center gap-6">
        {/* Radial Progress Ring */}
        <div className="relative w-28 h-28">
          <svg className="w-full h-full transform -rotate-90">
            {/* Background circle */}
            <circle
              cx="56"
              cy="56"
              r={radius}
              stroke="currentColor"
              strokeWidth="8"
              fill="none"
              className="text-slate-700"
            />
            {/* Progress circle */}
            <circle
              cx="56"
              cy="56"
              r={radius}
              stroke={isLoading ? '#475569' : scoreColor}
              strokeWidth="8"
              fill="none"
              strokeLinecap="round"
              strokeDasharray={circumference}
              strokeDashoffset={isLoading ? circumference : strokeDashoffset}
              className="transition-all duration-1000 ease-out"
              style={{
                filter: isLoading ? 'none' : `drop-shadow(0 0 8px ${scoreColor}80)`,
              }}
            />
          </svg>
          
          {/* Center text */}
          <div className="absolute inset-0 flex flex-col items-center justify-center">
            {isLoading ? (
              <div className="w-8 h-8 border-2 border-slate-600 border-t-primary-glow rounded-full animate-spin" />
            ) : (
              <>
                <span 
                  className="text-3xl font-bold transition-colors duration-500"
                  style={{ color: scoreColor }}
                >
                  {normalizedScore}
                </span>
                <span className="text-xs text-slate-500">/100</span>
              </>
            )}
          </div>
        </div>
        
        {/* Score details */}
        <div className="flex-1 space-y-2">
          {isLoading ? (
            <div className="space-y-2">
              <div className="h-5 bg-slate-700 rounded animate-pulse w-24" />
              <div className="h-4 bg-slate-700/50 rounded animate-pulse w-32" />
            </div>
          ) : (
            <>
              <p 
                className="text-lg font-semibold transition-colors duration-500"
                style={{ color: scoreColor }}
              >
                {scoreLabel}
              </p>
              {label && (
                <p className="text-sm text-slate-400">{label}</p>
              )}
            </>
          )}
        </div>
      </div>
      
      {/* Score breakdown hint */}
      {!isLoading && score !== undefined && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <p className="text-xs text-slate-500">
            Based on footfall, competitor density & nearby landmarks
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Filters/BusinessTypeSelector.jsx">
/**
 * Business Type Selector Component - Icon Grid Design
 * Glass-morphic 2-column grid of Icon Cards
 */

import { useState, useRef, useEffect } from 'react';
import { BUSINESS_ICONS } from '../common/Icon';

// Business type options with SVG icons
const BUSINESS_TYPES = [
  { id: 'cafe', label: 'Cafe', icon: BUSINESS_ICONS.cafe },
  { id: 'restaurant', label: 'Restaurant', icon: BUSINESS_ICONS.restaurant },
  { id: 'retail', label: 'Retail', icon: BUSINESS_ICONS.retail },
  { id: 'gym', label: 'Gym', icon: BUSINESS_ICONS.gym },
  { id: 'pharmacy', label: 'Pharmacy', icon: BUSINESS_ICONS.pharmacy },
  { id: 'salon', label: 'Salon', icon: BUSINESS_ICONS.salon },
  { id: 'electronics', label: 'Electronics', icon: BUSINESS_ICONS.electronics },
  { id: 'clothing', label: 'Clothing', icon: BUSINESS_ICONS.clothing },
  { id: 'bookstore', label: 'Bookstore', icon: BUSINESS_ICONS.bookstore },
  { id: 'other', label: 'Other', icon: BUSINESS_ICONS.other },
];

export default function BusinessTypeSelector({ value, onChange, disabled }) {
  const [customType, setCustomType] = useState('');
  const [showCustomInput, setShowCustomInput] = useState(false);

  const handleSelect = (type) => {
    if (disabled) return;
    
    if (type.id === 'other') {
      setShowCustomInput(true);
      onChange(type.id);
    } else {
      setShowCustomInput(false);
      onChange(type.id);
    }
  };

  const handleCustomSubmit = (e) => {
    e.preventDefault();
    if (customType.trim()) {
      onChange(customType.trim().toLowerCase());
      setShowCustomInput(false);
    }
  };

  const selectedType = BUSINESS_TYPES.find((t) => t.id === value);

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium text-slate-300">
          What are you opening?
        </label>
        {value && value !== 'other' && (
          <span className="text-xs text-emerald-400 bg-emerald-500/10 px-2 py-1 rounded-full border border-emerald-500/20">
            {selectedType?.label || value}
          </span>
        )}
      </div>

      {/* 2-Column Icon Grid */}
      <div className={`grid grid-cols-2 gap-2 ${disabled ? 'opacity-50 pointer-events-none' : ''}`}>
        {BUSINESS_TYPES.map((type) => {
          const isActive = value === type.id;
          return (
            <button
              key={type.id}
              type="button"
              onClick={() => handleSelect(type)}
              className={`
                relative flex flex-col items-center justify-center gap-2 p-3 rounded-xl
                transition-all duration-200 border
                ${isActive 
                  ? 'bg-emerald-500/20 border-emerald-500/50 ring-2 ring-emerald-500 shadow-lg shadow-emerald-500/10' 
                  : 'bg-slate-800/30 border-white/5 hover:bg-white/5 hover:border-white/10'
                }
              `}
            >
              <img 
                src={type.icon} 
                alt="" 
                className="w-7 h-7 transition-all duration-200"
                style={{ 
                  filter: isActive 
                    ? 'invert(80%) sepia(60%) saturate(1000%) hue-rotate(100deg) brightness(100%) contrast(90%)' 
                    : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)'
                }}
              />
              <span className={`text-xs font-medium transition-colors ${isActive ? 'text-emerald-400' : 'text-slate-400'}`}>
                {type.label}
              </span>
              
              {/* Active indicator dot */}
              {isActive && (
                <div className="absolute top-2 right-2 w-2 h-2 rounded-full bg-emerald-400 animate-pulse" />
              )}
            </button>
          );
        })}
      </div>

      {/* Custom Input (shown when 'Other' is selected) */}
      {showCustomInput && value === 'other' && (
        <form onSubmit={handleCustomSubmit} className="mt-3">
          <div className="flex gap-2">
            <input
              type="text"
              value={customType}
              onChange={(e) => setCustomType(e.target.value)}
              placeholder="Enter custom type..."
              className="flex-1 bg-black/50 border border-white/10 rounded-lg px-4 py-2.5 text-sm text-white placeholder-slate-500 focus:outline-none focus:border-emerald-500/50 focus:ring-1 focus:ring-emerald-500/30 transition-all"
              autoFocus
            />
            <button
              type="submit"
              className="px-4 py-2 bg-emerald-500 text-white text-sm font-medium rounded-lg hover:bg-emerald-400 transition-colors"
            >
              Set
            </button>
          </div>
        </form>
      )}

      {/* Validation hint */}
      {!value && (
        <p className="text-xs text-amber-400/80 flex items-center gap-1.5 mt-2">
          <svg className="w-3.5 h-3.5" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
          </svg>
          Required to identify competitors
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/components/Filters/index.js">
export { default as BusinessTypeSelector } from './BusinessTypeSelector';
export { default as ProximityFilters } from './ProximityFilters';
</file>

<file path="src/components/Filters/ProximityFilters.jsx">
/**
 * Proximity Filters Component
 * Step 2 in the user flow - Select what you want nearby
 */

import { useState } from 'react';
import { PROXIMITY_ICONS } from '../common/Icon';

// Proximity filter options with SVG icons
const PROXIMITY_FILTERS = [
  { id: 'near_metro', label: 'Metro', icon: PROXIMITY_ICONS.near_metro, popular: true },
  { id: 'near_bus', label: 'Bus Stop', icon: PROXIMITY_ICONS.near_bus, popular: false },
  { id: 'near_school', label: 'School', icon: PROXIMITY_ICONS.near_school, popular: false },
  { id: 'near_college', label: 'College', icon: PROXIMITY_ICONS.near_college, popular: true },
  { id: 'near_hospital', label: 'Hospital', icon: PROXIMITY_ICONS.near_hospital, popular: false },
  { id: 'near_mall', label: 'Mall', icon: PROXIMITY_ICONS.near_mall, popular: true },
  { id: 'near_office', label: 'Office/IT', icon: PROXIMITY_ICONS.near_office, popular: true },
  { id: 'near_residential', label: 'Residential', icon: PROXIMITY_ICONS.near_residential, popular: false },
  { id: 'near_temple', label: 'Temple', icon: PROXIMITY_ICONS.near_temple, popular: false },
  { id: 'near_park', label: 'Park', icon: PROXIMITY_ICONS.near_park, popular: false },
  { id: 'near_atm', label: 'ATM/Bank', icon: PROXIMITY_ICONS.near_atm, popular: false },
  { id: 'near_bar', label: 'Bar/Pub', icon: PROXIMITY_ICONS.near_bar, popular: false },
];

export default function ProximityFilters({ value = [], onChange, disabled }) {
  const [showAll, setShowAll] = useState(false);

  const toggleFilter = (filterId) => {
    if (disabled) return;
    
    const newFilters = value.includes(filterId)
      ? value.filter((f) => f !== filterId)
      : [...value, filterId];
    
    onChange(newFilters);
  };

  const selectPopular = () => {
    const popularFilters = PROXIMITY_FILTERS.filter((f) => f.popular).map((f) => f.id);
    onChange(popularFilters);
  };

  const clearAll = () => {
    onChange([]);
  };

  // Show only first 6 filters by default, or all if expanded
  const visibleFilters = showAll ? PROXIMITY_FILTERS : PROXIMITY_FILTERS.slice(0, 6);

  return (
    <div className="space-y-3 relative z-20">
      <div className="flex items-center justify-between">
        <label className="block text-sm font-medium text-slate-400">
          Step 2: What do you want nearby?
        </label>
        <span className="text-xs text-slate-500">
          {value.length} selected
        </span>
      </div>

      {/* Filter Chips Grid */}
      <div className={`grid grid-cols-3 gap-2 ${disabled ? 'opacity-50 pointer-events-none' : ''}`}>
        {visibleFilters.map((filter) => {
          const isActive = value.includes(filter.id);
          return (
            <button
              key={filter.id}
              type="button"
              onClick={() => toggleFilter(filter.id)}
              className={`
                chip flex flex-col items-center justify-center gap-1 py-2
                ${isActive ? 'chip-active' : 'chip-inactive'}
              `}
            >
              <img 
                src={filter.icon} 
                alt="" 
                className="w-5 h-5"
                style={{ filter: isActive 
                  ? 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' 
                  : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)'
                }}
              />
              <span className="text-xs truncate w-full text-center">{filter.label}</span>
            </button>
          );
        })}
      </div>

      {/* Show More / Less Toggle */}
      {PROXIMITY_FILTERS.length > 6 && (
        <button
          type="button"
          onClick={() => setShowAll(!showAll)}
          className="text-xs text-slate-500 hover:text-slate-300 transition-colors"
        >
          {showAll ? ' Show less' : `Show ${PROXIMITY_FILTERS.length - 6} more `}
        </button>
      )}

      {/* Quick Actions */}
      <div className="flex gap-2">
        <button
          type="button"
          onClick={selectPopular}
          disabled={disabled}
          className="flex-1 text-xs py-1.5 px-2 rounded border border-surface-border text-slate-400 hover:text-primary-bright hover:border-primary-glow transition-colors disabled:opacity-50 flex items-center justify-center gap-1"
        >
          <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
          </svg>
          Select Popular
        </button>
        <button
          type="button"
          onClick={clearAll}
          disabled={disabled || value.length === 0}
          className="flex-1 text-xs py-1.5 px-2 rounded border border-surface-border text-slate-400 hover:text-destructive-bright hover:border-destructive-glow transition-colors disabled:opacity-50 flex items-center justify-center gap-1"
        >
          <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
          Clear All
        </button>
      </div>

      {/* Optional hint */}
      <p className="text-xs text-slate-500">
        Optional  Filters affect score calculation
      </p>
    </div>
  );
}
</file>

<file path="src/components/Layout/Header.jsx">
/**
 * Header Component - Floating Island Design
 * Glass-morphic Command Center aesthetic
 */

export default function Header({ isDarkMode, onToggleTheme }) {
  return (
    <header className="fixed top-4 left-1/2 -translate-x-1/2 w-[92%] max-w-6xl z-50">
      <div className={`backdrop-blur-xl ${isDarkMode ? 'bg-slate-900/80 border-white/10' : 'bg-white/80 border-slate-200'} border rounded-full px-4 py-2 flex items-center justify-between shadow-xl ${isDarkMode ? 'shadow-black/20' : 'shadow-slate-300/30'}`}>
        {/* Left: Logo & Brand */}
        <div className="flex items-center gap-2">
          {/* Logo Image */}
          <div className="w-8 h-8 flex items-center justify-center">
            <img 
              src="/hotspot-logo.png" 
              alt="Hotspot IQ" 
              className="w-8 h-8 object-contain"
              onError={(e) => {
                e.target.style.display = 'none';
                e.target.nextSibling.style.display = 'flex';
              }}
            />
            {/* Fallback gradient icon */}
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-emerald-400 to-cyan-500 items-center justify-center hidden">
              <svg className="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
            </div>
          </div>
          
          {/* Brand Text */}
          <div className="leading-tight">
            <h1 className="text-base font-bold tracking-tight">
              <span className="bg-gradient-to-r from-emerald-400 via-cyan-400 to-emerald-400 bg-clip-text text-transparent">
                Hotspot
              </span>
              <span className={isDarkMode ? 'text-white' : 'text-slate-800'}>IQ</span>
            </h1>
            <p className={`text-[9px] ${isDarkMode ? 'text-slate-500' : 'text-slate-400'} tracking-wider uppercase -mt-0.5`}>
              Location Intelligence
            </p>
          </div>
        </div>

        {/* Right: Navigation & Links */}
        <div className="flex items-center gap-3">
          {/* Nav Links */}
          <nav className="hidden md:flex items-center">
            <a href="#" className={`px-3 py-1.5 text-xs ${isDarkMode ? 'text-slate-400 hover:text-white hover:bg-white/5' : 'text-slate-500 hover:text-slate-800 hover:bg-slate-100'} rounded-full transition-all duration-200`}>
              Dashboard
            </a>
            <a href="#" className={`px-3 py-1.5 text-xs ${isDarkMode ? 'text-slate-400 hover:text-white hover:bg-white/5' : 'text-slate-500 hover:text-slate-800 hover:bg-slate-100'} rounded-full transition-all duration-200`}>
              Analytics
            </a>
            <a href="#" className={`px-3 py-1.5 text-xs ${isDarkMode ? 'text-slate-400 hover:text-white hover:bg-white/5' : 'text-slate-500 hover:text-slate-800 hover:bg-slate-100'} rounded-full transition-all duration-200`}>
              API Docs
            </a>
          </nav>

          {/* Divider */}
          <div className={`hidden md:block w-px h-5 ${isDarkMode ? 'bg-white/10' : 'bg-slate-200'}`} />

          {/* Powered By */}
          <div className="hidden sm:flex items-center gap-1.5 text-[11px]">
            <span className={isDarkMode ? 'text-slate-500' : 'text-slate-400'}>Powered by</span>
            <span className="text-emerald-500 font-semibold">LatLong.ai</span>
          </div>

          {/* Theme Toggle Button */}
          <button
            onClick={onToggleTheme}
            className={`w-8 h-8 flex items-center justify-center rounded-full ${isDarkMode ? 'bg-white/5 hover:bg-white/10 border-white/10 hover:border-white/20' : 'bg-slate-100 hover:bg-slate-200 border-slate-200 hover:border-slate-300'} border transition-all duration-200 group`}
            title={isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
          >
            {isDarkMode ? (
              // Sun icon for light mode
              <svg className="w-4 h-4 text-amber-400 group-hover:text-amber-300 transition-colors" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z" />
              </svg>
            ) : (
              // Moon icon for dark mode
              <svg className="w-4 h-4 text-slate-500 group-hover:text-slate-700 transition-colors" fill="currentColor" viewBox="0 0 24 24">
                <path fillRule="evenodd" d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z" clipRule="evenodd" />
              </svg>
            )}
          </button>

          {/* GitHub Link */}
          <a 
            href="https://github.com/Shubhojit-17/Hotspot-IQ" 
            target="_blank" 
            rel="noopener noreferrer"
            className={`w-7 h-7 flex items-center justify-center rounded-full ${isDarkMode ? 'bg-white/5 hover:bg-white/10 border-white/10 hover:border-white/20' : 'bg-slate-100 hover:bg-slate-200 border-slate-200 hover:border-slate-300'} border transition-all duration-200 group`}
          >
            <svg className={`w-4 h-4 ${isDarkMode ? 'text-slate-400 group-hover:text-white' : 'text-slate-500 group-hover:text-slate-800'} transition-colors`} fill="currentColor" viewBox="0 0 24 24">
              <path fillRule="evenodd" clipRule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33.85 0 1.71.11 2.5.33 1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z" />
            </svg>
          </a>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="src/components/Layout/index.js">
export { default as Header } from './Header';
</file>

<file path="src/components/Map/HeatmapOverlay.jsx">
/**
 * Heatmap Overlay Component
 * Shows competition density as a heatmap overlay on the map
 * Red = High competition (avoid), Green = Low competition (opportunity)
 */

import { useEffect, useRef } from 'react';
import { useMap } from 'react-leaflet';
import L from 'leaflet';

/**
 * Generate heatmap data points based on competitors and landmarks
 * Creates a grid of points with intensity values
 */
function generateHeatmapGrid(center, competitors, landmarks, radius = 2500) {
  const gridSize = 20; // Number of grid cells in each direction
  const cellSize = (radius * 2) / gridSize;
  const points = [];
  
  // Convert radius from meters to degrees (approximate)
  const latDelta = radius / 111000; // 1 degree lat  111km
  const lngDelta = radius / (111000 * Math.cos(center.lat * Math.PI / 180));
  
  // Create grid
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      const lat = center.lat - latDelta + (i / gridSize) * 2 * latDelta;
      const lng = center.lng - lngDelta + (j / gridSize) * 2 * lngDelta;
      
      // Calculate competition intensity at this point
      let competitorScore = 0;
      let landmarkScore = 0;
      
      // Higher score = more competitors nearby = RED
      competitors.forEach(comp => {
        if (comp.lat && comp.lng) {
          const dist = getDistance(lat, lng, comp.lat, comp.lng);
          if (dist < cellSize * 2) {
            competitorScore += Math.max(0, 1 - dist / (cellSize * 2));
          }
        }
      });
      
      // Landmarks add opportunity (reduce competition effect slightly)
      landmarks.forEach(lm => {
        if (lm.lat && lm.lng) {
          const dist = getDistance(lat, lng, lm.lat, lm.lng);
          if (dist < cellSize * 2) {
            landmarkScore += Math.max(0, 0.3 * (1 - dist / (cellSize * 2)));
          }
        }
      });
      
      // Net intensity: positive = competition (red), negative = opportunity (green)
      // Normalize to 0-1 range
      const intensity = Math.min(1, Math.max(0, competitorScore - landmarkScore * 0.5));
      
      points.push({
        lat,
        lng,
        intensity,
        hasCompetitors: competitorScore > 0,
      });
    }
  }
  
  return points;
}

/**
 * Calculate distance between two points in meters
 */
function getDistance(lat1, lng1, lat2, lng2) {
  const R = 6371000; // Earth's radius in meters
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Get color based on intensity
 * Low intensity (0) = Green (opportunity)
 * High intensity (1) = Red (competition)
 */
function getHeatColor(intensity) {
  // Color gradient: Green -> Yellow -> Orange -> Red
  if (intensity < 0.25) {
    // Green to light green
    const t = intensity / 0.25;
    return {
      r: Math.round(34 + t * 100),
      g: Math.round(197 - t * 50),
      b: Math.round(94 - t * 50),
      a: 0.3 + t * 0.1
    };
  } else if (intensity < 0.5) {
    // Light green to yellow
    const t = (intensity - 0.25) / 0.25;
    return {
      r: Math.round(134 + t * 121),
      g: Math.round(147 + t * 53),
      b: Math.round(44 - t * 44),
      a: 0.4 + t * 0.1
    };
  } else if (intensity < 0.75) {
    // Yellow to orange
    const t = (intensity - 0.5) / 0.25;
    return {
      r: 255,
      g: Math.round(200 - t * 100),
      b: 0,
      a: 0.5 + t * 0.1
    };
  } else {
    // Orange to red
    const t = (intensity - 0.75) / 0.25;
    return {
      r: 255,
      g: Math.round(100 - t * 60),
      b: Math.round(t * 50),
      a: 0.6 + t * 0.15
    };
  }
}

export default function HeatmapOverlay({ 
  center, 
  competitors = [], 
  landmarks = [],
  radius = 2500,
  enabled = true 
}) {
  const map = useMap();
  const canvasRef = useRef(null);
  const overlayRef = useRef(null);

  useEffect(() => {
    if (!enabled || !center || !map) return;

    // Remove existing overlay
    if (overlayRef.current) {
      map.removeLayer(overlayRef.current);
    }

    // Generate heatmap points
    const points = generateHeatmapGrid(center, competitors, landmarks, radius);
    
    // If no competitors, don't show heatmap
    if (competitors.length === 0) return;

    // Calculate bounds
    const latDelta = radius / 111000;
    const lngDelta = radius / (111000 * Math.cos(center.lat * Math.PI / 180));
    const bounds = L.latLngBounds(
      [center.lat - latDelta, center.lng - lngDelta],
      [center.lat + latDelta, center.lng + lngDelta]
    );

    // Create canvas with higher resolution for smoother circle
    const canvas = document.createElement('canvas');
    const canvasSize = 400;
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const ctx = canvas.getContext('2d');

    // Define circular clipping region first
    const centerX = canvasSize / 2;
    const centerY = canvasSize / 2;
    const circleRadius = canvasSize / 2 - 2; // Slightly smaller for clean edge

    // Create circular clip path
    ctx.save();
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
    ctx.clip();

    // Draw heatmap cells within the circle
    const gridSize = 20;
    const cellWidth = canvasSize / gridSize;
    const cellHeight = canvasSize / gridSize;

    points.forEach((point, index) => {
      const i = Math.floor(index / gridSize);
      const j = index % gridSize;
      
      const x = j * cellWidth + cellWidth / 2;
      const y = (gridSize - 1 - i) * cellHeight + cellHeight / 2;
      
      // Check if point is within circle
      const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
      if (distFromCenter > circleRadius) return;
      
      const color = getHeatColor(point.intensity);
      const cellRadius = cellWidth * 1.0;
      
      // Create radial gradient for smooth effect
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, cellRadius);
      gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`);
      gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, cellRadius, 0, Math.PI * 2);
      ctx.fill();
    });

    // Restore context (removes clip)
    ctx.restore();

    // Draw circle border
    ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
    ctx.stroke();

    // Create image overlay
    const imageUrl = canvas.toDataURL();
    overlayRef.current = L.imageOverlay(imageUrl, bounds, {
      opacity: 0.7,
      interactive: false,
    });
    
    overlayRef.current.addTo(map);

    // Cleanup
    return () => {
      if (overlayRef.current) {
        map.removeLayer(overlayRef.current);
      }
    };
  }, [map, center, competitors, landmarks, radius, enabled]);

  return null;
}
</file>

<file path="src/components/Map/index.js">
export { default as MapView } from './MapView';
export { default as HeatmapOverlay } from './HeatmapOverlay';
</file>

<file path="src/components/Map/MapView.jsx">
/**
 * Map Container Component
 * The main map canvas using React-Leaflet
 */

import { useEffect, useRef, useState, useMemo } from 'react';
import { MapContainer, TileLayer, Marker, Popup, useMap, Circle } from 'react-leaflet';
import L from 'leaflet';
import HeatmapOverlay from './HeatmapOverlay';

// Fix for default marker icons in React-Leaflet
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
});

// =====================================================
// CONTEXTUAL VISIBILITY - Relevance Matrix
// =====================================================
// Maps business types to landmark categories with relevance scores (0.1 to 1.0)
// Higher score = more relevant for business success
const RELEVANCE_MATRIX = {
  cafe: {
    office: 0.95, school: 0.7, college: 0.9, university: 0.9, hospital: 0.5,
    mall: 0.8, metro_station: 0.9, bus_stop: 0.75, railway_station: 0.85,
    residential: 0.7, park: 0.8, temple: 0.4, bar: 0.85, restaurant: 0.6,
    hotel: 0.7, atm: 0.5, gym: 0.65, pharmacy: 0.3, default: 0.5
  },
  restaurant: {
    office: 0.95, school: 0.5, college: 0.85, university: 0.85, hospital: 0.6,
    mall: 0.85, metro_station: 0.8, bus_stop: 0.65, railway_station: 0.75,
    residential: 0.85, park: 0.6, temple: 0.65, bar: 0.9, restaurant: 0.4,
    hotel: 0.9, atm: 0.5, gym: 0.55, pharmacy: 0.3, default: 0.5
  },
  retail: {
    office: 0.7, school: 0.6, college: 0.75, university: 0.75, hospital: 0.5,
    mall: 0.95, metro_station: 0.9, bus_stop: 0.8, railway_station: 0.85,
    residential: 0.95, park: 0.5, temple: 0.6, bar: 0.4, restaurant: 0.6,
    hotel: 0.7, atm: 0.8, gym: 0.5, pharmacy: 0.6, default: 0.6
  },
  gym: {
    office: 0.9, school: 0.3, college: 0.85, university: 0.85, hospital: 0.4,
    mall: 0.7, metro_station: 0.75, bus_stop: 0.6, railway_station: 0.65,
    residential: 0.95, park: 0.85, temple: 0.2, bar: 0.3, restaurant: 0.5,
    hotel: 0.7, atm: 0.5, gym: 0.2, pharmacy: 0.6, default: 0.5
  },
  pharmacy: {
    office: 0.6, school: 0.7, college: 0.65, university: 0.65, hospital: 0.95,
    mall: 0.7, metro_station: 0.75, bus_stop: 0.7, railway_station: 0.7,
    residential: 0.95, park: 0.4, temple: 0.5, bar: 0.2, restaurant: 0.4,
    hotel: 0.6, atm: 0.6, gym: 0.5, pharmacy: 0.3, default: 0.5
  },
  salon: {
    office: 0.75, school: 0.3, college: 0.7, university: 0.7, hospital: 0.4,
    mall: 0.9, metro_station: 0.7, bus_stop: 0.6, railway_station: 0.65,
    residential: 0.95, park: 0.4, temple: 0.5, bar: 0.6, restaurant: 0.6,
    hotel: 0.8, atm: 0.5, gym: 0.7, pharmacy: 0.4, default: 0.5
  },
  electronics: {
    office: 0.85, school: 0.5, college: 0.9, university: 0.9, hospital: 0.4,
    mall: 0.95, metro_station: 0.85, bus_stop: 0.7, railway_station: 0.8,
    residential: 0.8, park: 0.3, temple: 0.3, bar: 0.3, restaurant: 0.5,
    hotel: 0.6, atm: 0.7, gym: 0.4, pharmacy: 0.3, default: 0.5
  },
  clothing: {
    office: 0.6, school: 0.5, college: 0.85, university: 0.85, hospital: 0.3,
    mall: 0.95, metro_station: 0.85, bus_stop: 0.7, railway_station: 0.8,
    residential: 0.85, park: 0.4, temple: 0.5, bar: 0.5, restaurant: 0.6,
    hotel: 0.7, atm: 0.7, gym: 0.5, pharmacy: 0.3, default: 0.5
  },
  bookstore: {
    office: 0.7, school: 0.95, college: 0.95, university: 0.95, hospital: 0.4,
    mall: 0.75, metro_station: 0.7, bus_stop: 0.6, railway_station: 0.7,
    residential: 0.7, park: 0.6, temple: 0.4, bar: 0.2, restaurant: 0.5,
    hotel: 0.5, atm: 0.5, gym: 0.3, pharmacy: 0.3, default: 0.5
  },
  other: {
    office: 0.6, school: 0.5, college: 0.5, university: 0.5, hospital: 0.5,
    mall: 0.7, metro_station: 0.7, bus_stop: 0.6, railway_station: 0.65,
    residential: 0.7, park: 0.5, temple: 0.5, bar: 0.5, restaurant: 0.5,
    hotel: 0.5, atm: 0.5, gym: 0.5, pharmacy: 0.5, default: 0.5
  }
};

// Get relevance score for a business type and landmark category
const getRelevanceScore = (businessType, landmarkCategory) => {
  const bt = businessType?.toLowerCase() || 'other';
  const lc = landmarkCategory?.toLowerCase().replace(/\s+/g, '_') || 'default';

  const businessScores = RELEVANCE_MATRIX[bt] || RELEVANCE_MATRIX['other'];
  return businessScores[lc] ?? businessScores['default'] ?? 0.5;
};

// Calculate marker style based on relevance
const getMarkerStyle = (businessType, landmarkCategory) => {
  const score = getRelevanceScore(businessType, landmarkCategory);

  // Opacity: 0.35 (low relevance) to 1.0 (high relevance)
  const opacity = 0.35 + (score * 0.65);

  // Scale: 0.7 (low relevance) to 1.15 (high relevance)
  const scale = 0.7 + (score * 0.45);

  // Size: 24px (low relevance) to 36px (high relevance)
  const size = Math.round(24 + (score * 12));

  // Z-index: 100 (low relevance) to 900 (high relevance)
  const zIndex = Math.round(100 + (score * 800));

  return { opacity, scale, size, zIndex, score };
};

// Landmark category to icon mapping
const LANDMARK_ICON_MAP = {
  metro_station: '/icons/metro.svg',
  metro: '/icons/metro.svg',
  bus_stop: '/icons/bus.svg',
  bus: '/icons/bus.svg',
  railway_station: '/icons/metro.svg',
  railway: '/icons/metro.svg',
  school: '/icons/school.svg',
  college: '/icons/college.svg',
  university: '/icons/college.svg',
  hospital: '/icons/hospital.svg',
  clinic: '/icons/hospital.svg',
  mall: '/icons/mall.svg',
  office: '/icons/office.svg',
  residential: '/icons/house.svg',
  temple: '/icons/temple.svg',
  church: '/icons/temple.svg',
  mosque: '/icons/temple.svg',
  park: '/icons/park.svg',
  atm: '/icons/bank.svg',
  bank: '/icons/bank.svg',
  bar: '/icons/bar.svg',
  pub: '/icons/bar.svg',
  restaurant: '/icons/restaurant.svg',
  cafe: '/icons/cafe.svg',
  hotel: '/icons/building.svg',
  pharmacy: '/icons/pharmacy.svg',
  gym: '/icons/gym.svg',
  supermarket: '/icons/mall.svg',
  default: '/icons/marker.svg',
};

// Custom marker icons with SVG - supports dynamic size/opacity for contextual visibility
// Size scaling is handled via CSS classes based on zoom level
const createCustomIcon = (color, iconPath, baseSize = 32, opacity = 1, zIndex = 500) => {
  const iconSize = baseSize;
  const innerIconSize = Math.round(baseSize * 0.5);

  return L.divIcon({
    className: 'custom-marker',
    html: `
      <div style="
        width: ${iconSize}px;
        height: ${iconSize}px;
        background: ${color};
        border: 2px solid white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        opacity: ${opacity};
        z-index: ${zIndex};
        position: relative;
      ">
        <div style="
          width: ${innerIconSize}px;
          height: ${innerIconSize}px;
          background-color: white;
          -webkit-mask: url('${iconPath}') center/contain no-repeat;
          mask: url('${iconPath}') center/contain no-repeat;
        "></div>
      </div>
    `,
    iconSize: [iconSize, iconSize],
    iconAnchor: [iconSize / 2, iconSize / 2],
    popupAnchor: [0, -iconSize / 2],
  });
};

// Cache for landmark icons - keyed by category + business type
const landmarkIconCache = {};

// Get landmark icon based on category with contextual visibility styling
const getLandmarkIcon = (category, businessType = null) => {
  const normalizedCategory = category?.toLowerCase().replace(/\s+/g, '_') || 'default';
  const bt = businessType?.toLowerCase() || 'other';
  const cacheKey = `${normalizedCategory}-${bt}`;

  // Return cached icon if available
  if (landmarkIconCache[cacheKey]) {
    return landmarkIconCache[cacheKey];
  }

  const iconPath = LANDMARK_ICON_MAP[normalizedCategory] || LANDMARK_ICON_MAP.default;

  // Get contextual visibility styling
  const style = getMarkerStyle(bt, normalizedCategory);

  // Create icon with contextual styling (CSS handles zoom scaling)
  const icon = createCustomIcon('#06b6d4', iconPath, style.size, style.opacity, style.zIndex);
  landmarkIconCache[cacheKey] = icon;
  return icon;
};

// Numbered recommended spot icon - HIGHLY DISTINCTIVE design
// These are the "best places to start business" markers - must stand out!
const createSpotIcon = (rank, color) => {
  // Much larger than other markers
  const size = 52;
  const fontSize = 18;
  
  // Bright, high-contrast colors for each rank
  const spotColors = {
    1: { bg: '#FFD700', text: '#000', glow: 'rgba(255, 215, 0, 0.8)', border: '#FFA500' },  // Gold
    2: { bg: '#C0C0C0', text: '#000', glow: 'rgba(192, 192, 192, 0.8)', border: '#A0A0A0' }, // Silver
    3: { bg: '#CD7F32', text: '#fff', glow: 'rgba(205, 127, 50, 0.8)', border: '#8B4513' },  // Bronze
    4: { bg: '#9333EA', text: '#fff', glow: 'rgba(147, 51, 234, 0.8)', border: '#7C3AED' },  // Purple
    5: { bg: '#EC4899', text: '#fff', glow: 'rgba(236, 72, 153, 0.8)', border: '#DB2777' },  // Pink
  };
  
  const colors = spotColors[rank] || spotColors[5];
  
  return L.divIcon({
    className: 'recommended-spot-marker',
    html: `
      <div class="spot-container" style="
        position: relative;
        width: ${size}px;
        height: ${size + 15}px;
      ">
        <!-- Pin pointer at bottom -->
        <div style="
          position: absolute;
          bottom: 0;
          left: 50%;
          transform: translateX(-50%);
          width: 0;
          height: 0;
          border-left: 10px solid transparent;
          border-right: 10px solid transparent;
          border-top: 15px solid ${colors.border};
          filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        "></div>
        
        <!-- Main circle with star icon -->
        <div style="
          position: absolute;
          top: 0;
          left: 0;
          width: ${size}px;
          height: ${size}px;
          background: linear-gradient(145deg, ${colors.bg}, ${colors.border});
          border: 4px solid white;
          border-radius: 50%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          box-shadow: 
            0 4px 15px ${colors.glow},
            0 0 30px ${colors.glow},
            inset 0 2px 4px rgba(255,255,255,0.4);
          animation: spot-pulse 1.5s ease-in-out infinite;
        ">
          <!-- Star icon -->
          <svg width="16" height="16" viewBox="0 0 24 24" fill="${colors.text}" style="margin-bottom: 1px;">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
          </svg>
          <!-- Rank number -->
          <span style="
            font-size: ${fontSize}px;
            font-weight: 900;
            color: ${colors.text};
            text-shadow: ${colors.text === '#000' ? 'none' : '0 1px 2px rgba(0,0,0,0.3)'};
            line-height: 1;
          ">${rank}</span>
        </div>
        
        <!-- Outer ring animation -->
        <div style="
          position: absolute;
          top: -6px;
          left: -6px;
          width: ${size + 12}px;
          height: ${size + 12}px;
          border: 2px solid ${colors.bg};
          border-radius: 50%;
          opacity: 0.6;
          animation: ring-pulse 1.5s ease-in-out infinite;
        "></div>
      </div>
      
      <style>
        @keyframes spot-pulse {
          0%, 100% { 
            transform: scale(1);
            box-shadow: 0 4px 15px ${colors.glow}, 0 0 30px ${colors.glow}, inset 0 2px 4px rgba(255,255,255,0.4);
          }
          50% { 
            transform: scale(1.05);
            box-shadow: 0 6px 25px ${colors.glow}, 0 0 50px ${colors.glow}, inset 0 2px 4px rgba(255,255,255,0.4);
          }
        }
        @keyframes ring-pulse {
          0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
          }
          50% { 
            transform: scale(1.15);
            opacity: 0.2;
          }
        }
      </style>
    `,
    iconSize: [size, size + 15],
    iconAnchor: [size / 2, size + 15],
    popupAnchor: [0, -size - 10],
  });
};

// Create competitor icon (CSS handles zoom scaling)
const createCompetitorIcon = () => {
  return createCustomIcon('#f43f5e', '/icons/store.svg', 32, 1, 500);
};

// landmarkIcon is now dynamically created per category using getLandmarkIcon()

// Component to handle map view changes - only flies to location ONCE when center changes
function MapController({ center, zoom, hasFlown, setHasFlown }) {
  const map = useMap();

  useEffect(() => {
    // Only fly to location once when a NEW location is selected
    if (center && !hasFlown) {
      map.flyTo(center, zoom || 15, {
        duration: 1.5,
      });
      setHasFlown(true);
    }
  }, [center, zoom, map, hasFlown, setHasFlown]);

  return null;
}

// Component to track zoom level and update markers via CSS class
function ZoomTracker({ onZoomChange }) {
  const map = useMap();

  useEffect(() => {
    const handleZoom = () => {
      const zoom = Math.round(map.getZoom());
      onZoomChange(zoom);
      
      // Update CSS class on map container for zoom-based styling
      const container = map.getContainer();
      // Remove old zoom classes
      container.className = container.className.replace(/map-zoom-\d+/g, '').trim();
      // Add new zoom class
      container.classList.add(`map-zoom-${zoom}`);
    };

    // Set initial zoom
    handleZoom();

    map.on('zoomend', handleZoom);
    return () => map.off('zoomend', handleZoom);
  }, [map, onZoomChange]);

  return null;
}

// Component to handle click events
function MapClickHandler({ onClick }) {
  const map = useMap();

  useEffect(() => {
    if (!onClick) return;

    const handleClick = (e) => {
      onClick({
        lat: e.latlng.lat,
        lng: e.latlng.lng,
      });
    };

    map.on('click', handleClick);
    return () => map.off('click', handleClick);
  }, [map, onClick]);

  return null;
}

export default function MapView({
  selectedLocation,
  competitors = [],
  landmarks = [],
  recommendedSpots = [],
  isochrone = null,
  onMapClick,
  onSpotClick,
  center = [12.9716, 77.5946], // Default: Bangalore
  zoom = 13,
  showHeatmap = true,
  showLandmarks = true,
  showCompetitors = true,
  setShowLandmarks,
  setShowCompetitors,
  businessType = null, // For contextual visibility
  radius = null, // Radius in meters
  analysis = null, // For stats panel
  onOpenPanel, // Callback to open analysis panel
  isLoading = false, // Loading state
  isDarkMode = true, // Dark/Light mode toggle
}) {
  const mapRef = useRef(null);
  const [heatmapEnabled, setHeatmapEnabled] = useState(true);
  const [showSpots, setShowSpots] = useState(true);
  const [contextualVisibility, setContextualVisibility] = useState(true); // Toggle for contextual visibility
  const [currentZoom, setCurrentZoom] = useState(zoom); // Track current zoom level for dynamic marker sizing
  const [hasFlown, setHasFlown] = useState(false); // Track if we've flown to location (prevent repeated flying)
  const [lastLocationKey, setLastLocationKey] = useState(null); // Track which location we flew to

  // Reset hasFlown when location changes to a NEW location
  useEffect(() => {
    const locationKey = selectedLocation ? `${selectedLocation.lat}-${selectedLocation.lng}` : null;
    if (locationKey !== lastLocationKey) {
      setHasFlown(false);
      setLastLocationKey(locationKey);
    }
  }, [selectedLocation, lastLocationKey]);

  // Clear landmark icon cache when business type changes (for contextual visibility)
  // Note: Zoom scaling is now handled via CSS, so no need to clear on zoom change
  useEffect(() => {
    // Clear cache to force re-creation of icons with new business type styling
    Object.keys(landmarkIconCache).forEach(key => delete landmarkIconCache[key]);
  }, [businessType, contextualVisibility]);

  // Safely convert to arrays
  const competitorList = Array.isArray(competitors) ? competitors : [];
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  const spotList = Array.isArray(recommendedSpots) ? recommendedSpots : [];

  // Spot colors by rank
  const getSpotColor = (rank) => {
    const colors = {
      1: '#10b981', // Emerald
      2: '#06b6d4', // Cyan
      3: '#3b82f6', // Blue
      4: '#8b5cf6', // Purple
      5: '#6b7280', // Gray
    };
    return colors[rank] || colors[5];
  };

  // Circle area style
  const circleStyle = {
    color: '#10b981',
    weight: 2,
    opacity: 0.8,
    fillColor: '#10b981',
    fillOpacity: 0.1,
  };

  // Calculate radius for the circular area (meters)
  // Use provided radius prop if available, otherwise fallback to defaults
  const areaRadius = radius || (selectedLocation?.is_major ? 2500 : 1500);

  return (
    <div className="absolute inset-0 z-0">
      <MapContainer
        ref={mapRef}
        center={center}
        zoom={zoom}
        className="w-full h-full"
        zoomControl={true}
        attributionControl={false}
      >
        {/* Tile layer - switches between dark and light mode */}
        <TileLayer
          key={isDarkMode ? 'dark' : 'light'}
          url={isDarkMode 
            ? "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png"
            : "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png"
          }
          attribution='&copy; <a href="https://carto.com/">CARTO</a>'
        />

        {/* Map controllers */}
        <MapController
          center={selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null
            ? [selectedLocation.lat, selectedLocation.lng]
            : null}
          zoom={15}
          hasFlown={hasFlown}
          setHasFlown={setHasFlown}
        />
        <MapClickHandler onClick={onMapClick} />
        <ZoomTracker onZoomChange={setCurrentZoom} />

        {/* Circular area selection - covers the entire selected area */}
        {selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null && (
          <Circle
            center={[selectedLocation.lat, selectedLocation.lng]}
            radius={areaRadius}
            pathOptions={circleStyle}
          />
        )}

        {/* Competition Heatmap Overlay */}
        {selectedLocation && selectedLocation.lat != null && heatmapEnabled && showHeatmap && (
          <HeatmapOverlay
            center={{ lat: selectedLocation.lat, lng: selectedLocation.lng }}
            competitors={competitorList}
            landmarks={landmarkList}
            radius={areaRadius}
            enabled={heatmapEnabled}
          />
        )}

        {/* Recommended Spot markers - rendered LAST to be on top */}
        {showSpots && spotList
          .filter(s => s.lat != null && s.lng != null)
          .map((spot) => (
            <Marker
              key={`spot-${spot.rank}`}
              position={[spot.lat, spot.lng]}
              icon={createSpotIcon(spot.rank, getSpotColor(spot.rank))}
              zIndexOffset={1000 + (6 - spot.rank) * 100}
              eventHandlers={{
                click: () => onSpotClick && onSpotClick(spot)
              }}
            >
              <Popup>
                <div className="text-slate-900 min-w-[200px]">
                  <div className="flex items-center gap-2 mb-2">
                    <div className="w-8 h-8 rounded-full flex items-center justify-center text-white font-bold" 
                         style={{ background: spot.rank === 1 ? '#FFD700' : spot.rank === 2 ? '#C0C0C0' : spot.rank === 3 ? '#CD7F32' : spot.rank === 4 ? '#9333EA' : '#EC4899' }}>
                      {spot.rank}
                    </div>
                    <div>
                      <span className="font-bold text-base">Best Location #{spot.rank}</span>
                      <p className="text-xs text-slate-500">Recommended for your business</p>
                    </div>
                  </div>
                  <p className="text-xs font-mono text-slate-500 mb-2">
                    {spot.lat.toFixed(6)}, {spot.lng.toFixed(6)}
                  </p>
                  <div className="flex items-center gap-2 mb-2">
                    <span className={`px-2 py-0.5 text-xs rounded-full font-medium ${spot.rating === 'Excellent' ? 'bg-emerald-100 text-emerald-700' :
                        spot.rating === 'Good' ? 'bg-cyan-100 text-cyan-700' :
                          spot.rating === 'Moderate' ? 'bg-amber-100 text-amber-700' :
                            'bg-orange-100 text-orange-700'
                      }`}>
                      {spot.rating}
                    </span>
                    <span className="text-xs text-slate-600">Score: {Math.round(spot.score)}</span>
                  </div>
                  <ul className="text-xs text-slate-600 space-y-0.5">
                    {spot.reasons?.slice(0, 2).map((reason, i) => (
                      <li key={i} className="flex items-start gap-1">
                        <svg className="w-3 h-3 text-emerald-500 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                          <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                        </svg>
                        <span>{reason}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              </Popup>
            </Marker>
          ))}

        {/* Competitor markers - only show those with coordinates */}
        {showCompetitors && competitorList
          .filter(c => c.lat != null && c.lng != null)
          .map((competitor, index) => (
            <Marker
              key={`competitor-${index}`}
              position={[competitor.lat, competitor.lng]}
              icon={createCompetitorIcon()}
            >
              <Popup>
                <div className="text-slate-900">
                  <p className="font-semibold">{competitor.name}</p>
                  <p className="text-xs text-slate-500">{competitor.category}</p>
                  {competitor.distance && (
                    <p className="text-xs text-rose-600 mt-1">
                      {competitor.distance}m away
                    </p>
                  )}
                </div>
              </Popup>
            </Marker>
          ))}

        {/* Landmark markers - only show those with coordinates */}
        {/* Uses contextual visibility to adjust opacity/size based on business relevance */}
        {showLandmarks && landmarkList
          .filter(l => l.lat != null && l.lng != null)
          .map((landmark, index) => {
            const relevance = getRelevanceScore(businessType, landmark.category);
            return (
              <Marker
              key={`landmark-${index}`}
              position={[landmark.lat, landmark.lng]}
              icon={getLandmarkIcon(landmark.category, contextualVisibility ? businessType : null)}
                zIndexOffset={contextualVisibility ? Math.round(relevance * 800) : 0}
              >
                <Popup>
                  <div className="text-slate-900">
                    <p className="font-semibold">{landmark.name}</p>
                    <p className="text-xs text-slate-500">{landmark.category}</p>
                    {contextualVisibility && businessType && (
                      <div className="mt-2 pt-2 border-t border-slate-200">
                        <div className="flex items-center gap-2">
                          <span className="text-xs text-slate-400">Relevance:</span>
                          <div className="flex-1 h-1.5 bg-slate-200 rounded-full overflow-hidden">
                            <div
                              className={`h-full rounded-full ${relevance >= 0.8 ? 'bg-emerald-500' :
                                  relevance >= 0.6 ? 'bg-cyan-500' :
                                    relevance >= 0.4 ? 'bg-amber-500' :
                                      'bg-slate-400'
                                }`}
                              style={{ width: `${relevance * 100}%` }}
                            />
                          </div>
                          <span className={`text-xs font-medium ${relevance >= 0.8 ? 'text-emerald-600' :
                              relevance >= 0.6 ? 'text-cyan-600' :
                                relevance >= 0.4 ? 'text-amber-600' :
                                  'text-slate-500'
                            }`}>
                            {Math.round(relevance * 100)}%
                          </span>
                        </div>
                        <p className="text-[10px] text-slate-400 mt-1">
                          {relevance >= 0.8 ? 'High impact for your business' :
                            relevance >= 0.6 ? 'Moderate impact' :
                              relevance >= 0.4 ? 'Some relevance' :
                                'Low relevance for this business type'}
                        </p>
                      </div>
                    )}
                  </div>
                </Popup>
              </Marker>
            );
          })}
      </MapContainer>

      {/* Unified Bottom-Right Controls - Single Column Stack */}
      {selectedLocation && !isLoading && (
        <div className="absolute bottom-6 right-6 z-[1000] flex flex-col gap-3 w-[300px]">
          
          {/* Row 1: Quick Stats Panel */}
          {analysis && onOpenPanel && (
            <button
              onClick={onOpenPanel}
              className="w-full backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 hover:bg-slate-800/90 transition-all cursor-pointer group shadow-xl"
            >
              <div className="flex items-center gap-4">
                <div className="text-center">
                  <p className="text-3xl font-bold text-emerald-400">
                    {analysis.recommended_spots?.length || 0}
                  </p>
                  <p className="text-xs text-slate-500">Spots</p>
                </div>
                <div className="w-px h-10 bg-white/10" />
                <div className="text-left text-sm">
                  <p className="text-slate-300">
                    <span className="text-rose-400 font-semibold">{analysis.competitors?.count || 0}</span> competitors
                  </p>
                  <p className="text-slate-300">
                    <span className="text-cyan-400 font-semibold">{analysis.landmarks?.total || 0}</span> landmarks
                  </p>
                </div>
                <div className="text-slate-500 group-hover:text-white group-hover:translate-x-0.5 transition-all ml-auto">
                  <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </div>
              </div>
            </button>
          )}

          {/* Row 2: Landmarks & Competitors Toggle */}
          {setShowLandmarks && setShowCompetitors && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-2 flex gap-2 shadow-xl">
              <button
                onClick={() => setShowLandmarks(!showLandmarks)}
                className={`flex-1 px-4 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${showLandmarks
                  ? 'bg-cyan-500 text-white shadow-md shadow-cyan-500/25'
                  : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                  }`}
              >
                <img src="/icons/building.svg" alt="" className="w-4 h-4"
                  style={{ filter: showLandmarks ? 'brightness(0) invert(1)' : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }}
                />
                <span>Landmarks</span>
              </button>
              <button
                onClick={() => setShowCompetitors(!showCompetitors)}
                className={`flex-1 px-4 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${showCompetitors
                  ? 'bg-rose-500 text-white shadow-md shadow-rose-500/25'
                  : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                  }`}
              >
                <img src="/icons/store.svg" alt="" className="w-4 h-4"
                  style={{ filter: showCompetitors ? 'brightness(0) invert(1)' : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }}
                />
                <span>Competitors</span>
              </button>
            </div>
          )}

          {/* Row 3: Heatmap, Spots, Smart View Toggle */}
          {competitorList.length > 0 && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-2 flex flex-wrap gap-2 shadow-xl">
              <button
                onClick={() => setHeatmapEnabled(!heatmapEnabled)}
                className={`flex-1 min-w-[80px] px-3 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${heatmapEnabled
                    ? 'bg-amber-500 text-white shadow-md shadow-amber-500/25'
                    : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                  }`}
              >
                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                </svg>
                <span>Heatmap</span>
              </button>
              {spotList.length > 0 && (
                <button
                  onClick={() => setShowSpots(!showSpots)}
                  className={`flex-1 min-w-[80px] px-3 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${showSpots
                      ? 'bg-emerald-500 text-white shadow-md shadow-emerald-500/25'
                      : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                    }`}
                >
                  <img src="/icons/star.svg" alt="" className="w-4 h-4" style={{ filter: showSpots ? 'brightness(0) invert(1)' : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
                  <span>{spotList.length} Spots</span>
                </button>
              )}
              {businessType && landmarkList.length > 0 && (
                <button
                  onClick={() => setContextualVisibility(!contextualVisibility)}
                  className={`flex-1 min-w-[80px] px-3 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${contextualVisibility
                      ? 'bg-violet-500 text-white shadow-md shadow-violet-500/25'
                      : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                    }`}
                  title="Adjusts landmark visibility based on relevance to your business type"
                >
                  <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                  </svg>
                  <span>Smart</span>
                </button>
              )}
            </div>
          )}

          {/* Row 4: Heatmap Legend */}
          {heatmapEnabled && competitorList.length > 0 && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 shadow-xl">
              <p className="text-sm font-medium text-slate-300 mb-2">Competition Density</p>
              <div className="flex items-center gap-1">
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(34, 197, 94)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(134, 197, 94)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(255, 200, 0)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(255, 150, 0)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(255, 80, 50)' }} />
              </div>
              <div className="flex justify-between text-xs text-slate-500 mt-2">
                <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-emerald-500"></span>Low</span>
                <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-rose-500"></span>High</span>
              </div>
            </div>
          )}

          {/* Row 5: Smart View Legend */}
          {contextualVisibility && businessType && landmarkList.length > 0 && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 shadow-xl">
              <p className="text-sm font-medium text-slate-300 mb-3 flex items-center gap-2">
                <svg className="w-4 h-4 text-violet-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                Smart: {businessType}
              </p>
              <div className="space-y-2">
                <div className="flex items-center gap-2 text-sm">
                  <div className="w-5 h-5 rounded-full bg-cyan-500 opacity-100 flex items-center justify-center">
                    <span className="text-white text-xs"></span>
                  </div>
                  <span className="text-slate-400">High relevance</span>
                </div>
                <div className="flex items-center gap-2 text-sm">
                  <div className="w-4 h-4 rounded-full bg-cyan-500 opacity-50 flex items-center justify-center">
                    <span className="text-white text-[8px]"></span>
                  </div>
                  <span className="text-slate-400">Low relevance</span>
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Search/index.js">
export { default as SearchBar } from './SearchBar';
</file>

<file path="src/components/Search/SearchBar.jsx">
/**
 * Search Bar Component - Spotlight Style
 * Glass-morphic search with glowing border effect
 */

import { useState, useEffect, useRef, useCallback } from 'react';
import { searchLocations } from '../../services/api';

// Debounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

export default function SearchBar({ onLocationSelect, disabled, selectedLocation }) {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  
  const inputRef = useRef(null);
  const dropdownRef = useRef(null);
  
  const debouncedQuery = useDebounce(query, 300);

  // Update query when selectedLocation changes (e.g., from map click)
  useEffect(() => {
    if (selectedLocation?.name) {
      setQuery(selectedLocation.name);
      setIsOpen(false);
      setSuggestions([]);
    }
  }, [selectedLocation]);

  // Fetch suggestions when debounced query changes
  useEffect(() => {
    const fetchSuggestions = async () => {
      if (debouncedQuery.length < 2) {
        setSuggestions([]);
        setIsOpen(false);
        return;
      }

      setIsLoading(true);
      try {
        const results = await searchLocations(debouncedQuery);
        setSuggestions(results);
        setIsOpen(results.length > 0);
        setSelectedIndex(-1);
      } catch (error) {
        console.error('Search error:', error);
        setSuggestions([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchSuggestions();
  }, [debouncedQuery]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target) &&
        !inputRef.current.contains(event.target)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Handle keyboard navigation
  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      setIsOpen(false);
      setSelectedIndex(-1);
      return;
    }

    if (e.key === 'Enter') {
      e.preventDefault();
      // If we have a selected suggestion, use it
      if (isOpen && selectedIndex >= 0 && suggestions[selectedIndex]) {
        handleSelect(suggestions[selectedIndex]);
      } 
      // If we have suggestions but none selected, use the first one
      else if (isOpen && suggestions.length > 0) {
        handleSelect(suggestions[0]);
      }
      // If no suggestions but we have a query, create a manual location
      else if (query.trim().length >= 2) {
        // Trigger a fresh search or use the query as-is
        onLocationSelect({
          name: query.trim(),
          lat: null,
          lng: null,
          needsGeocode: true,
        });
      }
      return;
    }

    if (!isOpen) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex((prev) => 
          prev < suggestions.length - 1 ? prev + 1 : prev
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex((prev) => (prev > 0 ? prev - 1 : -1));
        break;
      default:
        break;
    }
  };

  const handleSelect = (location) => {
    setQuery(location.name);
    setIsOpen(false);
    setSuggestions([]);
    onLocationSelect(location);
  };

  const handleClear = () => {
    setQuery('');
    setSuggestions([]);
    setIsOpen(false);
    inputRef.current?.focus();
  };

  return (
    <div className="space-y-2 relative z-10">
      <label className="text-sm font-medium text-slate-300">
        Which area to analyze?
      </label>
      <p className="text-xs text-slate-500 -mt-1">
        Search for a locality, neighborhood, or city
      </p>

      <div className="relative">
        {/* Spotlight Search Input */}
        <div className={`relative group ${isOpen ? 'ring-2 ring-emerald-500/50' : ''} rounded-xl transition-all duration-300`}>
          {/* Glow effect on focus */}
          <div className={`absolute -inset-0.5 bg-gradient-to-r from-emerald-500/20 via-cyan-500/20 to-emerald-500/20 rounded-xl blur-sm transition-opacity duration-300 ${isOpen ? 'opacity-100' : 'opacity-0 group-hover:opacity-50'}`} />
          
          <div className="relative flex items-center">
            <span className="absolute left-4 text-slate-500">
              <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            </span>
            <input
              ref={inputRef}
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={handleKeyDown}
              onFocus={() => suggestions.length > 0 && setIsOpen(true)}
              disabled={disabled}
              placeholder="Koramangala, Indiranagar, Bandra..."
              className={`
                w-full bg-black/50 border border-white/10 rounded-xl pl-12 pr-12 py-3.5
                text-white placeholder-slate-500 text-sm
                focus:outline-none focus:border-emerald-500/50 focus:bg-black/70
                transition-all duration-200
                ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
              `}
            />
            
            {/* Loading / Clear Button */}
            <div className="absolute right-4">
              {isLoading ? (
                <svg className="w-5 h-5 text-emerald-400 animate-spin" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
              ) : query ? (
                <button
                  type="button"
                  onClick={handleClear}
                  className="text-slate-500 hover:text-white transition-colors p-1"
                >
                  <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              ) : null}
            </div>
          </div>
        </div>

        {/* Suggestions Dropdown */}
        {isOpen && suggestions.length > 0 && (
          <div
            ref={dropdownRef}
            className="absolute z-50 w-full mt-2 backdrop-blur-xl bg-slate-900/95 border border-white/10 rounded-xl shadow-2xl overflow-hidden animate-slide-in-up"
          >
            <ul className="max-h-64 overflow-y-auto">
              {suggestions.map((suggestion, index) => (
                <li key={suggestion.place_id || index}>
                  <button
                    type="button"
                    onClick={() => handleSelect(suggestion)}
                    className={`
                      w-full flex items-start gap-3 px-4 py-3 text-left
                      transition-colors duration-150
                      ${selectedIndex === index ? 'bg-emerald-500/10' : 'hover:bg-white/5'}
                    `}
                  >
                    {/* Show different icon for major areas vs others */}
                    <span className="mt-0.5">
                      {suggestion.is_major ? (
                        <svg className="w-4 h-4 text-emerald-400" fill="currentColor" viewBox="0 0 20 20">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                        </svg>
                      ) : suggestion.is_area ? (
                        <svg className="w-4 h-4 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                        </svg>
                      ) : (
                        <svg className="w-4 h-4 text-cyan-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                      )}
                    </span>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <p className="text-slate-200 truncate">{suggestion.name}</p>
                        {suggestion.is_major && (
                          <span className="text-[10px] bg-emerald-500/20 text-emerald-400 px-1.5 py-0.5 rounded-full whitespace-nowrap border border-emerald-500/20">
                            Major Area
                          </span>
                        )}
                      </div>
                      {suggestion.is_area && !suggestion.is_major && (
                        <p className="text-xs text-slate-500 mt-0.5">Locality</p>
                      )}
                    </div>
                  </button>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* No results message */}
        {isOpen && query.length >= 2 && suggestions.length === 0 && !isLoading && (
          <div className="absolute z-50 w-full mt-2 backdrop-blur-xl bg-slate-900/95 border border-white/10 rounded-xl shadow-2xl p-4 text-center text-slate-400 animate-fade-in">
            <p>No locations found for "{query}"</p>
            <p className="text-xs mt-1 text-slate-500">Try a different area name or click on the map</p>
          </div>
        )}
      </div>

      {/* Hints */}
      {disabled ? (
        <p className="text-xs text-amber-400/80 flex items-center gap-1.5 mt-2">
          <svg className="w-3.5 h-3.5" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
          </svg>
          Select a business type first
        </p>
      ) : (
        <p className="text-xs text-slate-500 flex items-center gap-1.5 mt-2">
          <svg className="w-3.5 h-3.5 text-emerald-400" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
          </svg>
          You can also click anywhere on the map to select a location
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/hooks/index.js">
export { default as useAnalysis } from './useAnalysis';
export { default as useLocation } from './useLocation';
export { default as useFilters } from './useFilters';
</file>

<file path="src/hooks/useAnalysis.js">
/**
 * useAnalysis Hook
 * Manages location analysis state and API calls with progressive loading
 */

import { useState, useCallback } from 'react';
import { analyzeLocation, getIsochrone, getDigipin } from '../services/api';

/**
 * Helper to normalize landmarks from API response
 * API returns: { list: [...], by_category: {...}, total: N }
 * We need: [{ name, category, lat, lng }, ...]
 */
function normalizeAllLandmarks(landmarksData) {
  if (!landmarksData) return [];

  // If it's already an array, return it
  if (Array.isArray(landmarksData)) return landmarksData;

  // Check for 'list' property first (our API structure)
  if (Array.isArray(landmarksData.list)) {
    return landmarksData.list;
  }

  // If it has by_category with arrays, flatten all categories into one array
  if (landmarksData.by_category && typeof landmarksData.by_category === 'object') {
    const allLandmarks = [];
    Object.entries(landmarksData.by_category).forEach(([category, items]) => {
      if (Array.isArray(items)) {
        items.forEach(item => {
          allLandmarks.push({
            ...item,
            category: category,
          });
        });
      }
    });
    if (allLandmarks.length > 0) return allLandmarks;
  }

  return [];
}

export default function useAnalysis() {
  const [analysis, setAnalysis] = useState(null);
  const [isochrone, setIsochrone] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Progressive loading status
  const [loadingStatus, setLoadingStatus] = useState({
    step: '',
    message: '',
    progress: 0,
    details: []
  });

  const updateStatus = (step, message, progress, detail = null) => {
    setLoadingStatus(prev => ({
      step,
      message,
      progress,
      details: detail ? [...prev.details, detail] : prev.details
    }));
  };

  const analyze = useCallback(async (location, businessType, filters, radius = 1000) => {
    if (!location || !businessType) {
      setError('Location and business type are required');
      return { success: false, isValidationError: false };
    }

    // Validate that we have coordinates
    if (location.lat == null || location.lng == null) {
      setError('Location coordinates are missing. Please select a different location.');
      return { success: false, isValidationError: false };
    }

    // Clear previous analysis data immediately (clears markers)
    setAnalysis(null);
    setIsochrone(null);
    setError(null);

    setIsLoading(true);
    setLoadingStatus({ step: 'init', message: 'Starting analysis...', progress: 0, details: [] });

    try {
      // Determine isochrone radius based on whether it's a major area
      const isMajorArea = location.is_major || false;
      // Use provided radius (converted to km) or fallback to defaults
      const isochroneRadius = radius ? (radius / 1000) : (isMajorArea ? 2.5 : 1.5);

      // Step 1: Initialize & Validate Location
      updateStatus('validation', 'Checking location validity...', 10, ' Location validated');
      await new Promise(r => setTimeout(r, 300)); // Brief delay for UI feedback

      // Step 2: Fetch isochrone (area boundary)
      updateStatus('boundary', 'Drawing search boundary...', 20);
      let isochroneData = null;
      try {
        isochroneData = await getIsochrone(location.lat, location.lng, isochroneRadius);
        updateStatus('boundary', 'Area boundary ready', 25, ' Area boundary loaded');
      } catch (err) {
        console.warn('Isochrone fetch failed:', err);
        updateStatus('boundary', 'Using circular boundary', 25, ' Using default circular area');
      }

      // Step 3: Run main analysis (includes validation + competitors + landmarks)
      updateStatus('analysis', 'Searching for businesses & landmarks...', 35);

      const analysisData = await analyzeLocation(
        location.lat,
        location.lng,
        businessType,
        filters,
        isMajorArea,
        radius
      );

      // Extract counts for status
      const competitorCount = analysisData.competitors?.count || 0;
      const nearbyList = analysisData.competitors?.nearby || [];
      const landmarkCount = analysisData.landmarks?.total || 0;
      const landmarkCategories = Object.keys(analysisData.landmarks?.by_category || {}).length;

      // Update with competitor results
      updateStatus('competitors', `Found ${competitorCount} competitors`, 55,
        ` ${competitorCount} ${businessType}${competitorCount !== 1 ? 's' : ''} found nearby`);

      await new Promise(r => setTimeout(r, 400));

      // Update with landmark results  
      updateStatus('landmarks', `Identified ${landmarkCount} landmarks`, 70,
        ` ${landmarkCount} landmarks in ${landmarkCategories} categories`);

      await new Promise(r => setTimeout(r, 300));

      // Step 4: Get DIGIPIN (optional)
      updateStatus('digipin', 'Retrieving location code...', 80);
      let digipin = null;
      try {
        const digipinData = await getDigipin(location.lat, location.lng);
        digipin = digipinData?.digipin;
        if (digipin) {
          updateStatus('digipin', 'DIGIPIN retrieved', 85, ` DIGIPIN: ${digipin.substring(0, 10)}...`);
        } else {
          updateStatus('digipin', 'DIGIPIN not available', 85, ' Location code retrieved');
        }
      } catch {
        updateStatus('digipin', 'DIGIPIN skipped', 85, ' Location code skipped');
      }

      await new Promise(r => setTimeout(r, 200));

      // Step 5: Find recommended spots
      const spotsCount = analysisData.recommended_spots?.length || 0;
      updateStatus('spots', `Analyzing ${spotsCount} optimal locations...`, 95,
        ` ${spotsCount} recommended spot${spotsCount !== 1 ? 's' : ''} identified`);
      await new Promise(r => setTimeout(r, 200));

      // Log raw response for debugging
      console.log(' Raw API Response:', JSON.stringify(analysisData, null, 2));

      // Normalize the API response to match frontend expectations
      const normalizedAnalysis = {
        // Recommended spots (new feature)
        recommended_spots: analysisData.recommended_spots || [],
        // Extract competitors from nested structure
        competitors: {
          count: analysisData.competitors?.count || 0,
          nearby: Array.isArray(analysisData.competitors?.nearby)
            ? analysisData.competitors.nearby
            : []
        },
        // Extract landmarks
        landmarks: {
          total: analysisData.landmarks?.total || 0,
          list: normalizeAllLandmarks(analysisData.landmarks),
          by_category: analysisData.landmarks?.by_category || {}
        },
        // Additional data
        footfall_proxy: analysisData.footfall_proxy || 'medium',
        location: location,
        digipin: digipin || analysisData.location?.digipin || '',
        address: analysisData.location?.address || {},
        business_type: analysisData.business_type || businessType,
      };

      // Log normalized data for debugging
      console.log(' Normalized Analysis:', {
        recommended_spots: normalizedAnalysis.recommended_spots,
        competitors: normalizedAnalysis.competitors,
        landmarks: normalizedAnalysis.landmarks
      });

      // Complete! - Show summary
      const summaryMsg = `${competitorCount} competitors, ${landmarkCount} landmarks, ${spotsCount} spots`;
      updateStatus('complete', summaryMsg, 100);

      setAnalysis(normalizedAnalysis);
      setIsochrone(isochroneData);

      return { success: true, isValidationError: false };
    } catch (err) {
      console.error('Analysis error:', err);

      // Check if this is a validation error (location invalid)
      const isValidationError = err.isValidationError || false;
      const errorMessage = err.message || 'Failed to analyze location';

      setError(errorMessage);
      setLoadingStatus(prev => ({
        ...prev,
        step: 'error',
        message: ` ${errorMessage}`,
        progress: 0
      }));

      // Keep analysis and isochrone null (no markers on map)
      setAnalysis(null);
      setIsochrone(null);

      return {
        success: false,
        isValidationError,
        errorType: err.errorType,
        errorMessage
      };
    } finally {
      setIsLoading(false);
    }
  }, []);

  const clearAnalysis = useCallback(() => {
    setAnalysis(null);
    setIsochrone(null);
    setError(null);
    setLoadingStatus({ step: '', message: '', progress: 0, details: [] });
  }, []);

  return {
    analysis,
    isochrone,
    isLoading,
    error,
    loadingStatus,
    analyze,
    clearAnalysis,
  };
}
</file>

<file path="src/hooks/useFilters.js">
/**
 * useFilters Hook
 * Manages business type and proximity filter selections
 */

import { useState, useCallback, useMemo } from 'react';

// Popular filter presets
const POPULAR_FILTERS = ['metro', 'mall', 'office', 'college'];

export default function useFilters() {
  const [businessType, setBusinessType] = useState(null);
  const [proximityFilters, setProximityFilters] = useState([]);

  // Toggle a single proximity filter
  const toggleFilter = useCallback((filterId) => {
    setProximityFilters((prev) => {
      if (prev.includes(filterId)) {
        return prev.filter((f) => f !== filterId);
      }
      return [...prev, filterId];
    });
  }, []);

  // Select multiple filters at once
  const selectFilters = useCallback((filterIds) => {
    setProximityFilters(filterIds);
  }, []);

  // Select popular filters preset
  const selectPopularFilters = useCallback(() => {
    setProximityFilters(POPULAR_FILTERS);
  }, []);

  // Clear all proximity filters
  const clearFilters = useCallback(() => {
    setProximityFilters([]);
  }, []);

  // Clear everything (business type + filters)
  const clearAll = useCallback(() => {
    setBusinessType(null);
    setProximityFilters([]);
  }, []);

  // Check if a filter is selected
  const isFilterSelected = useCallback(
    (filterId) => proximityFilters.includes(filterId),
    [proximityFilters]
  );

  // Check if ready to analyze
  const canAnalyze = useMemo(() => {
    return businessType !== null;
  }, [businessType]);

  // Get filter summary for display
  const filterSummary = useMemo(() => {
    if (proximityFilters.length === 0) return 'No preferences set';
    if (proximityFilters.length === 1) return '1 preference';
    return `${proximityFilters.length} preferences`;
  }, [proximityFilters]);

  return {
    // State
    businessType,
    proximityFilters,
    canAnalyze,
    filterSummary,
    
    // Business Type Actions
    setBusinessType,
    
    // Proximity Filter Actions
    toggleFilter,
    selectFilters,
    selectPopularFilters,
    clearFilters,
    isFilterSelected,
    
    // Reset
    clearAll,
  };
}
</file>

<file path="src/hooks/useLocation.js">
/**
 * useLocation Hook
 * Manages selected location state
 */

import { useState, useCallback } from 'react';
import { searchLocations, geocodeLocation } from '../services/api';

export default function useLocation() {
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isGeocoding, setIsGeocoding] = useState(false);
  const [searchError, setSearchError] = useState(null);

  const search = useCallback(async (query) => {
    if (!query || query.length < 2) {
      setSearchResults([]);
      return;
    }

    setIsSearching(true);
    setSearchError(null);

    try {
      const results = await searchLocations(query);
      setSearchResults(results);
    } catch (error) {
      console.error('Search error:', error);
      setSearchError(error.message || 'Failed to search locations');
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  }, []);

  const selectLocation = useCallback(async (location) => {
    // If location already has coordinates, use it directly
    if (location.lat && location.lng) {
      setSelectedLocation(location);
      setSearchResults([]);
      return;
    }
    
    // Otherwise, geocode the location name to get coordinates
    setIsGeocoding(true);
    setSearchError(null);
    
    try {
      const geocoded = await geocodeLocation(location.name);
      setSelectedLocation({
        name: location.name,
        lat: geocoded.lat,
        lng: geocoded.lng,
        address: geocoded.address,
        geoid: location.geoid
      });
      setSearchResults([]);
    } catch (error) {
      console.error('Geocode error:', error);
      setSearchError('Could not find coordinates for this location');
      // Still set the location but without coordinates
      setSelectedLocation({
        ...location,
        lat: null,
        lng: null,
        needsGeocode: true
      });
    } finally {
      setIsGeocoding(false);
    }
  }, []);

  const selectFromCoords = useCallback((lat, lng, name = null) => {
    setSelectedLocation({
      lat,
      lng,
      name: name || `${lat.toFixed(4)}, ${lng.toFixed(4)}`,
    });
  }, []);

  const clearLocation = useCallback(() => {
    setSelectedLocation(null);
    setSearchResults([]);
    setSearchError(null);
  }, []);

  return {
    // State
    selectedLocation,
    searchResults,
    isSearching,
    isGeocoding,
    searchError,
    
    // Actions
    search,
    selectLocation,
    selectFromCoords,
    clearLocation,
  };
}
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom Glassmorphism Utilities */
@layer components {
  .glass-panel {
    @apply bg-surface-primary backdrop-blur-[12px] border border-surface-border rounded-2xl shadow-glass;
  }

  .glass-card {
    @apply bg-surface-secondary backdrop-blur-[12px] border border-surface-border rounded-xl shadow-glass;
  }

  .glass-input {
    @apply bg-canvas-base border border-surface-border rounded-lg px-4 py-3 text-slate-50 placeholder-slate-500 focus:outline-none focus:border-primary-glow focus:shadow-glow-primary transition-all duration-200;
  }

  .btn-primary {
    @apply bg-primary-glow text-canvas-deep font-semibold px-6 py-3 rounded-lg hover:bg-primary-bright active:scale-[0.98] transition-all duration-200 shadow-glow-primary disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none;
  }

  .btn-ghost {
    @apply bg-transparent border border-surface-border text-slate-300 font-medium px-4 py-2 rounded-lg hover:bg-surface-elevated hover:text-slate-50 transition-all duration-200;
  }

  .chip {
    @apply px-3 py-1.5 rounded-full text-sm font-medium transition-all duration-200 cursor-pointer select-none;
  }

  .chip-inactive {
    @apply bg-transparent border border-surface-border text-slate-500 hover:border-slate-500 hover:text-slate-400;
  }

  .chip-active {
    @apply bg-primary-soft border border-primary-glow text-primary-bright shadow-glow-primary;
  }

  .score-high {
    @apply bg-primary-soft border border-primary-glow text-primary-bright;
  }

  .score-medium {
    @apply bg-warning-soft border border-warning-glow text-warning-glow;
  }

  .score-low {
    @apply bg-destructive-soft border border-destructive-glow text-destructive-bright;
  }
}

/* Leaflet Map Dark Theme Overrides */
.leaflet-container {
  background: #020617;
  font-family: 'Inter', sans-serif;
}

.leaflet-control-zoom {
  border: 1px solid rgba(255, 255, 255, 0.08) !important;
  background: rgba(15, 23, 42, 0.9) !important;
  backdrop-filter: blur(12px);
}

.leaflet-control-zoom a {
  background: transparent !important;
  color: #cbd5e1 !important;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08) !important;
}

.leaflet-control-zoom a:hover {
  background: rgba(51, 65, 85, 0.6) !important;
  color: #f8fafc !important;
}

.leaflet-popup-content-wrapper {
  background: rgba(15, 23, 42, 0.95);
  color: #f8fafc;
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  backdrop-filter: blur(12px);
}

.leaflet-popup-tip {
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

/* Custom Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(15, 23, 42, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(100, 116, 139, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(100, 116, 139, 0.7);
}

/* Animations */
@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

.skeleton {
  background: linear-gradient(
    90deg,
    rgba(51, 65, 85, 0.3) 25%,
    rgba(51, 65, 85, 0.5) 50%,
    rgba(51, 65, 85, 0.3) 75%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

/* Pulse Ring Animation for Map Marker */
@keyframes pulseRing {
  0% {
    transform: scale(1);
    opacity: 0.8;
  }
  100% {
    transform: scale(2.5);
    opacity: 0;
  }
}

.marker-pulse-ring {
  animation: pulseRing 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Slide-in animation for dropdowns and panels */
@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.animate-slide-in-up {
  animation: slideInUp 0.2s ease-out;
}

.animate-slide-in-right {
  animation: slideInRight 0.3s ease-out;
}

.animate-fade-in {
  animation: fadeIn 0.2s ease-out;
}

.animate-fadeIn {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slideIn {
  animation: slideIn 0.3s ease-out forwards;
}

/* Toast slide down animation */
@keyframes slideDown {
  from {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

.animate-slide-down {
  animation: slideDown 0.3s ease-out forwards;
}

/* Custom marker styles */
.custom-marker {
  background: transparent !important;
  border: none !important;
}

/* Recommended spot markers - ALWAYS visible and distinct */
.recommended-spot-marker {
  background: transparent !important;
  border: none !important;
  z-index: 9999 !important;
}

/* Recommended spots should NOT scale down as much - stay prominent */
.map-zoom-7 .recommended-spot-marker > div,
.map-zoom-8 .recommended-spot-marker > div {
  transform: scale(0.6) !important;
}

.map-zoom-9 .recommended-spot-marker > div,
.map-zoom-10 .recommended-spot-marker > div {
  transform: scale(0.7) !important;
}

.map-zoom-11 .recommended-spot-marker > div,
.map-zoom-12 .recommended-spot-marker > div {
  transform: scale(0.8) !important;
}

.map-zoom-13 .recommended-spot-marker > div,
.map-zoom-14 .recommended-spot-marker > div,
.map-zoom-15 .recommended-spot-marker > div,
.map-zoom-16 .recommended-spot-marker > div,
.map-zoom-17 .recommended-spot-marker > div,
.map-zoom-18 .recommended-spot-marker > div,
.map-zoom-19 .recommended-spot-marker > div,
.map-zoom-20 .recommended-spot-marker > div {
  transform: scale(1) !important;
}

/* Dynamic marker sizing based on zoom level */
/* Range: 10% (min) to 80% (max) for regular markers */
.leaflet-marker-icon {
  transition: transform 0.15s ease-out;
}

/* Zoom-based marker scaling using CSS classes */
/* Very zoomed out - minimum 10% size */
.map-zoom-7 .custom-marker > div,
.map-zoom-8 .custom-marker > div {
  transform: scale(0.1) !important;
}

.map-zoom-9 .custom-marker > div {
  transform: scale(0.15) !important;
}

.map-zoom-10 .custom-marker > div {
  transform: scale(0.2) !important;
}

.map-zoom-11 .custom-marker > div {
  transform: scale(0.3) !important;
}

.map-zoom-12 .custom-marker > div {
  transform: scale(0.4) !important;
}

.map-zoom-13 .custom-marker > div {
  transform: scale(0.5) !important;
}

.map-zoom-14 .custom-marker > div {
  transform: scale(0.6) !important;
}

.map-zoom-15 .custom-marker > div {
  transform: scale(0.7) !important;
}

/* Max size capped at 80% - zoom 16 and above */
.map-zoom-16 .custom-marker > div,
.map-zoom-17 .custom-marker > div,
.map-zoom-18 .custom-marker > div,
.map-zoom-19 .custom-marker > div,
.map-zoom-20 .custom-marker > div {
  transform: scale(0.8) !important;
}

/* ============================================== */
/* LIGHT MODE STYLES                              */
/* ============================================== */

/* Base light mode - when 'dark' class is NOT on html */
:root:not(.dark) {
  --canvas-deep: #f8fafc;
  --canvas-base: #f1f5f9;
  --surface-primary: rgba(255, 255, 255, 0.9);
  --surface-secondary: rgba(248, 250, 252, 0.9);
  --surface-border: rgba(0, 0, 0, 0.1);
  --text-primary: #0f172a;
  --text-secondary: #475569;
  --text-muted: #64748b;
}

/* Dark mode variables */
.dark {
  --canvas-deep: #020617;
  --canvas-base: #0f172a;
  --surface-primary: rgba(15, 23, 42, 0.8);
  --surface-secondary: rgba(30, 41, 59, 0.7);
  --surface-border: rgba(255, 255, 255, 0.08);
  --text-primary: #f8fafc;
  --text-secondary: #cbd5e1;
  --text-muted: #64748b;
}

/* Light mode glass panels */
:root:not(.dark) .glass-panel {
  background: rgba(255, 255, 255, 0.85) !important;
  border-color: rgba(0, 0, 0, 0.08) !important;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

:root:not(.dark) .glass-card {
  background: rgba(255, 255, 255, 0.9) !important;
  border-color: rgba(0, 0, 0, 0.08) !important;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
}

/* Light mode inputs */
:root:not(.dark) .glass-input {
  background: rgba(255, 255, 255, 0.95) !important;
  border-color: rgba(0, 0, 0, 0.15) !important;
  color: #0f172a !important;
}

:root:not(.dark) .glass-input::placeholder {
  color: #94a3b8 !important;
}

:root:not(.dark) .glass-input:focus {
  border-color: #10b981 !important;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2) !important;
}

/* Light mode buttons */
:root:not(.dark) .btn-ghost {
  border-color: rgba(0, 0, 0, 0.15) !important;
  color: #334155 !important;
}

:root:not(.dark) .btn-ghost:hover {
  background: rgba(0, 0, 0, 0.05) !important;
  color: #0f172a !important;
}

/* Light mode chips */
:root:not(.dark) .chip-inactive {
  border-color: rgba(0, 0, 0, 0.15) !important;
  color: #64748b !important;
}

:root:not(.dark) .chip-inactive:hover {
  border-color: #94a3b8 !important;
  color: #475569 !important;
}

/* Light mode leaflet map controls */
:root:not(.dark) .leaflet-container {
  background: #f1f5f9;
}

:root:not(.dark) .leaflet-control-zoom {
  border: 1px solid rgba(0, 0, 0, 0.1) !important;
  background: rgba(255, 255, 255, 0.95) !important;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

:root:not(.dark) .leaflet-control-zoom a {
  background: transparent !important;
  color: #334155 !important;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
}

:root:not(.dark) .leaflet-control-zoom a:hover {
  background: rgba(0, 0, 0, 0.05) !important;
  color: #0f172a !important;
}

:root:not(.dark) .leaflet-popup-content-wrapper {
  background: rgba(255, 255, 255, 0.98);
  color: #0f172a;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

:root:not(.dark) .leaflet-popup-tip {
  background: rgba(255, 255, 255, 0.98);
  border: 1px solid rgba(0, 0, 0, 0.1);
}

/* Light mode scrollbar */
:root:not(.dark) ::-webkit-scrollbar-track {
  background: rgba(241, 245, 249, 0.8);
}

:root:not(.dark) ::-webkit-scrollbar-thumb {
  background: rgba(148, 163, 184, 0.5);
}

:root:not(.dark) ::-webkit-scrollbar-thumb:hover {
  background: rgba(148, 163, 184, 0.7);
}

/* Light mode skeleton loading */
:root:not(.dark) .skeleton {
  background: linear-gradient(
    90deg,
    rgba(226, 232, 240, 0.5) 25%,
    rgba(226, 232, 240, 0.8) 50%,
    rgba(226, 232, 240, 0.5) 75%
  );
  background-size: 200% 100%;
}

/* Light mode text colors - override common text utilities */
:root:not(.dark) .text-slate-50,
:root:not(.dark) .text-slate-100 {
  color: #0f172a !important;
}

:root:not(.dark) .text-slate-200,
:root:not(.dark) .text-slate-300 {
  color: #334155 !important;
}

:root:not(.dark) .text-slate-400,
:root:not(.dark) .text-slate-500 {
  color: #64748b !important;
}

/* Light mode background overrides for common patterns */
:root:not(.dark) .bg-canvas-deep {
  background-color: #f8fafc !important;
}

:root:not(.dark) .bg-canvas-base {
  background-color: #f1f5f9 !important;
}

:root:not(.dark) .bg-surface-primary {
  background-color: rgba(255, 255, 255, 0.9) !important;
}

:root:not(.dark) .bg-surface-secondary {
  background-color: rgba(248, 250, 252, 0.9) !important;
}

:root:not(.dark) .bg-surface-elevated {
  background-color: rgba(241, 245, 249, 0.9) !important;
}

/* Light mode border overrides */
:root:not(.dark) .border-surface-border {
  border-color: rgba(0, 0, 0, 0.1) !important;
}

:root:not(.dark) .border-slate-700,
:root:not(.dark) .border-slate-800 {
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Light mode gradient backgrounds */
:root:not(.dark) .bg-gradient-to-b.from-slate-900 {
  background: linear-gradient(to bottom, #f1f5f9, #f8fafc) !important;
}

:root:not(.dark) .bg-gradient-to-r.from-slate-800 {
  background: linear-gradient(to right, #f8fafc, #f1f5f9) !important;
}

/* Light mode divide colors */
:root:not(.dark) .divide-slate-700 > :not([hidden]) ~ :not([hidden]),
:root:not(.dark) .divide-slate-800 > :not([hidden]) ~ :not([hidden]) {
  border-color: rgba(0, 0, 0, 0.08) !important;
}

/* Light mode ring colors */
:root:not(.dark) .ring-slate-800,
:root:not(.dark) .ring-surface-border {
  --tw-ring-color: rgba(0, 0, 0, 0.1) !important;
}

/* Light mode hover states */
:root:not(.dark) .hover\:bg-surface-elevated:hover {
  background-color: rgba(226, 232, 240, 0.8) !important;
}

:root:not(.dark) .hover\:bg-slate-800:hover {
  background-color: rgba(226, 232, 240, 0.6) !important;
}

/* Light mode focus states */
:root:not(.dark) .focus\:border-primary-glow:focus {
  border-color: #10b981 !important;
}

/* Score cards stay consistent */
:root:not(.dark) .score-high {
  background: rgba(16, 185, 129, 0.15) !important;
}

:root:not(.dark) .score-medium {
  background: rgba(245, 158, 11, 0.15) !important;
}

:root:not(.dark) .score-low {
  background: rgba(244, 63, 94, 0.15) !important;
}

/* ============================================== */
/* SIDEBAR & PANEL LIGHT MODE OVERRIDES           */
/* ============================================== */

/* Left sidebar panel - backdrop blur with light background */
:root:not(.dark) .backdrop-blur-xl.bg-slate-900\/80 {
  background: rgba(255, 255, 255, 0.9) !important;
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Right sidebar/floating panels */
:root:not(.dark) .backdrop-blur-md.bg-slate-900\/90,
:root:not(.dark) .backdrop-blur-lg.bg-slate-900\/90 {
  background: rgba(255, 255, 255, 0.95) !important;
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Panel borders */
:root:not(.dark) .border-white\/10,
:root:not(.dark) .border-white\/5 {
  border-color: rgba(0, 0, 0, 0.08) !important;
}

/* Text color overrides for panels */
:root:not(.dark) .text-white {
  color: #0f172a !important;
}

:root:not(.dark) .text-white\/80,
:root:not(.dark) .text-white\/70,
:root:not(.dark) .text-white\/60 {
  color: #334155 !important;
}

:root:not(.dark) .text-white\/50,
:root:not(.dark) .text-white\/40 {
  color: #64748b !important;
}

/* Slider track */
:root:not(.dark) .bg-slate-700\/50 {
  background: rgba(203, 213, 225, 0.6) !important;
}

:root:not(.dark) .bg-slate-700 {
  background: #cbd5e1 !important;
}

:root:not(.dark) .bg-slate-700\/30 {
  background: rgba(203, 213, 225, 0.4) !important;
}

/* Background overlays */
:root:not(.dark) .bg-slate-900\/50,
:root:not(.dark) .bg-slate-900\/60,
:root:not(.dark) .bg-slate-900\/70,
:root:not(.dark) .bg-slate-900\/80,
:root:not(.dark) .bg-slate-900\/90 {
  background: rgba(255, 255, 255, 0.9) !important;
}

:root:not(.dark) .bg-slate-800,
:root:not(.dark) .bg-slate-800\/50,
:root:not(.dark) .bg-slate-800\/60,
:root:not(.dark) .bg-slate-800\/70,
:root:not(.dark) .bg-slate-800\/80 {
  background: rgba(241, 245, 249, 0.9) !important;
}

/* Panel shadows for light mode */
:root:not(.dark) .shadow-2xl.shadow-black\/30 {
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15) !important;
}

/* Business type selector cards */
:root:not(.dark) .bg-slate-800\/30 {
  background: rgba(241, 245, 249, 0.7) !important;
}

:root:not(.dark) .hover\:bg-slate-800\/50:hover {
  background: rgba(226, 232, 240, 0.8) !important;
}

/* Active/selected states */
:root:not(.dark) .bg-emerald-500\/10 {
  background: rgba(16, 185, 129, 0.15) !important;
}

:root:not(.dark) .border-emerald-500\/20 {
  border-color: rgba(16, 185, 129, 0.3) !important;
}

/* Floating stats panel (bottom right) */
:root:not(.dark) .bg-gradient-to-br.from-slate-800\/95 {
  background: linear-gradient(to bottom right, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95)) !important;
}

/* Score display backgrounds */
:root:not(.dark) .bg-slate-900\/80 {
  background: rgba(255, 255, 255, 0.9) !important;
}

/* Ring and circle backgrounds */
:root:not(.dark) .text-slate-700 {
  color: #cbd5e1 !important;
}

/* Preserve emerald/primary colors in light mode */
:root:not(.dark) .text-emerald-400,
:root:not(.dark) .text-emerald-500 {
  color: #059669 !important;
}

:root:not(.dark) .text-cyan-400,
:root:not(.dark) .text-cyan-500 {
  color: #0891b2 !important;
}

/* Toggle buttons and switches */
:root:not(.dark) .bg-slate-600,
:root:not(.dark) .bg-slate-600\/50 {
  background: #94a3b8 !important;
}

:root:not(.dark) .hover\:bg-slate-700:hover {
  background: #cbd5e1 !important;
}

/* Mini stat cards */
:root:not(.dark) .bg-slate-800\/40 {
  background: rgba(241, 245, 249, 0.8) !important;
}

/* Analysis panel header */
:root:not(.dark) .from-slate-800 {
  background: linear-gradient(to right, #f8fafc, #f1f5f9) !important;
}

/* Dividers */
:root:not(.dark) .bg-slate-700\/50 {
  background: rgba(203, 213, 225, 0.5) !important;
}

/* Competitor/Landmark toggle buttons */
:root:not(.dark) .bg-cyan-500\/20 {
  background: rgba(6, 182, 212, 0.15) !important;
}

:root:not(.dark) .bg-orange-500\/20 {
  background: rgba(249, 115, 22, 0.15) !important;
}

:root:not(.dark) .border-cyan-500\/30 {
  border-color: rgba(6, 182, 212, 0.3) !important;
}

:root:not(.dark) .border-orange-500\/30 {
  border-color: rgba(249, 115, 22, 0.3) !important;
}

/* Input placeholder in light mode */
:root:not(.dark) input::placeholder,
:root:not(.dark) textarea::placeholder {
  color: #94a3b8 !important;
}

/* Range slider thumb */
:root:not(.dark) input[type="range"] {
  background: rgba(203, 213, 225, 0.6) !important;
}

/* Loading skeleton pulse */
:root:not(.dark) .animate-pulse {
  background-color: rgba(203, 213, 225, 0.5) !important;
}

/* Fix for accent colored text that should stay vibrant */
:root:not(.dark) .text-amber-400,
:root:not(.dark) .text-amber-500 {
  color: #d97706 !important;
}

:root:not(.dark) .text-rose-400,
:root:not(.dark) .text-rose-500 {
  color: #e11d48 !important;
}

:root:not(.dark) .text-violet-400,
:root:not(.dark) .text-violet-500 {
  color: #7c3aed !important;
}

/* Keep primary button text white */
:root:not(.dark) .bg-gradient-to-r.from-emerald-500 .text-white,
:root:not(.dark) .bg-emerald-500 .text-white,
:root:not(.dark) button.bg-gradient-to-r {
  color: white !important;
}

/* Button with gradient should keep white text */
:root:not(.dark) .from-emerald-500.to-cyan-500 {
  color: white !important;
}

/* Search input specific overrides */
:root:not(.dark) .bg-black\/50 {
  background: rgba(255, 255, 255, 0.95) !important;
}

:root:not(.dark) .bg-black\/70 {
  background: rgba(255, 255, 255, 0.98) !important;
}

:root:not(.dark) input.text-white {
  color: #0f172a !important;
}

/* Search dropdown */
:root:not(.dark) .bg-slate-900\/95 {
  background: rgba(255, 255, 255, 0.98) !important;
}

/* Dropdown items hover */
:root:not(.dark) .hover\:bg-slate-800\/50:hover {
  background: rgba(226, 232, 240, 0.7) !important;
}

:root:not(.dark) .bg-emerald-500\/10 {
  background: rgba(16, 185, 129, 0.12) !important;
}

/* Floating stats panel specific */
:root:not(.dark) .rounded-2xl.backdrop-blur-md {
  background: rgba(255, 255, 255, 0.95) !important;
}

/* Mini badges/pills */
:root:not(.dark) .bg-slate-700\/60 {
  background: rgba(203, 213, 225, 0.6) !important;
}

:root:not(.dark) .bg-slate-700\/40 {
  background: rgba(203, 213, 225, 0.4) !important;
}

/* Right panel specific styles */
:root:not(.dark) .space-y-2 .text-xs.text-slate-500 {
  color: #64748b !important;
}

:root:not(.dark) .space-y-1 .text-xs.text-slate-500 {
  color: #64748b !important;
}

/* Ensure all form inputs are readable */
:root:not(.dark) input[type="text"],
:root:not(.dark) input[type="search"] {
  color: #0f172a !important;
}

/* Map overlay controls */
:root:not(.dark) .bg-slate-800\/90 {
  background: rgba(255, 255, 255, 0.95) !important;
}

:root:not(.dark) .bg-slate-900 {
  background: #f8fafc !important;
}

/* Chip/tag active states */
:root:not(.dark) .bg-emerald-500\/20 {
  background: rgba(16, 185, 129, 0.18) !important;
}

:root:not(.dark) .bg-cyan-500\/10 {
  background: rgba(6, 182, 212, 0.12) !important;
}

:root:not(.dark) .bg-orange-500\/10 {
  background: rgba(249, 115, 22, 0.12) !important;
}

/* Dashboard cards text */
:root:not(.dark) .font-semibold.text-white {
  color: #0f172a !important;
}

:root:not(.dark) .font-medium.text-white {
  color: #1e293b !important;
}

/* Stats numbers should be dark */
:root:not(.dark) .text-2xl.font-bold.text-white,
:root:not(.dark) .text-3xl.font-bold.text-white,
:root:not(.dark) .text-xl.font-bold.text-white {
  color: #0f172a !important;
}

/* Keep primary colored text vibrant */
:root:not(.dark) .text-primary-glow,
:root:not(.dark) .text-primary-bright {
  color: #059669 !important;
}

/* Fix floating panel in bottom right */
:root:not(.dark) .fixed.bottom-6.right-6 .backdrop-blur-md {
  background: rgba(255, 255, 255, 0.95) !important;
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Business type selector inactive cards */
:root:not(.dark) .border-white\/5 {
  border-color: rgba(0, 0, 0, 0.08) !important;
}

:root:not(.dark) .hover\:bg-white\/5:hover {
  background: rgba(0, 0, 0, 0.03) !important;
}

:root:not(.dark) .hover\:border-white\/10:hover {
  border-color: rgba(0, 0, 0, 0.12) !important;
}

/* Placeholder text */
:root:not(.dark) .placeholder-slate-500::placeholder {
  color: #94a3b8 !important;
}

/* Right panel toggle buttons container */
:root:not(.dark) .bg-slate-800\/60 {
  background: rgba(241, 245, 249, 0.8) !important;
}

/* Bottom right stats - ensure dark text */
:root:not(.dark) .text-lg.font-bold {
  color: #0f172a !important;
}

:root:not(.dark) .text-sm.font-semibold {
  color: #1e293b !important;
}

/* Legend/key colors - keep them visible */
:root:not(.dark) .bg-emerald-400,
:root:not(.dark) .bg-emerald-500 {
  background-color: #10b981 !important;
}

:root:not(.dark) .bg-amber-400,
:root:not(.dark) .bg-amber-500 {
  background-color: #f59e0b !important;
}

:root:not(.dark) .bg-rose-400,
:root:not(.dark) .bg-rose-500 {
  background-color: #f43f5e !important;
}

/* Make sure analyze button keeps white text */
:root:not(.dark) button.bg-gradient-to-r.from-emerald-500.to-cyan-500,
:root:not(.dark) .bg-gradient-to-r.from-emerald-500.to-cyan-500 button {
  color: white !important;
}

/* Generic white text in buttons should be preserved for colored backgrounds */
:root:not(.dark) .bg-emerald-500 .text-white,
:root:not(.dark) .bg-cyan-500 .text-white,
:root:not(.dark) .bg-gradient-to-r .text-white {
  color: white !important;
}

/* Fix the analyze button specifically */
:root:not(.dark) button[class*="from-emerald-500"][class*="to-cyan-500"] {
  color: white !important;
}
</file>

<file path="src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import 'leaflet/dist/leaflet.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="src/services/api.js">
/**
 * Hotspot IQ - API Service Layer
 * Handles all communication with the Flask backend
 */

import axios from 'axios';

// Create axios instance with base configuration
const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api',
  timeout: 120000, // 2 minutes to handle longer analysis calls
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for logging
api.interceptors.request.use(
  (config) => {
    console.log(` API Request: ${config.method?.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    console.error('API Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    console.error('API Response Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

/**
 * Search for locations using autocomplete
 * @param {string} query - Search term
 * @returns {Promise<Array>} Location suggestions
 */
export const searchLocations = async (query) => {
  if (!query || query.length < 2) return [];

  try {
    const response = await api.get('/autocomplete', { params: { query, limit: 10 } });
    const suggestions = response.data.suggestions || [];

    // LatLong autocomplete returns { name, geoid } without coordinates
    // We need to geocode to get coordinates when user selects a location
    return suggestions.map(s => ({
      name: s.name,
      place_id: s.place_id || s.geoid?.toString() || s.name,
      geoid: s.geoid,
      // lat/lng may be null from autocomplete - will be geocoded on selection
      lat: s.lat,
      lng: s.lng
    }));
  } catch (error) {
    console.error('Search error:', error);
    throw error;
  }
};

/**
 * Geocode a location name to get coordinates
 * @param {string} address - Location name/address
 * @returns {Promise<Object>} Location with coordinates
 */
export const geocodeLocation = async (address) => {
  try {
    const response = await api.get('/geocode', { params: { address } });
    return response.data;
  } catch (error) {
    console.error('Geocode error:', error);
    throw error;
  }
};

/**
 * Reverse geocode coordinates to get address
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} radius - Optional radius in meters for area-based geocoding
 * @returns {Promise<Object>} Address details { address, area_name, pincode, landmark }
 */
export const reverseGeocode = async (lat, lng, radius = 0) => {
  try {
    const params = { lat, lng };
    if (radius > 0) {
      params.radius = radius;
    }
    const response = await api.get('/reverse-geocode', { params });
    return response.data;
  } catch (error) {
    console.error('Reverse geocode error:', error);
    throw error;
  }
};

/**
 * Analyze a location for business potential
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {string} businessType - Type of business
 * @param {Array<string>} filters - Proximity filters
 * @param {boolean} isMajor - Whether this is a major area (larger radius)
 * @returns {Promise<Object>} Analysis results
 * @throws {Error} With validation error message if location is invalid
 */
export const analyzeLocation = async (lat, lng, businessType, filters = [], isMajor = false, radius = 1000) => {
  try {
    const response = await api.post('/analyze', {
      lat,
      lng,
      business_type: businessType,
      filters,
      is_major: isMajor,
      radius,
    });
    return response.data;
  } catch (error) {
    console.error('Analysis error:', error);

    // Extract validation error from backend response
    if (error.response?.data) {
      const data = error.response.data;

      // Check if this is a validation failure
      if (data.validation_failed || data.error_type) {
        const validationError = new Error(data.error || data.message || 'Location validation failed');
        validationError.isValidationError = true;
        validationError.errorType = data.error_type;
        throw validationError;
      }

      // Regular error with message from backend
      if (data.error) {
        throw new Error(data.error);
      }
    }

    throw error;
  }
};

/**
 * Get isochrone polygon for reachability
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} distanceKm - Distance in kilometers (default: 1.0)
 * @returns {Promise<Object>} GeoJSON Feature
 * 
 * Also supports legacy mode/time format which is converted on backend:
 * @param {string} mode - Travel mode (walk, bike, car) - optional
 * @param {number} timeMinutes - Travel time in minutes - optional
 */
export const getIsochrone = async (lat, lng, distanceKmOrMode = 1.0, timeMinutes = null) => {
  try {
    let payload = { lat, lng };

    // Support both new format (distance_km) and legacy (mode + time_minutes)
    if (typeof distanceKmOrMode === 'number' && timeMinutes === null) {
      payload.distance_km = distanceKmOrMode;
    } else if (typeof distanceKmOrMode === 'string') {
      payload.mode = distanceKmOrMode;
      payload.time_minutes = timeMinutes || 15;
    } else {
      payload.distance_km = distanceKmOrMode;
    }

    const response = await api.post('/isochrone', payload);
    return response.data;
  } catch (error) {
    console.error('Isochrone error:', error);
    throw error;
  }
};

/**
 * Get Digipin for a location
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @returns {Promise<Object>} Digipin data
 */
export const getDigipin = async (lat, lng) => {
  try {
    const response = await api.get('/digipin', { params: { lat, lng } });
    return response.data;
  } catch (error) {
    console.error('Digipin error:', error);
    throw error;
  }
};

/**
 * Send chat message to AI assistant
 * @param {string} message - User message
 * @param {Object} context - Location context
 * @returns {Promise<Object>} AI response
 */
export const chat = async (message, context = {}) => {
  try {
    const response = await api.post('/chat', {
      message,
      context,
    });
    return response.data;
  } catch (error) {
    console.error('Chat error:', error);
    throw error;
  }
};

/**
 * Check supply chain feasibility
 * @param {number} storeLat - Store latitude
 * @param {number} storeLng - Store longitude
 * @param {number} warehouseLat - Warehouse latitude
 * @param {number} warehouseLng - Warehouse longitude
 * @returns {Promise<Object>} Supply chain analysis
 */
export const checkSupplyChain = async (storeLat, storeLng, warehouseLat, warehouseLng) => {
  try {
    const response = await api.post('/supply-chain', {
      store_lat: storeLat,
      store_lng: storeLng,
      warehouse_lat: warehouseLat,
      warehouse_lng: warehouseLng,
    });
    return response.data;
  } catch (error) {
    console.error('Supply chain error:', error);
    throw error;
  }
};

/**
 * Health check
 * @returns {Promise<Object>} Health status
 */
export const healthCheck = async () => {
  try {
    const response = await api.get('/health');
    return response.data;
  } catch (error) {
    console.error('Health check failed:', error);
    throw error;
  }
};



export default api;
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class', // Enable class-based dark mode
  theme: {
    extend: {
      colors: {
        // Canvas - Background layers
        canvas: {
          deep: '#020617',  // slate-950
          base: '#0f172a',  // slate-900
        },
        // Light mode canvas
        'canvas-light': {
          deep: '#f8fafc',  // slate-50
          base: '#f1f5f9',  // slate-100
        },
        // Surface - Glass layers
        surface: {
          primary: 'rgba(15, 23, 42, 0.8)',
          secondary: 'rgba(30, 41, 59, 0.7)',
          elevated: 'rgba(51, 65, 85, 0.6)',
          border: 'rgba(255, 255, 255, 0.08)',
        },
        // Light mode surfaces
        'surface-light': {
          primary: 'rgba(255, 255, 255, 0.9)',
          secondary: 'rgba(248, 250, 252, 0.9)',
          elevated: 'rgba(241, 245, 249, 0.9)',
          border: 'rgba(0, 0, 0, 0.1)',
        },
        // Primary - Neon Emerald
        primary: {
          glow: '#10b981',     // emerald-500
          bright: '#34d399',   // emerald-400
          soft: 'rgba(16, 185, 129, 0.2)',
          pulse: 'rgba(16, 185, 129, 0.5)',
        },
        // Warning - Amber
        warning: {
          glow: '#f59e0b',     // amber-500
          soft: 'rgba(245, 158, 11, 0.2)',
        },
        // Destructive - Rose
        destructive: {
          glow: '#f43f5e',     // rose-500
          bright: '#fb7185',   // rose-400
          soft: 'rgba(244, 63, 94, 0.2)',
        },
        // Accent
        accent: {
          cyan: '#06b6d4',     // cyan-500
          violet: '#8b5cf6',   // violet-500
        }
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
        mono: ['JetBrains Mono', 'Fira Code', 'Consolas', 'monospace'],
      },
      boxShadow: {
        'glow-primary': '0 0 20px rgba(16, 185, 129, 0.4), 0 0 40px rgba(16, 185, 129, 0.2)',
        'glow-warning': '0 0 20px rgba(245, 158, 11, 0.4), 0 0 40px rgba(245, 158, 11, 0.2)',
        'glow-destructive': '0 0 20px rgba(244, 63, 94, 0.4), 0 0 40px rgba(244, 63, 94, 0.2)',
        'glow-violet': '0 0 20px rgba(139, 92, 246, 0.4), 0 0 40px rgba(139, 92, 246, 0.2)',
        'glass': '0 8px 32px rgba(0, 0, 0, 0.4)',
      },
      backdropBlur: {
        'glass': '12px',
      },
      animation: {
        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'slide-in-right': 'slideInRight 0.4s ease-out',
        'slide-in-up': 'slideInUp 0.3s ease-out',
        'fade-in': 'fadeIn 0.2s ease-out',
        'glow-pulse': 'glowPulse 2s ease-in-out infinite',
      },
      keyframes: {
        slideInRight: {
          '0%': { transform: 'translateX(20px)', opacity: '0' },
          '100%': { transform: 'translateX(0)', opacity: '1' },
        },
        slideInUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        glowPulse: {
          '0%, 100%': { boxShadow: '0 0 20px rgba(16, 185, 129, 0.4)' },
          '50%': { boxShadow: '0 0 30px rgba(16, 185, 129, 0.6), 0 0 60px rgba(16, 185, 129, 0.3)' },
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true
  }
})
</file>

</files>
</file>

<file path=".gitignore">
# Dependencies
node_modules/
__pycache__/
*.pyc
venv/
.venv/

# Environment files
.env
.env.local
.env.*.local
*.env

# IDE
.vscode/
.idea/

# Build outputs
dist/
build/

# Logs
*.log
npm-debug.log*

# OS
.DS_Store
Thumbs.db
</file>

<file path="backend/.gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
env/
.venv/

# Environment Variables
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# Logs
*.log
logs/

# Cache
.cache/
*.cache

# OS
.DS_Store
Thumbs.db
</file>

<file path="backend/routes/__init__.py">
"""
Hotspot IQ - Routes Package
"""

from .location_routes import location_bp
from .analysis_routes import analysis_bp
from .chat_routes import chat_bp

__all__ = ['location_bp', 'analysis_bp', 'chat_bp']
</file>

<file path="backend/routes/location_routes.py">
"""
Hotspot IQ - Location Routes
Handles autocomplete, reverse geocoding, and digipin endpoints.
"""

from flask import Blueprint, request, jsonify
from services.latlong_service import latlong_service

location_bp = Blueprint('location', __name__)


@location_bp.route('/autocomplete', methods=['GET'])
def autocomplete():
    """
    GET /api/autocomplete?query={search_term}&lat={lat}&lng={lng}&limit={limit}
    
    Returns location suggestions for autocomplete dropdown.
    
    LatLong API returns:
    {
        "data": [
            { "name": "Delhi, South West Delhi, Delhi", "geoid": 188443 }
        ]
    }
    
    Note: Autocomplete results don't include coordinates.
    For coordinates, use the geocode endpoint with the location name.
    """
    query = request.args.get('query', '')
    limit = request.args.get('limit', 10, type=int)
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    
    if len(query) < 2:
        return jsonify({'suggestions': []})
    
    suggestions = latlong_service.autocomplete(query, lat, lng, limit)
    
    return jsonify({'suggestions': suggestions})


@location_bp.route('/geocode', methods=['GET'])
def geocode():
    """
    GET /api/geocode?address={address}
    
    Returns coordinates from an address.
    Use this after autocomplete to get lat/lng for a location.
    """
    address = request.args.get('address', '')
    
    if not address:
        return jsonify({'error': 'address parameter is required'}), 400
    
    result = latlong_service.geocode(address)
    
    if 'error' in result:
        return jsonify({'error': 'Could not geocode address'}), 404
    
    return jsonify(result)


@location_bp.route('/reverse-geocode', methods=['GET'])
def reverse_geocode():
    """
    GET /api/reverse-geocode?lat={lat}&lng={lng}&radius={radius}
    
    Returns address details from coordinates.
    If radius is provided, samples multiple points to find the most representative area name.
    """
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    radius = request.args.get('radius', type=int, default=0)
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng parameters are required'}), 400
    
    # If radius provided, use area-based reverse geocoding
    if radius and radius > 0:
        result = latlong_service.reverse_geocode_area(lat, lng, radius)
    else:
        result = latlong_service.reverse_geocode(lat, lng)
    
    return jsonify(result)


@location_bp.route('/digipin', methods=['GET'])
def get_digipin():
    """
    GET /api/digipin?lat={lat}&lng={lng}
    
    Returns Digipin (Digital Address Code) for a location.
    """
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng parameters are required'}), 400
    
    result = latlong_service.get_digipin(lat, lng)
    
    return jsonify(result)
</file>

<file path="backend/services/chat_agent.py">
"""
Hotspot IQ - Chat Agent Service
Provides a retrieval-augmented generation (RAG) helper that:
- fetches local analysis/POI/landmark data
- fetches short web snippets using DuckDuckGo
- composes a contextual prompt and queries OpenAI

The implementation strives to be simple and self-contained so it is
easy to extend later (add embeddings store, richer document loader, etc.).
"""

import os
import requests
from typing import Dict, Any, List, Tuple
from config import Config

try:
    from duckduckgo_search import ddg
except Exception:
    ddg = None


def _load_local_docs(repo_root: str) -> List[Tuple[str, str]]:
    """Load small local documentation files (README, DESIGN) as (title, text).
    This lets the assistant reference project-specific details visible in the repo.
    """
    docs = []
    candidates = ["README.md", "DESIGN.md", "TASKS.md"]
    for name in candidates:
        path = os.path.join(repo_root, name)
        if os.path.exists(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    text = f.read(2048)
                docs.append((name, text))
            except Exception:
                continue
    return docs


def _search_web(query: str, max_results: int = 3) -> List[Dict[str, str]]:
    """Run a quick DuckDuckGo search and return small snippets.
    Falls back to an empty list if the package isn't installed.
    """
    results = []
    if ddg is None:
        return results

    try:
        hits = ddg(query, max_results=max_results)
        if not hits:
            return results

        for h in hits[:max_results]:
            results.append({
                "title": h.get("title") or h.get("text") or "",
                "href": h.get("href") or h.get("url") or "",
                "snippet": h.get("body") or h.get("snippet") or ""
            })
    except Exception:
        return []

    return results


def _compose_prompt(system_instructions: str, analysis_data: Dict[str, Any], message: str,
                    web_snippets: List[Dict[str, str]], local_docs: List[Tuple[str, str]]) -> List[Dict[str, str]]:
    """Compose chat messages list for OpenAI Chat API.
    We include: system, user context, web snippets, and user's question.
    """
    context_lines = []

    # Basic location & analysis
    if analysis_data:
        context_lines.append(f"Location: {analysis_data.get('lat')},{analysis_data.get('lng')}")
        address = analysis_data.get('address', {})
        if isinstance(address, dict):
            context_lines.append(f"Address: {address.get('formatted_address','')}")
        context_lines.append(f"Business type: {analysis_data.get('business_type','')}")
        context_lines.append(f"Opportunity score: {analysis_data.get('opportunity_score','N/A')}")
        comp_count = 0
        try:
            comp_count = analysis_data.get('competitors', {}).get('count', 0)
        except Exception:
            comp_count = 0
        context_lines.append(f"Competitors nearby: {comp_count}")

    # Add brief landmarks summary if present
    landmarks = analysis_data.get('landmarks') if analysis_data else None
    if landmarks:
        try:
            by_cat = landmarks.get('by_category', {})
            for k, v in (by_cat.items() if isinstance(by_cat, dict) else []):
                context_lines.append(f"Landmarks - {k}: {v}")
        except Exception:
            pass

    # Add recommended spots
    rec_spots = analysis_data.get('recommended_spots') if analysis_data else None
    if rec_spots:
        context_lines.append("Recommended Spots (Top 5):")
        for i, spot in enumerate(rec_spots[:5], 1):
            context_lines.append(f"- Spot #{i}: Score {spot.get('total_score', 'N/A')}/100 - {spot.get('rating_label', 'N/A')} (Lat: {spot.get('lat')}, Lng: {spot.get('lng')})")

    # Add web snippets
    if web_snippets:
        context_lines.append("Web snippets:")
        for s in web_snippets:
            context_lines.append(f"- {s.get('title','')}: {s.get('snippet','')[:240]}  ({s.get('href','')})")

    # Add small local docs
    if local_docs:
        context_lines.append("Local docs:")
        for name, text in local_docs:
            excerpt = text.replace('\n', ' ')[:400]
            context_lines.append(f"- {name}: {excerpt}...")

    user_prompt = "\n".join(context_lines) + "\n\nUser question: " + message

    messages = [
        {"role": "system", "content": system_instructions},
        {"role": "user", "content": user_prompt}
    ]

    return messages


def answer_question(message: str, context: Dict[str, Any]) -> Dict[str, Any]:
    """Main entrypoint used by the route.

    Steps:
    - Ensure we have analysis_data (fetch if needed using provided services in context)
    - Run a quick web search for the user query
    - Load small local docs
    - Compose prompt and call OpenAI Chat completion
    """
    # Provide helpful system instruction
    system = (
        "You are Hotspot IQ, an expert location intelligence assistant for small businesses. "
        "Answer concisely, cite which data sources you used (local analysis, project docs, web search), "
        "and when you are uncertain say so. Prioritize local analysis data over web snippets."
    )

    analysis_data = context.get('analysis_data') or {}
    lat = context.get('lat')
    lng = context.get('lng')
    business_type = context.get('business_type')

    # If coords provided but no analysis, try to call provided retriever in context
    retriever = context.get('retriever')
    if (lat and lng) and not analysis_data and callable(retriever):
        try:
            analysis_data = retriever(lat, lng, business_type)
        except Exception:
            analysis_data = {}

    # Web snippets
    web_snips = []
    try:
        web_snips = _search_web(message, max_results=3)
    except Exception:
        web_snips = []

    # Local docs from repo root
    repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
    local_docs = _load_local_docs(repo_root)

    # Compose messages
    messages = _compose_prompt(system, analysis_data or {}, message, web_snips, local_docs)

    # If Hugging Face not configured, return template/fallback
    if not Config.HUGGINGFACE_API_KEY:
        # Return minimal template response
        response = {
            'response': 'AI not configured. Provide HUGGINGFACE_API_KEY in environment to enable the assistant.',
            'data_sources': ['local_analysis', 'local_docs', 'web_snippets' if web_snips else 'none'],
            'ai_powered': False
        }
        return response

    # Call Hugging Face
    try:
        from huggingface_hub import InferenceClient
        client = InferenceClient(
            model=Config.HUGGINGFACE_MODEL,
            token=Config.HUGGINGFACE_API_KEY
        )

        # Use chat_completion for instruction-tuned models
        # We need to convert our messages format to what HF expects (list of dicts with role/content)
        # Our 'messages' variable is already in that format: [{'role': 'system', ...}, {'role': 'user', ...}]
        
        response_text = ""
        for token in client.chat_completion(messages, max_tokens=600, stream=True):
            if token.choices and token.choices[0].delta.content:
                response_text += token.choices[0].delta.content

        return {
            'response': response_text,
            'data_sources': ['local_analysis'] + (['local_docs'] if local_docs else []) + (['web_snippets'] if web_snips else []),
            'ai_powered': True
        }

    except Exception as e:
        return {
            'response': f'Error contacting AI service: {e}',
            'data_sources': ['local_analysis'],
            'ai_powered': False,
            'error': str(e)
        }
</file>

<file path="backend/services/relevance_service.py">
"""
Relevance Matrix Service
========================
This service provides contextual visibility scoring for landmarks based on the selected business type.

Data Science Rationale:
-----------------------
The relevance scores are based on customer behavior patterns and business synergy analysis:

1. FOOT TRAFFIC SYNERGY: Landmarks that generate foot traffic relevant to the business
2. DEMOGRAPHIC ALIGNMENT: Locations whose visitors match the target customer profile  
3. COMPLEMENTARY SERVICES: Businesses that create mutual benefit (e.g., gym + pharmacy)
4. TIME-OF-DAY PATTERNS: Locations with overlapping peak hours
5. ECONOMIC CORRELATION: Areas with spending patterns matching the business model

Scoring Scale:
- 1.0: Critical relevance (primary customer source)
- 0.8: High relevance (significant customer overlap)
- 0.6: Moderate relevance (some customer benefit)
- 0.4: Low relevance (minimal impact)
- 0.2: Very low relevance (negligible impact)
- 0.1: Irrelevant (potentially negative correlation)
"""

# Comprehensive Relevance Matrix
# Maps: business_type -> landmark_category -> relevance_score
RELEVANCE_MATRIX = {
    # =========================================================================
    # CAFE / COFFEE SHOP
    # Target: Young professionals, students, remote workers, casual meetups
    # Peak: Morning rush, lunch breaks, afternoon work sessions
    # =========================================================================
    'cafe': {
        # HIGH RELEVANCE (0.8-1.0) - Primary customer sources
        'office': 1.0,          # Office workers = morning coffee, lunch meetings
        'coworking': 1.0,       # Remote workers, freelancers
        'college': 0.95,        # Students studying, group projects
        'university': 0.95,     # Academic crowd, study sessions
        'library': 0.9,         # Readers, students needing caffeine
        'bookstore': 0.9,       # Literary crowd, reading enthusiasts
        'bank': 0.85,           # Professionals during breaks
        'corporate': 0.85,      # Business meetings, client discussions
        
        # MODERATE-HIGH RELEVANCE (0.6-0.8)
        'mall': 0.75,           # Shoppers taking breaks
        'shopping': 0.75,       # Retail therapy + coffee
        'metro': 0.7,           # Commuters grabbing coffee
        'metro_station': 0.7,
        'bus_stop': 0.65,       # Transit users
        'bus': 0.65,
        'railway': 0.7,         # Travelers, commuters
        'railway_station': 0.7,
        'gym': 0.6,             # Post-workout refreshment
        'park': 0.6,            # Leisure visitors
        'cinema': 0.65,         # Before/after movie crowds
        'theatre': 0.65,
        
        # MODERATE RELEVANCE (0.4-0.6)
        'residential': 0.55,    # Local residents
        'apartment': 0.55,
        'hotel': 0.5,           # Tourists, business travelers
        'hospital': 0.45,       # Visitors, staff breaks
        'clinic': 0.45,
        'salon': 0.5,           # Waiting clients
        'spa': 0.5,
        'museum': 0.55,         # Cultural visitors
        'art_gallery': 0.55,
        
        # LOW RELEVANCE (0.2-0.4)
        'school': 0.35,         # Parents dropping kids (limited)
        'temple': 0.3,          # Religious visitors (brief stops)
        'church': 0.3,
        'mosque': 0.3,
        'pharmacy': 0.35,       # Quick errands
        'supermarket': 0.4,     # Grocery shoppers
        'industrial': 0.25,     # Factory workers (limited breaks)
        'warehouse': 0.2,
        
        # VERY LOW RELEVANCE (0.1-0.2)
        'bar': 0.2,             # Different time/demographic
        'pub': 0.2,
        'nightclub': 0.15,
        'cemetery': 0.1,
        'funeral': 0.1,
    },
    
    # =========================================================================
    # RESTAURANT / FAST FOOD
    # Target: Families, office workers, tourists, social diners
    # Peak: Lunch (12-2pm), Dinner (7-10pm)
    # =========================================================================
    'restaurant': {
        # HIGH RELEVANCE
        'office': 1.0,          # Lunch crowds, team dinners
        'corporate': 1.0,
        'mall': 0.95,           # Shopping + dining combo
        'shopping': 0.95,
        'cinema': 0.9,          # Pre/post movie dining
        'theatre': 0.9,
        'hotel': 0.9,           # Tourists, business travelers
        'residential': 0.85,    # Family dinners, local regulars
        'apartment': 0.85,
        
        # MODERATE-HIGH RELEVANCE
        'metro': 0.75,          # Commuters
        'metro_station': 0.75,
        'railway': 0.75,
        'railway_station': 0.75,
        'bus_stop': 0.7,
        'bus': 0.7,
        'college': 0.7,         # Student groups
        'university': 0.7,
        'park': 0.65,           # Family outings
        'tourist_attraction': 0.8,
        'museum': 0.7,
        'bar': 0.6,             # Pub + food combo
        'pub': 0.6,
        
        # MODERATE RELEVANCE
        'gym': 0.5,             # Health-conscious (depends on type)
        'hospital': 0.55,       # Visitors, staff
        'clinic': 0.5,
        'temple': 0.5,          # After religious events
        'church': 0.5,
        'mosque': 0.5,
        'school': 0.45,         # Parent pickups
        'bank': 0.5,
        
        # LOW RELEVANCE
        'pharmacy': 0.35,
        'salon': 0.4,
        'spa': 0.4,
        'library': 0.35,
        'industrial': 0.3,
        'warehouse': 0.25,
        'cemetery': 0.15,
        'funeral': 0.15,
    },
    
    # =========================================================================
    # RETAIL STORE (General)
    # Target: Broad demographic, impulse buyers, planned shoppers
    # Peak: Weekends, evenings, festivals
    # =========================================================================
    'retail': {
        # HIGH RELEVANCE
        'mall': 1.0,            # Shopping destination
        'shopping': 1.0,
        'residential': 0.95,    # Local shoppers
        'apartment': 0.95,
        'metro': 0.85,          # High foot traffic
        'metro_station': 0.85,
        'bus_stop': 0.8,
        'bus': 0.8,
        'railway': 0.8,
        'railway_station': 0.8,
        'market': 0.9,
        
        # MODERATE-HIGH RELEVANCE
        'office': 0.75,         # After-work shopping
        'corporate': 0.75,
        'bank': 0.7,            # Financial district foot traffic
        'atm': 0.65,
        'college': 0.65,
        'university': 0.65,
        'park': 0.6,
        'cinema': 0.65,
        'hotel': 0.6,
        
        # MODERATE RELEVANCE
        'hospital': 0.5,
        'clinic': 0.45,
        'school': 0.5,
        'temple': 0.45,
        'church': 0.45,
        'mosque': 0.45,
        'gym': 0.5,
        'salon': 0.55,
        'restaurant': 0.55,
        'cafe': 0.55,
        
        # LOW RELEVANCE
        'bar': 0.35,
        'pub': 0.35,
        'nightclub': 0.3,
        'industrial': 0.3,
        'warehouse': 0.35,
        'cemetery': 0.15,
        'library': 0.4,
    },
    
    # =========================================================================
    # GYM / FITNESS CENTER
    # Target: Health-conscious, 25-45 age group, office workers
    # Peak: Early morning (6-8am), Evening (5-8pm)
    # =========================================================================
    'gym': {
        # HIGH RELEVANCE
        'office': 1.0,          # Before/after work fitness
        'corporate': 1.0,
        'residential': 0.95,    # Local fitness enthusiasts
        'apartment': 0.95,
        'park': 0.85,           # Outdoor fitness, runners
        'sports_complex': 0.9,
        'stadium': 0.8,
        
        # MODERATE-HIGH RELEVANCE
        'pharmacy': 0.7,        # Supplements, health products
        'clinic': 0.65,         # Physiotherapy referrals
        'hospital': 0.6,        # Rehab, health-focused
        'salon': 0.65,          # Self-care demographic overlap
        'spa': 0.7,             # Wellness seekers
        'college': 0.7,         # Young fitness crowd
        'university': 0.7,
        'mall': 0.6,            # Gym in mall complexes
        'hotel': 0.55,          # Business travelers
        
        # MODERATE RELEVANCE
        'metro': 0.5,           # Commuter convenience
        'metro_station': 0.5,
        'bus_stop': 0.45,
        'bus': 0.45,
        'supermarket': 0.5,     # Health food shoppers
        'cafe': 0.45,           # Post-workout (protein shakes)
        'restaurant': 0.4,
        
        # LOW RELEVANCE
        'bar': 0.2,             # Opposite lifestyle
        'pub': 0.2,
        'nightclub': 0.15,
        'fast_food': 0.2,
        'school': 0.35,
        'temple': 0.3,
        'church': 0.3,
        'mosque': 0.3,
        'cinema': 0.35,
        'library': 0.3,
        'cemetery': 0.1,
        'industrial': 0.25,
    },
    
    # =========================================================================
    # PHARMACY / MEDICAL
    # Target: All demographics, health-focused, elderly, families
    # Peak: Throughout day, post-doctor visits
    # =========================================================================
    'pharmacy': {
        # HIGH RELEVANCE
        'hospital': 1.0,        # Post-treatment prescriptions
        'clinic': 1.0,          # Doctor referrals
        'medical_center': 1.0,
        'doctor': 0.95,
        'dental': 0.85,
        'residential': 0.9,     # Local health needs
        'apartment': 0.9,
        'elderly_home': 0.95,   # Regular medication needs
        'nursing_home': 0.95,
        
        # MODERATE-HIGH RELEVANCE
        'gym': 0.7,             # Supplements, sports medicine
        'supermarket': 0.7,     # One-stop health shopping
        'mall': 0.65,
        'office': 0.6,          # Work-related health needs
        'corporate': 0.6,
        'school': 0.6,          # Children's health
        'college': 0.55,
        
        # MODERATE RELEVANCE
        'temple': 0.5,          # Elderly visitors
        'church': 0.5,
        'mosque': 0.5,
        'metro': 0.5,
        'metro_station': 0.5,
        'bus_stop': 0.5,
        'bus': 0.5,
        'park': 0.45,
        'salon': 0.4,
        
        # LOW RELEVANCE
        'bar': 0.2,
        'pub': 0.2,
        'nightclub': 0.15,
        'cinema': 0.3,
        'library': 0.35,
        'industrial': 0.3,
        'warehouse': 0.25,
        'cemetery': 0.2,
    },
    
    # =========================================================================
    # SALON / SPA
    # Target: Women 25-55, self-care enthusiasts, wedding parties
    # Peak: Weekends, pre-events, lunch breaks
    # =========================================================================
    'salon': {
        # HIGH RELEVANCE
        'residential': 1.0,     # Local regular clients
        'apartment': 1.0,
        'mall': 0.95,           # Shopping + grooming
        'shopping': 0.95,
        'spa': 0.9,             # Wellness seekers
        'gym': 0.85,            # Self-care demographic
        'hotel': 0.85,          # Tourists, events, weddings
        'banquet': 0.9,         # Wedding/event prep
        'wedding_hall': 0.95,
        
        # MODERATE-HIGH RELEVANCE
        'office': 0.75,         # Professional grooming
        'corporate': 0.75,
        'cinema': 0.65,         # Pre-event grooming
        'theatre': 0.65,
        'restaurant': 0.6,      # Date prep, events
        'cafe': 0.55,
        'boutique': 0.8,        # Fashion-conscious
        'clothing': 0.75,
        
        # MODERATE RELEVANCE
        'college': 0.55,        # Young adults
        'university': 0.55,
        'pharmacy': 0.5,        # Beauty products
        'metro': 0.5,
        'metro_station': 0.5,
        'temple': 0.5,          # Pre-religious events
        'church': 0.5,
        'mosque': 0.5,
        
        # LOW RELEVANCE
        'hospital': 0.35,
        'clinic': 0.4,
        'school': 0.35,
        'bar': 0.4,
        'pub': 0.4,
        'industrial': 0.2,
        'warehouse': 0.15,
        'cemetery': 0.1,
        'library': 0.3,
    },
    
    # =========================================================================
    # ELECTRONICS STORE
    # Target: Tech enthusiasts, students, professionals, gamers
    # Peak: Weekends, product launches, back-to-school
    # =========================================================================
    'electronics': {
        # HIGH RELEVANCE
        'office': 1.0,          # Business tech needs
        'corporate': 1.0,
        'college': 0.95,        # Students buying laptops, gadgets
        'university': 0.95,
        'coworking': 0.9,       # Freelancer tech needs
        'mall': 0.9,            # Tech sections in malls
        'shopping': 0.85,
        
        # MODERATE-HIGH RELEVANCE
        'residential': 0.75,    # Home electronics
        'apartment': 0.75,
        'gaming_center': 0.85,  # Gaming peripherals
        'internet_cafe': 0.8,
        'library': 0.65,        # Academic tech needs
        'metro': 0.6,           # Commuter convenience
        'metro_station': 0.6,
        'bank': 0.6,            # Financial district
        
        # MODERATE RELEVANCE
        'school': 0.55,         # Educational tech
        'cinema': 0.5,
        'cafe': 0.5,            # Tech meetups
        'restaurant': 0.45,
        'hotel': 0.5,
        'gym': 0.4,             # Fitness trackers
        
        # LOW RELEVANCE
        'hospital': 0.35,
        'clinic': 0.3,
        'temple': 0.25,
        'church': 0.25,
        'mosque': 0.25,
        'bar': 0.3,
        'pub': 0.3,
        'salon': 0.3,
        'park': 0.35,
        'cemetery': 0.1,
        'industrial': 0.4,
    },
    
    # =========================================================================
    # CLOTHING / FASHION
    # Target: Fashion-conscious, all ages, families, young adults
    # Peak: Weekends, festivals, season changes
    # =========================================================================
    'clothing': {
        # HIGH RELEVANCE
        'mall': 1.0,            # Fashion destination
        'shopping': 1.0,
        'residential': 0.9,     # Local shoppers
        'apartment': 0.9,
        'boutique': 0.95,       # Fashion district
        'salon': 0.85,          # Style-conscious overlap
        'spa': 0.8,
        
        # MODERATE-HIGH RELEVANCE
        'office': 0.75,         # Professional attire
        'corporate': 0.75,
        'college': 0.8,         # Fashion-forward youth
        'university': 0.8,
        'metro': 0.7,           # High foot traffic
        'metro_station': 0.7,
        'bus_stop': 0.65,
        'bus': 0.65,
        'cinema': 0.65,         # Social outings
        'restaurant': 0.6,
        'cafe': 0.55,
        'hotel': 0.65,          # Tourist shopping
        
        # MODERATE RELEVANCE
        'gym': 0.5,             # Athleisure wear
        'park': 0.5,
        'temple': 0.5,          # Festival/occasion wear
        'church': 0.5,
        'mosque': 0.5,
        'school': 0.5,          # School uniforms, kids wear
        'bank': 0.5,
        
        # LOW RELEVANCE
        'hospital': 0.3,
        'clinic': 0.3,
        'pharmacy': 0.25,
        'bar': 0.4,
        'pub': 0.4,
        'library': 0.35,
        'industrial': 0.2,
        'warehouse': 0.25,
        'cemetery': 0.1,
    },
    
    # =========================================================================
    # BOOKSTORE / STATIONERY
    # Target: Students, academics, parents, book lovers
    # Peak: Back-to-school, exam seasons, weekends
    # =========================================================================
    'bookstore': {
        # HIGH RELEVANCE
        'school': 1.0,          # Students, parents
        'college': 1.0,         # Academic books, stationery
        'university': 1.0,
        'library': 0.95,        # Book lovers, researchers
        'coworking': 0.85,      # Professional development
        'coaching': 0.9,        # Exam prep materials
        'tuition': 0.9,
        
        # MODERATE-HIGH RELEVANCE
        'office': 0.7,          # Office supplies, professional books
        'corporate': 0.7,
        'residential': 0.75,    # Family reading, kids books
        'apartment': 0.75,
        'cafe': 0.7,            # Reading + coffee culture
        'museum': 0.65,         # Cultural/intellectual crowd
        'art_gallery': 0.6,
        
        # MODERATE RELEVANCE
        'mall': 0.55,           # Bookstore chains in malls
        'shopping': 0.55,
        'metro': 0.5,           # Commuter reading
        'metro_station': 0.5,
        'bus_stop': 0.45,
        'bus': 0.45,
        'railway': 0.5,
        'railway_station': 0.5,
        'temple': 0.45,         # Religious texts
        'church': 0.45,
        'mosque': 0.45,
        'park': 0.5,
        
        # LOW RELEVANCE
        'bar': 0.15,            # Different demographic
        'pub': 0.15,
        'nightclub': 0.1,
        'gym': 0.25,
        'salon': 0.3,
        'hospital': 0.35,
        'cinema': 0.4,
        'industrial': 0.2,
        'cemetery': 0.1,
    },
    
    # =========================================================================
    # OTHER (Custom/Generic Business)
    # Target: Broad demographic, balanced scoring
    # =========================================================================
    'other': {
        # Balanced moderate-high for commercial areas
        'mall': 0.8,
        'shopping': 0.8,
        'residential': 0.8,
        'apartment': 0.8,
        'office': 0.75,
        'corporate': 0.75,
        'metro': 0.7,
        'metro_station': 0.7,
        'bus_stop': 0.65,
        'bus': 0.65,
        'railway': 0.65,
        'railway_station': 0.65,
        
        # Moderate for mixed-use
        'college': 0.6,
        'university': 0.6,
        'school': 0.5,
        'hospital': 0.5,
        'clinic': 0.5,
        'bank': 0.6,
        'park': 0.5,
        'temple': 0.45,
        'church': 0.45,
        'mosque': 0.45,
        'hotel': 0.6,
        'restaurant': 0.55,
        'cafe': 0.55,
        'gym': 0.5,
        'salon': 0.5,
        'pharmacy': 0.5,
        'cinema': 0.55,
        'library': 0.5,
        
        # Lower for specialized
        'bar': 0.4,
        'pub': 0.4,
        'nightclub': 0.35,
        'industrial': 0.35,
        'warehouse': 0.3,
        'cemetery': 0.2,
    },
}

# Default relevance score for unknown landmark types
DEFAULT_RELEVANCE = 0.5

# Category normalization map (handles variations in category names)
CATEGORY_NORMALIZATION = {
    # Transport
    'metro station': 'metro_station',
    'metro': 'metro',
    'subway': 'metro',
    'underground': 'metro',
    'bus stop': 'bus_stop',
    'bus station': 'bus_stop',
    'bus': 'bus',
    'railway station': 'railway_station',
    'train station': 'railway_station',
    'railway': 'railway',
    'train': 'railway',
    
    # Education
    'school': 'school',
    'primary school': 'school',
    'high school': 'school',
    'college': 'college',
    'university': 'university',
    'institute': 'college',
    'coaching': 'coaching',
    'tuition': 'tuition',
    'library': 'library',
    
    # Healthcare
    'hospital': 'hospital',
    'clinic': 'clinic',
    'medical': 'clinic',
    'doctor': 'doctor',
    'dental': 'dental',
    'pharmacy': 'pharmacy',
    'chemist': 'pharmacy',
    
    # Commercial
    'office': 'office',
    'corporate': 'corporate',
    'coworking': 'coworking',
    'bank': 'bank',
    'atm': 'atm',
    'mall': 'mall',
    'shopping': 'shopping',
    'market': 'market',
    'supermarket': 'supermarket',
    
    # Residential
    'residential': 'residential',
    'apartment': 'apartment',
    'housing': 'residential',
    
    # Religious
    'temple': 'temple',
    'church': 'church',
    'mosque': 'mosque',
    'gurudwara': 'temple',
    'synagogue': 'temple',
    
    # Entertainment
    'cinema': 'cinema',
    'movie': 'cinema',
    'theatre': 'theatre',
    'theater': 'theatre',
    'park': 'park',
    'garden': 'park',
    'playground': 'park',
    'museum': 'museum',
    'art gallery': 'art_gallery',
    
    # Food & Beverage
    'restaurant': 'restaurant',
    'cafe': 'cafe',
    'coffee': 'cafe',
    'bar': 'bar',
    'pub': 'pub',
    'nightclub': 'nightclub',
    
    # Services
    'salon': 'salon',
    'spa': 'spa',
    'gym': 'gym',
    'fitness': 'gym',
    'hotel': 'hotel',
    
    # Industrial
    'industrial': 'industrial',
    'factory': 'industrial',
    'warehouse': 'warehouse',
    
    # Default
    'nearby': 'default',
    'other': 'default',
}


def normalize_category(category: str) -> str:
    """
    Normalize a landmark category to match the relevance matrix keys.
    
    Args:
        category: Raw category string from landmark data
        
    Returns:
        Normalized category key
    """
    if not category:
        return 'default'
    
    # Convert to lowercase and strip whitespace
    normalized = category.lower().strip().replace('_', ' ')
    
    # Check exact match first
    if normalized in CATEGORY_NORMALIZATION:
        return CATEGORY_NORMALIZATION[normalized]
    
    # Check if any key is contained in the category
    for key, value in CATEGORY_NORMALIZATION.items():
        if key in normalized or normalized in key:
            return value
    
    # Return as-is (with underscores) if no match found
    return normalized.replace(' ', '_')


def get_relevance_score(business_type: str, landmark_category: str) -> float:
    """
    Get the relevance score for a landmark category given a business type.
    
    Args:
        business_type: The selected business type (cafe, restaurant, etc.)
        landmark_category: The category of the landmark
        
    Returns:
        Relevance score between 0.1 and 1.0
    """
    # Normalize inputs
    business_type = business_type.lower().strip() if business_type else 'other'
    normalized_category = normalize_category(landmark_category)
    
    # Get the relevance matrix for this business type
    business_matrix = RELEVANCE_MATRIX.get(business_type, RELEVANCE_MATRIX['other'])
    
    # Get the relevance score
    score = business_matrix.get(normalized_category, DEFAULT_RELEVANCE)
    
    return score


def get_marker_style(business_type: str, landmark_category: str) -> dict:
    """
    Calculate marker style based on relevance score.
    
    Args:
        business_type: The selected business type
        landmark_category: The category of the landmark
        
    Returns:
        Dict with opacity, scale, and zIndex values
    """
    relevance = get_relevance_score(business_type, landmark_category)
    
    # Calculate style parameters
    # Opacity: Linear mapping from relevance (0.1 -> 0.3, 1.0 -> 1.0)
    opacity = 0.3 + (relevance * 0.7)
    
    # Scale: Higher relevance = larger markers (0.6 to 1.2)
    scale = 0.6 + (relevance * 0.6)
    
    # Z-Index: Higher relevance = higher z-index (100 to 1000)
    z_index = int(100 + (relevance * 900))
    
    return {
        'relevance': relevance,
        'opacity': round(opacity, 2),
        'scale': round(scale, 2),
        'zIndex': z_index,
        'isHighRelevance': relevance >= 0.7,
        'isMediumRelevance': 0.4 <= relevance < 0.7,
        'isLowRelevance': relevance < 0.4,
    }


def enrich_landmarks_with_relevance(landmarks: list, business_type: str) -> list:
    """
    Add relevance data to a list of landmarks.
    
    Args:
        landmarks: List of landmark dictionaries
        business_type: The selected business type
        
    Returns:
        Enriched landmarks with relevance styling data
    """
    enriched = []
    for landmark in landmarks:
        category = landmark.get('category', landmark.get('type', 'default'))
        style = get_marker_style(business_type, category)
        
        enriched_landmark = {
            **landmark,
            'relevance_style': style
        }
        enriched.append(enriched_landmark)
    
    # Sort by relevance (high relevance first for proper rendering order)
    enriched.sort(key=lambda x: x['relevance_style']['relevance'], reverse=True)
    
    return enriched
</file>

<file path="backend/utils/__init__.py">
"""
Hotspot IQ - Utils Package
"""

from .score_calculator import (
    calculate_footfall_proxy,
    calculate_landmark_value,
    calculate_competitor_density,
    calculate_opportunity_score,
    get_score_interpretation,
    analyze_location
)

__all__ = [
    'calculate_footfall_proxy',
    'calculate_landmark_value',
    'calculate_competitor_density',
    'calculate_opportunity_score',
    'get_score_interpretation',
    'analyze_location'
]
</file>

<file path="DESIGN.md">
#  Hotspot IQ  Design Specification Document

> **Version:** 1.0  
> **Last Updated:** November 29, 2025  
> **Status:** Source of Truth for Frontend Development

---

## Table of Contents

1. [Visual Identity & Philosophy](#1-visual-identity--philosophy)
2. [The Color System](#2-the-color-system)
3. [Component Architecture](#3-component-architecture)
4. [Data Visualization Guidelines](#4-data-visualization-guidelines)
5. [Typography & Motion](#5-typography--motion)
6. [Spacing & Grid System](#6-spacing--grid-system)
7. [Responsive Behavior](#7-responsive-behavior)
8. [Accessibility Guidelines](#8-accessibility-guidelines)

---

## 1. Visual Identity & Philosophy

### 1.1 The Aesthetic: "Cyber-Enterprise"

Hotspot IQ embodies a **"Cyber-Enterprise"** aestheticthe sophisticated credibility of enterprise SaaS fused with the electric energy of cyberpunk interfaces. Think: *What if Mapbox Studio was redesigned by the UI team from Cyberpunk 2077?*

**Visual Anchors:**
| Inspiration | What We Take From It |
|-------------|---------------------|
| **Mapbox Studio** | Map-first layouts, floating control panels, dark canvas |
| **Vercel Dashboard** | Clean typography, subtle gradients, professional spacing |
| **Cyberpunk 2077** | Neon accents, scan-line effects, data-dense HUDs |
| **Bloomberg Terminal** | Information density, real-time updates, serious tone |

### 1.2 The Three Design Pillars

####  Pillar 1: "Dark Mode as Default"

The interface is **permanently dark**. There is no light mode toggledarkness is the product identity.

**Rationale:**
- Maps are the hero. Dark backgrounds make colorful map data pop.
- Reduces eye strain during extended analysis sessions.
- Conveys technical sophistication and premium positioning.
- Neon data points create instant visual hierarchy.

**Implementation:**
- The deepest background (`Canvas`) should feel like looking into space.
- All panels float above this void, creating depth through layering.
- Light elements (text, icons, data points) feel like they're *emitting* light, not reflecting it.

---

####  Pillar 2: "Glassmorphism  The Map Never Hides"

All UI panels use **glassmorphism**translucent surfaces with backdrop blur that allow the map to remain visible at all times.

**Rationale:**
- The map IS the product. Covering it with opaque panels defeats the purpose.
- Users maintain spatial context while reading data.
- Creates a sense of floating, futuristic HUD overlays.
- Reinforces the "intelligence layer on top of geography" metaphor.

**Implementation Rules:**
```

  GLASSMORPHISM RECIPE                                       

  Background:    rgba(15, 23, 42, 0.80)  /* Slate-900 @ 80% */
  Backdrop Blur: blur(12px)                                  
  Border:        1px solid rgba(255, 255, 255, 0.08)         
  Border Radius: 16px (panels) / 12px (cards) / 8px (inputs)
  Shadow:        0 8px 32px rgba(0, 0, 0, 0.4)              

```

**The Opacity Hierarchy:**
| Layer | Opacity | Use Case |
|-------|---------|----------|
| **Primary Panels** | 80% | Sidebar, Main Dashboard |
| **Secondary Cards** | 70% | Score cards, Stat blocks |
| **Tertiary Overlays** | 60% | Tooltips, Dropdowns |
| **Ghost Elements** | 40% | Disabled states, Placeholders |

---

####  Pillar 3: "Reactive  The Interface Breathes"

The UI is **reactive**it responds instantly to user input without waiting for explicit submissions.

**Rationale:**
- Location intelligence is exploratory. Users want to "play" with the map.
- Immediate feedback creates a sense of power and control.
- Reduces friction between thought and action.
- Makes the product feel alive and intelligent.

**Implementation Rules:**

| Interaction | Expected Behavior |
|-------------|-------------------|
| **Typing in Search** | Autocomplete appears after 2 characters, updates on every keystroke (debounced 300ms) |
| **Selecting Location** | Map flies to location, marker appears, analysis begins automatically |
| **Changing Filters** | Dashboard recalculates immediately, cards animate to new values |
| **Hovering Map Pins** | Tooltip fades in (150ms), pin scales up (1.2x) |
| **Adjusting Isochrone** | Polygon redraws in real-time as slider moves |

**The "No Submit Button" Rule:**
Wherever possible, eliminate explicit "Submit" or "Go" buttons. The interface should:
1. Detect user intent from input
2. Begin processing immediately
3. Show loading state inline
4. Resolve with animated result

*Exception: The main "Analyze Location" action retains a button for deliberate, high-stakes actions.*

---

## 2. The Color System

### 2.1 Philosophy: Semantic, Not Decorative

Colors in Hotspot IQ are **functional signals**, not aesthetic choices. Every color communicates meaning.

```

  "If a color doesn't mean something, it shouldn't exist."  

```

### 2.2 The Semantic Palette

####  CANVAS  The Void (Background Layer)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--canvas-deep` | `#020617` | `slate-950` | `rgb(2, 6, 23)` |
| `--canvas-base` | `#0f172a` | `slate-900` | `rgb(15, 23, 42)` |

**When to Use:**
- `canvas-deep`: The absolute background. The map container. The void behind everything.
- `canvas-base`: Secondary backgrounds, input fields, code blocks.

**Never Use For:** Text, icons, or anything that needs to be "seen."

---

####  SURFACE  The Glass Layers

| Token | Hex + Opacity | Tailwind | Usage |
|-------|---------------|----------|-------|
| `--surface-primary` | `#0f172a` @ 80% | `slate-900/80` | Main panels (Sidebar, Dashboard) |
| `--surface-secondary` | `#1e293b` @ 70% | `slate-800/70` | Cards within panels |
| `--surface-elevated` | `#334155` @ 60% | `slate-700/60` | Hover states, Active items |
| `--surface-border` | `#ffffff` @ 8% | `white/8` | All panel/card borders |

**When to Use:**
- Wrap all floating UI in `surface-primary`.
- Nest cards inside panels using `surface-secondary`.
- Use `surface-elevated` for interactive hover/focus states.

**The Golden Rule:** Surfaces are always semi-transparent. If you're reaching for an opaque color, you're doing it wrong.

---

####  PRIMARY  The Neon Emerald (Action & Success)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--primary-glow` | `#10b981` | `emerald-500` | `rgb(16, 185, 129)` |
| `--primary-bright` | `#34d399` | `emerald-400` | `rgb(52, 211, 153)` |
| `--primary-soft` | `#10b981` @ 20% | `emerald-500/20` | Backgrounds, Fills |
| `--primary-pulse` | `#10b981` @ 50% | `emerald-500/50` | Glows, Shadows |

**When to Use:**
- **Primary CTA buttons:** "Analyze Location", "Get Insights"
- **Positive scores:** Opportunity Score  70
- **Success states:** "Location Added", "Analysis Complete"
- **Active navigation:** Selected menu items
- **Data highlights:** Important numbers, charts ascending

**Glow Effect Recipe:**
```css
.primary-glow {
  box-shadow: 
    0 0 20px rgba(16, 185, 129, 0.4),
    0 0 40px rgba(16, 185, 129, 0.2),
    0 0 60px rgba(16, 185, 129, 0.1);
}
```

---

####  WARNING  The Amber Signal (Caution)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--warning-glow` | `#f59e0b` | `amber-500` | `rgb(245, 158, 11)` |
| `--warning-soft` | `#f59e0b` @ 20% | `amber-500/20` | Backgrounds |

**When to Use:**
- **Medium scores:** Opportunity Score 40-69
- **Caution alerts:** "Moderate competition detected"
- **Pending states:** "Calculating...", "Loading data"
- **Attention flags:** Items that need review

---

####  DESTRUCTIVE  The Neon Rose (Danger & Errors)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--destructive-glow` | `#f43f5e` | `rose-500` | `rgb(244, 63, 94)` |
| `--destructive-bright` | `#fb7185` | `rose-400` | `rgb(251, 113, 133)` |
| `--destructive-soft` | `#f43f5e` @ 20% | `rose-500/20` | Backgrounds |

**When to Use:**
- **Low scores:** Opportunity Score < 40
- **Saturation warnings:** "High competitor density!"
- **Error states:** API failures, Invalid inputs
- **Negative trends:** Charts descending, Bad metrics
- **Destructive actions:** "Remove location", "Clear all"

---

####  TEXT  The Light Spectrum

| Token | Hex | Tailwind | Opacity | Usage |
|-------|-----|----------|---------|-------|
| `--text-primary` | `#f8fafc` | `slate-50` | 100% | Headlines, Key data, CTAs |
| `--text-secondary` | `#cbd5e1` | `slate-300` | 85% | Body text, Descriptions |
| `--text-tertiary` | `#64748b` | `slate-500` | 60% | Metadata, Timestamps, Labels |
| `--text-disabled` | `#475569` | `slate-600` | 40% | Disabled inputs, Placeholders |

**Hierarchy Rules:**
1. Only ONE piece of information per screen should use `text-primary` (usually the score or key metric).
2. Supporting information uses `text-secondary`.
3. Metadata (dates, IDs, labels) uses `text-tertiary`.
4. Never use pure white (`#ffffff`)it's too harsh on dark backgrounds.

---

####  ACCENT  The Cyan Highlight (Information)

| Token | Hex | Tailwind | Usage |
|-------|-----|----------|-------|
| `--accent-cyan` | `#06b6d4` | `cyan-500` | Links, Info icons, Neutral highlights |
| `--accent-violet` | `#8b5cf6` | `violet-500` | AI/Chat features, Special badges |

**When to Use:**
- `accent-cyan`: Hyperlinks, informational tooltips, neutral data points.
- `accent-violet`: AI-generated content, "Ask Hotspot" chat, premium features.

---

### 2.3 Color Application Matrix

| Element | Background | Border | Text | Icon |
|---------|------------|--------|------|------|
| **Panel** | `surface-primary` | `surface-border` |  |  |
| **Card** | `surface-secondary` | `surface-border` |  |  |
| **Primary Button** | `primary-glow` | `primary-bright` | `canvas-deep` | `canvas-deep` |
| **Ghost Button** | `transparent` | `surface-border` | `text-secondary` | `text-tertiary` |
| **Input Field** | `canvas-base` | `surface-border` | `text-primary` | `text-tertiary` |
| **Input Focused** | `canvas-base` | `primary-glow` | `text-primary` | `primary-glow` |
| **Score High** | `primary-soft` | `primary-glow` | `primary-bright` |  |
| **Score Medium** | `warning-soft` | `warning-glow` | `warning-glow` |  |
| **Score Low** | `destructive-soft` | `destructive-glow` | `destructive-bright` |  |

---

## 3. Component Architecture

### 3.1 The Layered Interface Model

Hotspot IQ uses a **Z-axis layered architecture**. Think of the interface as stacked transparent sheets of glass:

```

  Z-INDEX STACK (Bottom to Top)                              

                                                             
  z-50    MODAL LAYER (Dialogs, Alerts)          
                                                  
                                                             
  z-40    CHAT WIDGET (Floating FAB)             
                                                  
                                                             
  z-30                   
              DATA HUD (Score Cards)                       
                         
                                                             
  z-20                                             
        CONTROL  CONTROL DECK (Sidebar)                   
         DECK                                             
                                                   
                                                             
  z-10   
                      MAP OVERLAYS                         
            (Markers, Isochrones, Heatmaps)               
         
                                                             
  z-0    
                                                          
                      THE MAP CANVAS                      
                   (100% width  100% height)             
                                                          
         
                                                             

```

---

### 3.2 The Map Canvas (`z-0`)

**Role:** The foundational layer. The reason users come to Hotspot IQ.

**Specifications:**
| Property | Value | Rationale |
|----------|-------|-----------|
| **Position** | `fixed`, `inset-0` | Covers entire viewport |
| **Dimensions** | `100vw  100vh` | Edge to edge |
| **Tile Style** | Dark/Monochrome | Reduces visual noise |
| **Default Center** | `12.9716, 77.5946` (Bangalore) | Indian market focus |
| **Default Zoom** | `13` | Neighborhood level |
| **Interaction** | Pan, Zoom, Click-to-select | Always interactive |

**Map Style Guidelines:**
- Use a **dark basemap** (Mapbox Dark, CartoDB Dark Matter, or custom).
- Desaturate colors so data overlays pop.
- Road labels should be `text-tertiary` color.
- Water bodies should be `canvas-deep` (near black).
- Parks/green spaces should be a muted dark teal.

**The Map is Never Blocked:**
- No panel should exceed 400px width.
- No panel should exceed 70% viewport height.
- Users must always be able to see at least 50% of the map.

---

### 3.3 The Control Deck (`z-20`)  Left Sidebar

**Role:** The command center. Where users input their intent.

**Position:** Fixed left, vertically centered.

```

  CONTROL DECK ANATOMY                  

                                        
    
     HOTSPOT IQ                        Logo/Brand
       Location Intelligence          
    
                                        
    
    STEP 1: What are you opening?       Section Label
        
      Cafe / Coffee Shop            Business Type Dropdown
        
    
                                        
    
    STEP 2: What do you need nearby?     Section Label
          
     Metro  School  College       Filter Chips
              (Multi-select)
          
     Hosp  Mall   Office    
          
          
     ATM   Bar    Temple    
          
    
                                        
    
    STEP 3: Where do you want to open?    Section Label
     Search Location...                Autocomplete Input
        
     Indiranagar, Bangalore            Suggestion Item
     Indira Nagar Metro Station     
     Indirapuram, Ghaziabad         
        
    
                                        
    
     ANALYZE LOCATION                   Primary CTA (Glowing)
    
                                        
    
     Digipin: J7Q4-M2X9               Location ID (Copyable)
    
                                        

```

**Specifications:**
| Property | Value |
|----------|-------|
| **Width** | `360px` (desktop), `100%` (mobile drawer) |
| **Height** | Auto, max `calc(100vh - 48px)` |
| **Position** | `fixed`, `left: 24px`, `top: 50%`, `transform: translateY(-50%)` |
| **Background** | `surface-primary` (glassmorphism) |
| **Border Radius** | `16px` |
| **Padding** | `24px` |
| **Gap** | `16px` between sections |

**Interaction States:**
- Panel can be collapsed to icon-only mode (hamburger toggle).
- On mobile, becomes a bottom drawer (swipe up to expand).

---

### 3.3.1 User Input Components (Control Deck Details)

The Control Deck follows a **strict sequential flow**. Users must complete each step before proceeding.

#### Component A: Business Type Selector

**Purpose:** Determines what category of business the user is opening. This selection defines which POIs are treated as **competitors**.

```

  BUSINESS TYPE DROPDOWN                                     

                                                             
  CLOSED STATE:                                              
     
     What are you opening?                              
          
       Cafe / Coffee Shop                           
          
     
                                                             
  OPEN STATE (Dropdown Expanded):                           
     
       Cafe / Coffee Shop                  Selected 
       Restaurant / Fast Food                        
       Retail Store                                  
       Gym / Fitness Center                          
       Pharmacy / Medical                            
       Salon / Spa                                   
       Electronics Store                             
       Clothing / Fashion                            
       Bookstore / Stationery                        
       Other (Custom)...                             
     
                                                             

```

**Specifications:**
| Property | Value |
|----------|-------|
| **Height** | `48px` (closed), auto (open) |
| **Background** | `canvas-base` |
| **Border** | `1px solid surface-border` |
| **Border (Focus)** | `1px solid primary-glow` + glow shadow |
| **Border Radius** | `8px` |
| **Icon Size** | `20px` (emoji/icon) |
| **Font** | `text-body`, `text-primary` |
| **Dropdown Shadow** | `0 8px 24px rgba(0,0,0,0.4)` |

**States:**
| State | Visual Treatment |
|-------|------------------|
| **Empty/Placeholder** | "Select business type..." in `text-tertiary` |
| **Hover** | Background lightens to `surface-secondary` |
| **Open** | Border glows `primary-glow`, dropdown appears |
| **Selected** | Shows icon + business name, checkmark in dropdown |
| **Error** | Red border, "Please select a business type" below |

**Competitor Mapping (Data Logic):**
```
Business Type           Competitor POI Categories

 Cafe / Coffee Shop   cafe, coffee_shop, bakery, tea_house
 Restaurant          restaurant, fast_food, food_court, dhaba
 Retail Store         supermarket, convenience_store, grocery
 Gym / Fitness        gym, fitness_center, yoga_studio, sports_club
 Pharmacy             pharmacy, medical_store, clinic
 Salon / Spa          salon, spa, beauty_parlor, barbershop
 Electronics          electronics_store, mobile_shop, computer_store
 Clothing             clothing_store, boutique, fashion_store
 Bookstore            bookstore, stationery_shop, library
 Other                User enters custom POI category
```

---

#### Component B: Proximity Preference Filters

**Purpose:** User selects what landmarks/amenities they want **nearby**. These add bonus points to the Opportunity Score and filter the map display.

```

  PROXIMITY FILTER CHIPS                                     

                                                             
  Section Label: "What do you want nearby?" (text-secondary) 
                                                             
  CHIP GRID (3 columns, wrapping):                          
     
            
      Metro       School      College        
       [Active]     [Inactive]    [Active]         
            
                                                          
            
      Hospital    Mall        Office         
      [Inactive]    [Inactive]    [Active]         
            
                                                          
            
      Resident    Temple      Park           
      [Inactive]    [Inactive]    [Inactive]       
            
                                                          
            
      ATM/Bank    Bar/Pub     Bus Stop       
      [Inactive]    [Inactive]    [Inactive]       
            
                                                          
             
      Select Popular     Clear All               
             
     
                                                             

```

**Available Filter Options:**
| Filter | Icon | POI Category | Score Bonus |
|--------|------|--------------|-------------|
| Metro Station |  | `metro_station` | +15 |
| Bus Stop |  | `bus_stop` | +5 |
| School |  | `school` | +10 |
| College/University |  | `college`, `university` | +12 |
| Hospital |  | `hospital`, `clinic` | +8 |
| Mall/Shopping |  | `mall`, `shopping_center` | +15 |
| Office/IT Park |  | `office`, `it_park`, `business_center` | +12 |
| Residential Area |  | `residential`, `apartment_complex` | +8 |
| Temple/Religious |  | `temple`, `mosque`, `church`, `gurudwara` | +6 |
| Park/Recreation |  | `park`, `playground`, `garden` | +5 |
| ATM/Bank |  | `atm`, `bank` | +4 |
| Bar/Pub |  | `bar`, `pub`, `nightclub` | +7 |

**Chip Specifications:**
| Property | Inactive State | Active State |
|----------|----------------|--------------|
| **Background** | `transparent` | `primary-soft` |
| **Border** | `1px solid surface-border` | `1px solid primary-glow` |
| **Text Color** | `text-tertiary` | `text-primary` |
| **Icon Opacity** | 60% | 100% |
| **Shadow** | None | `0 0 12px primary-pulse` |
| **Padding** | `8px 12px` | `8px 12px` |
| **Border Radius** | `20px` (pill shape) | `20px` |
| **Transition** | `all 200ms ease-out` |  |

**Interaction:**
- Click to toggle (multi-select allowed)
- Active chips glow with neon green
- "Select Popular" pre-selects: Metro, College, Office, Mall
- "Clear All" deselects all chips

---

#### Component C: Location Search (Autocomplete)

Appears **after** Business Type and Filters. See main Search specification above.

---

#### Input Flow Validation

The Control Deck enforces a **progressive disclosure** pattern:

```

  VALIDATION STATES                                          

                                                             
  STATE 1: Initial (Nothing Selected)                       
     
    Step 1: Business Type    [ Select...  ]            
    Step 2: Nearby Filters   [  Disabled/Dimmed  ]        
    Step 3: Search Location  [  Disabled/Dimmed  ]        
    [ ANALYZE LOCATION ]     [  Disabled/Grey   ]         
     
                                                             
  STATE 2: Business Type Selected                           
     
    Step 1: Business Type    [  Cafe     ]            
    Step 2: Nearby Filters   [  Now Active!    ]        
    Step 3: Search Location  [  Disabled/Dimmed  ]        
    [ ANALYZE LOCATION ]     [  Disabled/Grey   ]         
     
                                                             
  STATE 3: Filters Selected (Optional)                      
     
    Step 1: Business Type    [  Cafe     ]            
    Step 2: Nearby Filters   [    selected ]      
    Step 3: Search Location  [  Now Active!    ]        
    [ ANALYZE LOCATION ]     [  Disabled/Grey   ]         
     
                                                             
  STATE 4: Location Selected (Ready!)                       
     
    Step 1: Business Type    [  Cafe     ]            
    Step 2: Nearby Filters   [    selected ]      
    Step 3: Search Location  [ Indiranagar... ]         
    [  ANALYZE LOCATION ]   [  GLOWING GREEN  ]       
     
                                                             

```

**Note:** Step 2 (Filters) is technically **optional**  users can skip to Step 3. However, the UI encourages selection by highlighting the section.

---

### 3.4 The Data HUD (`z-30`)  Dashboard Cards

**Role:** Display analysis results. The "payoff" after searching.

**Position:** Fixed right side, stacked vertically or in a grid.

```

  DATA HUD LAYOUT                                            

                                                             
                              
                                OPPORTUNITY SCORE          
                                                    
                                        78               
                                                    
                                    Prime Location       
                              
                                                             
                                    
                              COMPETITORS LANDMARKS      
                                  12          8          
                                nearby      nearby       
                                    
                                                             
                              
                                FOOTFALL ANALYSIS          
                                  HIGH     
                                Peak: 6-9 PM weekdays      
                              
                                                             
                              
                                 GROWTH RADAR            
                                "New Metro line by 2026"   
                                Impact: +15% footfall      
                              
                                                             

```

**Specifications:**
| Property | Value |
|----------|-------|
| **Width** | `320px` per card |
| **Position** | `fixed`, `right: 24px`, `top: 24px` |
| **Layout** | Vertical stack with `12px` gap |
| **Background** | `surface-secondary` (glassmorphism) |
| **Border Radius** | `12px` |
| **Padding** | `20px` |
| **Max Height** | Each card max `300px`, scrollable if overflow |

**Card States:**
| State | Visual Treatment |
|-------|------------------|
| **Loading** | Skeleton pulse animation, no content |
| **Empty** | Ghost icon + "Select a location" message |
| **Populated** | Full data display |
| **Error** | Red border, error icon, retry button |

**Animation on Appear:**
- Cards slide in from right (`translateX: 100px  0`).
- Staggered delay: Card 1 at `0ms`, Card 2 at `100ms`, Card 3 at `200ms`.
- Duration: `400ms`, Easing: `ease-out`.

---

### 3.5 The Chat Widget (`z-40`)  AI Assistant

**Role:** Natural language interface to Hotspot IQ's intelligence.

**Position:** Floating Action Button (FAB) in bottom-right corner.

```

  CHAT WIDGET STATES                                         

                                                             
  STATE 1: COLLAPSED (FAB Only)                             
                                                             
                                                   
                                                        
                                           Ask            
                                                   
                                                             
  STATE 2: EXPANDED (Chat Panel)                            
                                                             
                              
                                Ask Hotspot            
                              
                                                           
                                Hi! I'm your location   
                                  intelligence assistant.  
                                                           
                                Is this good for a gym? 
                                                           
                                Based on the data, this 
                                  location shows strong    
                                  potential. There are 3   
                                  offices within 1km...    
                                                           
                              
                               Type a question...        
                              
                                                             

```

**FAB Specifications:**
| Property | Value |
|----------|-------|
| **Size** | `56px  56px` |
| **Position** | `fixed`, `right: 24px`, `bottom: 24px` |
| **Background** | `accent-violet` (AI = Purple) |
| **Border Radius** | `50%` (circular) |
| **Shadow** | Violet glow effect |
| **Icon** | Chat bubble or sparkle  |

**Expanded Panel Specifications:**
| Property | Value |
|----------|-------|
| **Width** | `380px` |
| **Height** | `500px` max |
| **Position** | `fixed`, `right: 24px`, `bottom: 96px` |
| **Background** | `surface-primary` |
| **Border Radius** | `16px` |

**Message Bubbles:**
| Sender | Background | Alignment | Border Radius |
|--------|------------|-----------|---------------|
| **User** | `primary-soft` | Right | `12px 12px 4px 12px` |
| **AI** | `surface-elevated` | Left | `12px 12px 12px 4px` |

**Suggested Questions (Chips):**
Display above input when chat is empty:
- "Is this good for a [business_type]?"
- "What's the competition like here?"
- "Show me the best spots nearby"

---

## 4. Data Visualization Guidelines

### 4.1 The Opportunity Score Ring

**Purpose:** The hero metric. The single number users remember.

```

  SCORE RING ANATOMY                                         

                                                             
                                         
                                                 
                                    Progress Arc     
                                     (Colored by      
                                      score range)    
                           78         Score Number     
                         /100          (Large, Bold)    
                                                      
                               Background Track 
                                         (surface-border) 
                       PRIME          Status Label     
                       LOCATION                           
                                         
                                                             

```

**Visual Specifications:**
| Property | Value |
|----------|-------|
| **Diameter** | `160px` |
| **Stroke Width** | `12px` |
| **Track Color** | `surface-border` |
| **Progress Color** | Dynamic (see below) |
| **Score Font Size** | `48px` |
| **Score Font Weight** | `700` (Bold) |
| **Label Font Size** | `14px` |
| **Label Font Weight** | `600` (Semi-bold) |

**Color by Score Range:**
| Score | Arc Color | Label | Glow |
|-------|-----------|-------|------|
| **70-100** | `primary-glow` | "PRIME LOCATION" | Green glow |
| **40-69** | `warning-glow` | "MODERATE POTENTIAL" | Amber glow |
| **0-39** | `destructive-glow` | "HIGH RISK" | Red glow |

**Animation:**
- On load: Arc animates from 0% to final value.
- Duration: `1200ms`
- Easing: `ease-out`
- Number counts up from 0 to final score.

---

### 4.2 Isochrone Rendering

**Purpose:** Show "What can I reach in X minutes?" as a polygon overlay.

```

  ISOCHRONE VISUAL STYLE                                     

                                                             
                                        
                                                    
                                            
                                                 
                      YOU                              
                                                  
               (15-min bike radius)                      
                                                         
                                                         
                                                     
                                                   
                                                  
                                         
                                                             

```

**Polygon Specifications:**
| Property | Value |
|----------|-------|
| **Fill Color** | `primary-glow` @ 15% opacity |
| **Stroke Color** | `primary-glow` @ 80% opacity |
| **Stroke Width** | `2px` |
| **Stroke Style** | Solid (not dashed) |

**Multiple Isochrones (Time Comparison):**
When showing multiple time ranges (5, 10, 15 mins):

| Time | Fill Opacity | Stroke Opacity |
|------|--------------|----------------|
| **5 min** | 25% | 100% |
| **10 min** | 15% | 70% |
| **15 min** | 10% | 50% |

**Animation:**
- On draw: Polygon fades in (`opacity: 0  1`).
- Duration: `600ms`
- When changing time: Morphs smoothly to new shape (if library supports).

---

### 4.3 Map Markers & Pins

**Purpose:** Represent locations, competitors, landmarks on the map.

**Marker Types:**

| Type | Shape | Size | Color | Icon |
|------|-------|------|-------|------|
| **Selected Location** | Circle with pulse | `24px` | `primary-glow` | None (solid dot) |
| **Competitor** | Circle | `16px` | `destructive-glow` | Business icon |
| **Landmark (Positive)** | Circle | `14px` | `primary-soft` | Category icon |
| **Landmark (Neutral)** | Circle | `12px` | `text-tertiary` | Category icon |
| **Warehouse** | Square | `20px` | `accent-cyan` |  |

**Selected Location Marker:**
```

  PULSE ANIMATION                                            

                                                             
                                                 
                              Outer pulse ring           
                        (expanding, fading)        
                           Inner solid dot            
                                                   
                                                           
                                                 
                                                             

```

- Inner dot: `12px`, solid `primary-glow`.
- Outer ring: Expands from `12px` to `36px`, fades from 50% to 0% opacity.
- Animation: Infinite loop, `2s` duration.

---

### 4.4 Heatmap Overlay

**Purpose:** Show opportunity density across an area.

**Color Gradient:**
```
Low Opportunity                              High Opportunity
     
             
     
     destructive  warning  amber  primary  primary-bright
```

**Specifications:**
| Property | Value |
|----------|-------|
| **Opacity** | 40-60% (must see map beneath) |
| **Blur** | Soft edges, no hard boundaries |
| **Radius** | Based on data density |
| **Update** | Real-time as user pans |

---

### 4.5 Charts (Recharts)

**Bar Chart (Competitor Breakdown):**
| Property | Value |
|----------|-------|
| **Bar Color** | `destructive-glow` (competitors are threats) |
| **Background** | `transparent` |
| **Grid Lines** | `surface-border` @ 50% |
| **Axis Labels** | `text-tertiary` |
| **Bar Radius** | `4px` top corners |

**Radar Chart (Landmark Categories):**
| Property | Value |
|----------|-------|
| **Fill** | `primary-soft` |
| **Stroke** | `primary-glow` |
| **Grid** | `surface-border` |
| **Dots** | `primary-bright`, `6px` |

**Line Chart (Trends):**
| Property | Value |
|----------|-------|
| **Line Color** | `primary-glow` |
| **Line Width** | `2px` |
| **Area Fill** | Gradient from `primary-soft` to `transparent` |
| **Dots** | Show only on hover |

---

## 5. Typography & Motion

### 5.1 Font Stack

**Primary Font: Inter**
```css
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
```

**Monospace Font: JetBrains Mono** (for data, codes, Digipin)
```css
font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
```

### 5.2 Type Scale

| Token | Size | Weight | Line Height | Use Case |
|-------|------|--------|-------------|----------|
| `--text-hero` | `48px` | 700 | 1.1 | Opportunity Score number |
| `--text-h1` | `28px` | 700 | 1.2 | Panel titles |
| `--text-h2` | `20px` | 600 | 1.3 | Card headers |
| `--text-h3` | `16px` | 600 | 1.4 | Section labels |
| `--text-body` | `14px` | 400 | 1.5 | Default body text |
| `--text-small` | `12px` | 400 | 1.5 | Metadata, captions |
| `--text-micro` | `10px` | 500 | 1.4 | Badges, tags |

### 5.3 Font Weights

| Weight | Value | Usage |
|--------|-------|-------|
| **Regular** | 400 | Body text, descriptions |
| **Medium** | 500 | Labels, interactive elements |
| **Semi-bold** | 600 | Subheadings, emphasis |
| **Bold** | 700 | Headlines, scores, CTAs |

### 5.4 Motion System

**The Motion Philosophy:**
> "Movement should feel like data flowing through a systemswift, precise, purposeful."

**Timing Functions:**
| Token | Value | Use Case |
|-------|-------|----------|
| `--ease-out` | `cubic-bezier(0.0, 0.0, 0.2, 1)` | Elements entering (cards appearing) |
| `--ease-in` | `cubic-bezier(0.4, 0.0, 1, 1)` | Elements exiting (modals closing) |
| `--ease-in-out` | `cubic-bezier(0.4, 0.0, 0.2, 1)` | Elements transforming (toggles, sliders) |
| `--spring` | `cubic-bezier(0.34, 1.56, 0.64, 1)` | Playful interactions (FAB press) |

**Duration Scale:**
| Token | Value | Use Case |
|-------|-------|----------|
| `--duration-instant` | `100ms` | Hover states, focus rings |
| `--duration-fast` | `200ms` | Button clicks, toggles |
| `--duration-normal` | `300ms` | Card transitions, dropdowns |
| `--duration-slow` | `500ms` | Page transitions, large panels |
| `--duration-glacial` | `1000ms` | Score animations, charts drawing |

### 5.5 Micro-Interactions Catalog

| Interaction | Animation |
|-------------|-----------|
| **Button Hover** | Background lightens 10%, subtle glow appears (`200ms`) |
| **Button Press** | Scale down to `0.97`, shadow reduces (`100ms`) |
| **Card Appear** | Slide from right (`translateX: 20px  0`) + fade in (`400ms`) |
| **Card Hover** | Border color brightens, subtle lift (`translateY: -2px`) |
| **Input Focus** | Border color  `primary-glow`, glow shadow appears (`200ms`) |
| **Dropdown Open** | Scale from `0.95` to `1`, fade in (`200ms`) |
| **Score Count-Up** | Number counts from 0 to value (`1200ms`, ease-out) |
| **Progress Arc** | Draws from 0% to value (`1200ms`, ease-out) |
| **Marker Pulse** | Infinite expanding ring (`2s` loop) |
| **Chat Message** | Slide up from bottom + fade in (`300ms`) |
| **Toast Notification** | Slide in from right, auto-dismiss after `4s` |
| **Loading Skeleton** | Shimmer effect (gradient moving left to right, `1.5s` loop) |

---

## 6. Spacing & Grid System

### 6.1 Spacing Scale

Based on `4px` base unit:

| Token | Value | Use Case |
|-------|-------|----------|
| `--space-1` | `4px` | Tight gaps (icon + text) |
| `--space-2` | `8px` | Inline spacing |
| `--space-3` | `12px` | Card gaps, small padding |
| `--space-4` | `16px` | Default padding, section gaps |
| `--space-5` | `20px` | Card padding |
| `--space-6` | `24px` | Panel padding, large gaps |
| `--space-8` | `32px` | Section separation |
| `--space-10` | `40px` | Major section breaks |
| `--space-12` | `48px` | Page margins |

### 6.2 Component Spacing

| Component | Padding | Gap (between children) | Margin (from viewport) |
|-----------|---------|------------------------|------------------------|
| **Sidebar Panel** | `24px` | `16px` | `24px` from edges |
| **Dashboard Card** | `20px` | `12px` |  |
| **Input Field** | `12px 16px` |  |  |
| **Button** | `12px 24px` | `8px` (icon + text) |  |
| **Chip/Tag** | `6px 12px` |  | `8px` between chips |
| **Modal** | `32px` | `24px` | Centered |

---

## 7. Responsive Behavior

### 7.1 Breakpoints

| Token | Value | Description |
|-------|-------|-------------|
| `--breakpoint-sm` | `640px` | Mobile landscape |
| `--breakpoint-md` | `768px` | Tablets |
| `--breakpoint-lg` | `1024px` | Small laptops |
| `--breakpoint-xl` | `1280px` | Desktops |
| `--breakpoint-2xl` | `1536px` | Large monitors |

### 7.2 Layout Adaptation

| Viewport | Sidebar | Dashboard | Chat |
|----------|---------|-----------|------|
| **Desktop (1024px)** | Fixed left, always visible | Fixed right, always visible | FAB bottom-right |
| **Tablet (768-1023px)** | Collapsible, hamburger toggle | Below map, scrollable | FAB bottom-right |
| **Mobile (<768px)** | Bottom drawer (swipe up) | Full-screen modal on demand | FAB bottom-right |

### 7.3 Mobile Considerations

- **Touch targets:** Minimum `44px  44px` for all interactive elements.
- **Swipe gestures:** Sidebar opens with swipe-right, closes with swipe-left.
- **Map remains hero:** On mobile, map takes 60% of screen, panels overlay from bottom.
- **Simplified HUD:** On mobile, show only Score + 2 key metrics (not full dashboard).

---

## 8. Accessibility Guidelines

### 8.1 Color Contrast

All text must meet WCAG 2.1 AA standards:
- **Normal text:** Minimum `4.5:1` contrast ratio.
- **Large text (18px+):** Minimum `3:1` contrast ratio.

| Combination | Contrast Ratio | Pass? |
|-------------|----------------|-------|
| `text-primary` on `canvas-deep` | `17.4:1` |  AAA |
| `text-secondary` on `canvas-deep` | `9.7:1` |  AAA |
| `text-tertiary` on `canvas-deep` | `5.1:1` |  AA |
| `primary-glow` on `canvas-deep` | `6.2:1` |  AA |

### 8.2 Focus States

All interactive elements must have visible focus indicators:
```css
:focus-visible {
  outline: 2px solid var(--primary-glow);
  outline-offset: 2px;
}
```

### 8.3 Screen Reader Support

- All images have descriptive `alt` text.
- Icon-only buttons have `aria-label`.
- Score changes announced with `aria-live="polite"`.
- Map markers have accessible names.

### 8.4 Reduced Motion

Respect user preference:
```css
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}
```

---

##  Appendix: Quick Reference

### Color Tokens (Copy-Paste)
```css
:root {
  /* Canvas */
  --canvas-deep: #020617;
  --canvas-base: #0f172a;
  
  /* Surface */
  --surface-primary: rgba(15, 23, 42, 0.8);
  --surface-secondary: rgba(30, 41, 59, 0.7);
  --surface-elevated: rgba(51, 65, 85, 0.6);
  --surface-border: rgba(255, 255, 255, 0.08);
  
  /* Primary */
  --primary-glow: #10b981;
  --primary-bright: #34d399;
  --primary-soft: rgba(16, 185, 129, 0.2);
  
  /* Warning */
  --warning-glow: #f59e0b;
  --warning-soft: rgba(245, 158, 11, 0.2);
  
  /* Destructive */
  --destructive-glow: #f43f5e;
  --destructive-soft: rgba(244, 63, 94, 0.2);
  
  /* Text */
  --text-primary: #f8fafc;
  --text-secondary: #cbd5e1;
  --text-tertiary: #64748b;
  --text-disabled: #475569;
  
  /* Accent */
  --accent-cyan: #06b6d4;
  --accent-violet: #8b5cf6;
}
```

### Tailwind Mapping
```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        canvas: {
          deep: '#020617',
          base: '#0f172a',
        },
        surface: {
          primary: 'rgba(15, 23, 42, 0.8)',
          secondary: 'rgba(30, 41, 59, 0.7)',
        },
        // ... etc
      }
    }
  }
}
```

---

<div align="center">

** Design with purpose. Build with precision. Ship with confidence.**

*Hotspot IQ Design System v1.0*

</div>
</file>

<file path="frontend/.env.example">
# Frontend Environment Variables
VITE_API_BASE_URL=http://localhost:5000/api
</file>

<file path="frontend/.gitignore">
# Dependencies
node_modules/

# Build output
dist/
build/

# Environment
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Cache
.cache/
.eslintcache
</file>

<file path="frontend/package.json">
{
  "name": "hotspot-iq-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "leaflet": "^1.9.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-leaflet": "^4.2.1",
    "recharts": "^2.10.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "vite": "^5.0.8"
  }
}
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/public/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32">
  <defs>
    <linearGradient id="heatGrad" x1="0%" y1="100%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#F7B731"/>
      <stop offset="100%" style="stop-color:#EB5B3C"/>
    </linearGradient>
    <linearGradient id="pinGrad" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#1E3A5F"/>
      <stop offset="100%" style="stop-color:#0F2439"/>
    </linearGradient>
  </defs>
  
  <!-- Heatmap base -->
  <ellipse cx="16" cy="25" rx="14" ry="5" fill="#F7B731" opacity="0.9"/>
  <ellipse cx="16" cy="24" rx="10" ry="4" fill="#F5A623"/>
  <ellipse cx="16" cy="23" rx="6" ry="2.5" fill="#EB5B3C"/>
  
  <!-- Pin -->
  <path d="M16 3 C10.5 3 6 7.5 6 13 C6 18.5 16 26 16 26 C16 26 26 18.5 26 13 C26 7.5 21.5 3 16 3 Z" 
        fill="url(#pinGrad)"/>
  
  <!-- Inner circles -->
  <circle cx="16" cy="12" r="5" fill="white"/>
  <circle cx="16" cy="12" r="2.5" fill="#F5A623"/>
</svg>
</file>

<file path="frontend/public/icons/bank.svg">
<!-- Bank/ATM icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 16v4h56v-4L32 4zM8 24v28h8V24H8zm16 0v28h8V24h-8zm16 0v28h8V24h-8zm16 0v28h8V24h-8zM4 56v4h56v-4H4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/bar.svg">
<!-- Bar/Drink icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 8v8l20 24v16H16v4h32v-4H36V40l20-24V8H8zm8 4h32l-16 20L16 12z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/book.svg">
<!-- Book icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M12 8v48c0 2.2 1.8 4 4 4h36V8H16c-2.2 0-4 1.8-4 4zm8 4h28v40H20V12zm4 8v4h20v-4H24zm0 8v4h20v-4H24z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/building.svg">
<!-- Building/Other icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 4v56h20V48h8v12h20V4H8zm8 8h8v8h-8v-8zm16 0h8v8h-8v-8zm16 0h8v8h-8v-8zM16 28h8v8h-8v-8zm16 0h8v8h-8v-8zm16 0h8v8h-8v-8z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/bus.svg">
<!-- Bus icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M12 8c-2.2 0-4 1.8-4 4v36c0 2.2 1.8 4 4 4h4v4h8v-4h16v4h8v-4h4c2.2 0 4-1.8 4-4V12c0-2.2-1.8-4-4-4H12zm4 8h32v16H16V16zm0 24c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm32 0c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/cafe.svg">
<!-- Cafe icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M48 16H12c-2.2 0-4 1.8-4 4v8c0 8.8 7.2 16 16 16h8c8.8 0 16-7.2 16-16v-4h4c2.2 0 4-1.8 4-4s-1.8-4-4-4h-4zm0 8h4v-4h-4v4zM8 52h48v4H8z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/clothing.svg">
<!-- Clothing icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M24 4l-16 12v12l8-4v36h32V24l8 4V16L40 4h-4c0 4.4-3.6 8-8 8s-8-3.6-8-8h-4v8c0 2.2 1.8 4 4 4h8c2.2 0 4-1.8 4-4V4h-8z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/college.svg">
<!-- College/University icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 18l28 14 28-14L32 4zM8 24v4l24 12 24-12v-4L32 36 8 24zm4 12v16l20 8 20-8V36l-20 10-20-10z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/electronics.svg">
<!-- Electronics icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M16 4c-2.2 0-4 1.8-4 4v40c0 2.2 1.8 4 4 4h4v4c0 2.2 1.8 4 4 4h16c2.2 0 4-1.8 4-4v-4h4c2.2 0 4-1.8 4-4V8c0-2.2-1.8-4-4-4H16zm4 8h24v28H20V12zm12 32c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/gym.svg">
<!-- Gym/Fitness icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M4 24v16h4v-4h4v4h4V24h-4v4H8v-4H4zm48 0v16h4v-4h4v4h4V24h-4v4h-4v-4h-4zM16 28v8h32v-8H16z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/hospital.svg">
<!-- Hospital icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 8v48h48V8H8zm20 8h8v12h12v8H36v12h-8V36H16v-8h12V16z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/house.svg">
<!-- House/Residential icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 32h8v24h16V40h8v16h16V32h8L32 4zm0 12l12 12v20H36V32h-8v16H20V28l12-12z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/location-pin.svg">
<!-- Location pin icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <defs>
    <linearGradient id="pinGrad" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#1E3A5F"/>
      <stop offset="100%" style="stop-color:#0F2439"/>
    </linearGradient>
  </defs>
  <path d="M32 4C20 4 10 14 10 26c0 16 22 34 22 34s22-18 22-34c0-12-10-22-22-22z" fill="url(#pinGrad)"/>
  <circle cx="32" cy="24" r="10" fill="white"/>
  <circle cx="32" cy="24" r="5" fill="#F5A623"/>
</svg>
</file>

<file path="frontend/public/icons/mall.svg">
<!-- Mall/Shopping icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M20 8l-4 16H8v4h48v-4h-8l-4-16H20zm-4 24v24h8V40h16v16h8V32H16zm8-20h16l2 8H22l2-8z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/marker.svg">
<!-- Competitor/Store marker icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4C20 4 10 14 10 26c0 16 22 34 22 34s22-18 22-34c0-12-10-22-22-22zm0 30c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/metro.svg">
<!-- Metro/Train icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M16 4c-4.4 0-8 3.6-8 8v32c0 4.4 3.6 8 8 8l-4 8h4l4-8h24l4 8h4l-4-8c4.4 0 8-3.6 8-8V12c0-4.4-3.6-8-8-8H16zm0 8h32v16H16V12zm4 24c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm24 0c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/office.svg">
<!-- Office/Building icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M12 4v56h16V48h8v12h16V4H12zm8 8h8v8h-8v-8zm16 0h8v8h-8v-8zm-16 16h8v8h-8v-8zm16 0h8v8h-8v-8z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/park.svg">
<!-- Park/Tree icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4c-8 0-16 8-16 20h-4l12 16h-6l14 20h4V44h-6l12-16h-4C44 12 40 4 32 4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/pharmacy.svg">
<!-- Pharmacy/Medical icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M24 4v16H8v24h16v16h16V44h16V20H40V4H24zm4 20h8v8h8v8h-8v8h-8v-8h-8v-8h8v-8z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/restaurant.svg">
<!-- Restaurant icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M20 4c-1.1 0-2 .9-2 2v20c0 3.3 2.7 6 6 6v26c0 1.1.9 2 2 2h4c1.1 0 2-.9 2-2V32c3.3 0 6-2.7 6-6V6c0-1.1-.9-2-2-2s-2 .9-2 2v16h-4V6c0-1.1-.9-2-2-2s-2 .9-2 2v16h-4V6c0-1.1-.9-2-2-2zm24 0c-1.1 0-2 .9-2 2v22c0 2.8 1.6 5.2 4 6.3V58c0 1.1.9 2 2 2h4c1.1 0 2-.9 2-2V6c0-7.7-8-2-10-2z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/salon.svg">
<!-- Salon icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4C20 4 12 16 12 28c0 8 4 15 10 19v9c0 2.2 1.8 4 4 4h12c2.2 0 4-1.8 4-4v-9c6-4 10-11 10-19C52 16 44 4 32 4zm-4 28c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4zm8 0c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/school.svg">
<!-- School icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4L4 20v4l28-12 28 12v-4L32 4zM8 28v28h16V40h16v16h16V28l-24-10L8 28z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/search.svg">
<!-- Search icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M28 8C16.96 8 8 16.96 8 28s8.96 20 20 20c4.44 0 8.56-1.48 11.9-3.96L51.04 55.2l5.66-5.66-11.14-11.14C48.04 35.06 48 31.58 48 28c0-11.04-8.96-20-20-20zm0 8c6.62 0 12 5.38 12 12s-5.38 12-12 12-12-5.38-12-12 5.38-12 12-12z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/star.svg">
<!-- Star/Recommended icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4l-9.17 18.58L4 25.82l13.42 13.08L14.17 58 32 48.42 49.83 58l-3.25-19.1L60 25.82l-18.83-3.24L32 4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/store.svg">
<!-- Store/Retail icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M8 8v8l4 8v32h40V24l4-8V8H8zm8 16h8v16h-8V24zm16 0h8v16h-8V24z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/icons/temple.svg">
<!-- Temple icon - Flaticon style -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <path d="M32 4l-4 8h-4l-8 12H8v4h4v28h8V36h24v20h8V28h4v-4h-8l-8-12h-4l-4-8zm0 12c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z" fill="currentColor"/>
</svg>
</file>

<file path="frontend/public/logo.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
  <!-- Heatmap base (yellow to orange gradient rings) -->
  <defs>
    <linearGradient id="heatGradient" x1="0%" y1="100%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#F7B731;stop-opacity:1" />
      <stop offset="50%" style="stop-color:#F5A623;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#EB5B3C;stop-opacity:1" />
    </linearGradient>
    <linearGradient id="pinGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#1E3A5F;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#0F2439;stop-opacity:1" />
    </linearGradient>
  </defs>
  
  <!-- Heatmap rings (perspective transformed) -->
  <ellipse cx="50" cy="75" rx="45" ry="18" fill="#F7B731" opacity="0.9"/>
  <ellipse cx="50" cy="72" rx="35" ry="14" fill="#F5A623" opacity="0.95"/>
  <ellipse cx="50" cy="69" rx="25" ry="10" fill="#EB5B3C" opacity="1"/>
  <ellipse cx="50" cy="66" rx="15" ry="6" fill="#E74C3C" opacity="1"/>
  
  <!-- Location Pin -->
  <path d="M50 12 C35 12 24 23 24 38 C24 53 50 70 50 70 C50 70 76 53 76 38 C76 23 65 12 50 12 Z" 
        fill="url(#pinGradient)" 
        stroke="#1E3A5F" 
        stroke-width="1"/>
  
  <!-- Inner circle (white) -->
  <circle cx="50" cy="36" r="14" fill="white"/>
  
  <!-- Center dot (orange) -->
  <circle cx="50" cy="36" r="7" fill="#F5A623"/>
</svg>
</file>

<file path="frontend/src/components/Chat/ChatBot.jsx">
import React, { useState, useRef, useEffect } from 'react';
import { chat } from '../../services/api';

export const ChatBot = ({ selectedLocation, businessType, analysis, isOpen, onClose }) => {
    const [messages, setMessages] = useState([
        {
            role: 'assistant',
            content: 'Hi! I\'m Hotspot IQ. I can help you analyze locations and answer questions about your business expansion. How can I help you today?'
        }
    ]);
    const [input, setInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const messagesEndRef = useRef(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    useEffect(() => {
        if (isOpen) {
            scrollToBottom();
        }
    }, [messages, isOpen]);

    const handleSend = async (e) => {
        e.preventDefault();
        if (!input.trim()) return;

        const userMessage = input.trim();
        setInput('');
        setMessages(prev => [...prev, { role: 'user', content: userMessage }]);
        setIsLoading(true);

        try {
            const context = {
                lat: selectedLocation?.lat,
                lng: selectedLocation?.lng,
                business_type: businessType,
                analysis_data: analysis
            };

            const response = await chat(userMessage, context);

            setMessages(prev => [...prev, {
                role: 'assistant',
                content: response.response,
                isAi: response.ai_powered
            }]);
        } catch (error) {
            setMessages(prev => [...prev, {
                role: 'assistant',
                content: 'Sorry, I encountered an error. Please try again later.',
                isError: true
            }]);
        } finally {
            setIsLoading(false);
        }
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center pointer-events-auto">
            {/* Backdrop */}
            <div
                className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                onClick={onClose}
            />

            {/* Chat Window */}
            <div className="relative w-full max-w-lg h-[600px] glass-panel flex flex-col shadow-2xl animate-in zoom-in-95 fade-in duration-200 mx-4">
                {/* Header */}
                <div className="p-4 border-b border-surface-border flex justify-between items-center bg-surface-elevated/50">
                    <div className="flex items-center gap-2">
                        <div className="w-2 h-2 rounded-full bg-emerald-400 animate-pulse" />
                        <h3 className="font-semibold text-white">Hotspot IQ Assistant</h3>
                    </div>
                    <button
                        onClick={onClose}
                        className="text-slate-400 hover:text-white transition-colors"
                    >
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                {/* Messages */}
                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                    {messages.map((msg, idx) => (
                        <div
                            key={idx}
                            className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
                        >
                            <div
                                className={`
                max-w-[80%] p-3 rounded-2xl text-sm
                ${msg.role === 'user'
                                        ? 'bg-primary-glow/20 text-white rounded-tr-sm border border-primary-glow/30'
                                        : 'bg-surface-elevated text-slate-200 rounded-tl-sm border border-surface-border'
                                    }
                ${msg.isError ? 'border-destructive-glow/50 text-destructive-glow' : ''}
              `}
                            >
                                <p className="whitespace-pre-wrap">{msg.content}</p>
                                {msg.isAi && (
                                    <div className="mt-1 flex items-center gap-1 opacity-50">
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                                        </svg>
                                        <span className="text-[10px]">AI Powered</span>
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}
                    {isLoading && (
                        <div className="flex justify-start">
                            <div className="bg-surface-elevated p-3 rounded-2xl rounded-tl-sm border border-surface-border">
                                <div className="flex gap-1">
                                    <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                                    <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                                    <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                                </div>
                            </div>
                        </div>
                    )}
                    <div ref={messagesEndRef} />
                </div>

                {/* Input */}
                <form onSubmit={handleSend} className="p-4 border-t border-surface-border bg-surface-elevated/30">
                    <div className="relative">
                        <input
                            type="text"
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            placeholder="Ask about this location..."
                            className="w-full bg-surface-base border border-surface-border rounded-xl py-3 pl-4 pr-12 text-sm text-white placeholder-slate-500 focus:outline-none focus:border-primary-glow focus:ring-1 focus:ring-primary-glow transition-all"
                            disabled={isLoading}
                        />
                        <button
                            type="submit"
                            disabled={!input.trim() || isLoading}
                            className="absolute right-2 top-1/2 -translate-y-1/2 p-1.5 text-primary-glow hover:text-white disabled:opacity-50 disabled:hover:text-primary-glow transition-colors"
                        >
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                            </svg>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};
</file>

<file path="frontend/src/components/Chat/index.js">
export { ChatBot } from './ChatBot';
</file>

<file path="frontend/src/components/common/Icon.jsx">
/**
 * Icon Component
 * Renders SVG icons from the public/icons folder
 */

// Icon mapping for business types
export const BUSINESS_ICONS = {
  cafe: '/icons/cafe.svg',
  restaurant: '/icons/restaurant.svg',
  retail: '/icons/store.svg',
  gym: '/icons/gym.svg',
  pharmacy: '/icons/pharmacy.svg',
  salon: '/icons/salon.svg',
  electronics: '/icons/electronics.svg',
  clothing: '/icons/clothing.svg',
  bookstore: '/icons/book.svg',
  other: '/icons/building.svg',
};

// Icon mapping for proximity filters
export const PROXIMITY_ICONS = {
  near_metro: '/icons/metro.svg',
  near_bus: '/icons/bus.svg',
  near_school: '/icons/school.svg',
  near_college: '/icons/college.svg',
  near_hospital: '/icons/hospital.svg',
  near_mall: '/icons/mall.svg',
  near_office: '/icons/office.svg',
  near_residential: '/icons/house.svg',
  near_temple: '/icons/temple.svg',
  near_park: '/icons/park.svg',
  near_atm: '/icons/bank.svg',
  near_bar: '/icons/bar.svg',
};

// General icons
export const GENERAL_ICONS = {
  search: '/icons/search.svg',
  marker: '/icons/marker.svg',
  locationPin: '/icons/location-pin.svg',
  star: '/icons/star.svg',
};

/**
 * Icon component - renders SVG icons with customizable size and color
 */
export default function Icon({ 
  name, 
  src, 
  size = 24, 
  className = '',
  color = 'currentColor',
  style = {}
}) {
  // Determine the icon source
  const iconSrc = src || BUSINESS_ICONS[name] || PROXIMITY_ICONS[name] || GENERAL_ICONS[name];
  
  if (!iconSrc) {
    console.warn(`Icon not found: ${name}`);
    return null;
  }

  return (
    <img 
      src={iconSrc} 
      alt={name || 'icon'}
      width={size}
      height={size}
      className={`inline-block ${className}`}
      style={{ 
        filter: color !== 'currentColor' ? 'brightness(0) saturate(100%)' : undefined,
        ...style 
      }}
    />
  );
}

/**
 * Colored Icon component - applies color filter to SVG
 */
export function ColoredIcon({ 
  name, 
  src, 
  size = 24, 
  color = '#F5A623',
  className = '' 
}) {
  const iconSrc = src || BUSINESS_ICONS[name] || PROXIMITY_ICONS[name] || GENERAL_ICONS[name];
  
  if (!iconSrc) {
    return null;
  }

  // Convert hex color to CSS filter
  const getColorFilter = (hexColor) => {
    // Common color mappings
    const colorFilters = {
      '#F5A623': 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)', // orange
      '#10b981': 'invert(64%) sepia(44%) saturate(533%) hue-rotate(109deg) brightness(93%) contrast(88%)', // green
      '#f43f5e': 'invert(42%) sepia(93%) saturate(1352%) hue-rotate(326deg) brightness(99%) contrast(97%)', // red
      '#3b82f6': 'invert(47%) sepia(98%) saturate(1953%) hue-rotate(207deg) brightness(98%) contrast(94%)', // blue
      '#8b5cf6': 'invert(44%) sepia(94%) saturate(2670%) hue-rotate(243deg) brightness(95%) contrast(94%)', // purple
      '#ffffff': 'brightness(0) invert(1)', // white
      '#1E3A5F': 'invert(19%) sepia(29%) saturate(1039%) hue-rotate(178deg) brightness(92%) contrast(87%)', // dark blue
    };
    return colorFilters[hexColor] || '';
  };

  return (
    <img 
      src={iconSrc} 
      alt={name || 'icon'}
      width={size}
      height={size}
      className={`inline-block ${className}`}
      style={{ 
        filter: getColorFilter(color)
      }}
    />
  );
}
</file>

<file path="frontend/src/components/common/index.js">
/**
 * Common Components Index
 */

export { default as Icon, ColoredIcon, BUSINESS_ICONS, PROXIMITY_ICONS, GENERAL_ICONS } from './Icon';
</file>

<file path="frontend/src/components/Dashboard/Charts/index.js">
export { default as CompetitorChart } from './CompetitorChart';
export { default as LandmarkRadar } from './LandmarkRadar';
export { default as ScoreGauge } from './ScoreGauge';
</file>

<file path="frontend/src/components/Dashboard/Charts/ScoreGauge.jsx">
/**
 * Score Gauge Component
 * Circular gauge visualization for opportunity score
 */

import { useMemo } from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer } from 'recharts';

export default function ScoreGauge({ score = 0, size = 'md', showLabel = true, isLoading }) {
  const normalizedScore = Math.min(100, Math.max(0, score));
  
  // Determine color based on score
  const scoreColor = useMemo(() => {
    if (normalizedScore >= 70) return '#10b981'; // Green - Excellent
    if (normalizedScore >= 50) return '#06b6d4'; // Cyan - Good
    if (normalizedScore >= 30) return '#f59e0b'; // Amber - Fair
    return '#f43f5e'; // Rose - Poor
  }, [normalizedScore]);

  const scoreLabel = useMemo(() => {
    if (normalizedScore >= 70) return 'Excellent';
    if (normalizedScore >= 50) return 'Good';
    if (normalizedScore >= 30) return 'Fair';
    return 'Poor';
  }, [normalizedScore]);

  // Chart data for gauge effect
  const data = [
    { name: 'score', value: normalizedScore },
    { name: 'remaining', value: 100 - normalizedScore },
  ];

  // Size configurations
  const sizes = {
    sm: { width: 100, height: 100, inner: 35, outer: 45, fontSize: 'text-xl' },
    md: { width: 160, height: 160, inner: 55, outer: 70, fontSize: 'text-3xl' },
    lg: { width: 200, height: 200, inner: 70, outer: 90, fontSize: 'text-4xl' },
  };

  const config = sizes[size] || sizes.md;

  if (isLoading) {
    return (
      <div 
        className="relative flex items-center justify-center"
        style={{ width: config.width, height: config.height }}
      >
        <div 
          className="absolute rounded-full border-8 border-slate-700 animate-pulse"
          style={{ 
            width: config.outer * 2, 
            height: config.outer * 2,
          }}
        />
        <div className="w-8 h-8 border-2 border-slate-600 border-t-primary-glow rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div 
      className="relative"
      style={{ width: config.width, height: config.height }}
    >
      <ResponsiveContainer width="100%" height="100%">
        <PieChart>
          <Pie
            data={data}
            cx="50%"
            cy="50%"
            startAngle={180}
            endAngle={0}
            innerRadius={config.inner}
            outerRadius={config.outer}
            paddingAngle={0}
            dataKey="value"
            stroke="none"
          >
            <Cell fill={scoreColor} />
            <Cell fill="#1e293b" />
          </Pie>
        </PieChart>
      </ResponsiveContainer>
      
      {/* Center content */}
      <div className="absolute inset-0 flex flex-col items-center justify-center">
        <span 
          className={`font-bold ${config.fontSize} transition-colors duration-500`}
          style={{ color: scoreColor }}
        >
          {normalizedScore}
        </span>
        {showLabel && (
          <span 
            className="text-xs font-medium transition-colors duration-500 -mt-1"
            style={{ color: scoreColor }}
          >
            {scoreLabel}
          </span>
        )}
      </div>
      
      {/* Scale markers */}
      <div className="absolute bottom-0 left-0 right-0 flex justify-between px-2 text-xs text-slate-600">
        <span>0</span>
        <span>50</span>
        <span>100</span>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Filters/index.js">
export { default as BusinessTypeSelector } from './BusinessTypeSelector';
export { default as ProximityFilters } from './ProximityFilters';
</file>

<file path="frontend/src/components/Layout/index.js">
export { default as Header } from './Header';
</file>

<file path="frontend/src/components/Map/HeatmapOverlay.jsx">
/**
 * Heatmap Overlay Component
 * Shows competition density as a heatmap overlay on the map
 * Red = High competition (avoid), Green = Low competition (opportunity)
 */

import { useEffect, useRef } from 'react';
import { useMap } from 'react-leaflet';
import L from 'leaflet';

/**
 * Generate heatmap data points based on competitors and landmarks
 * Creates a grid of points with intensity values
 */
function generateHeatmapGrid(center, competitors, landmarks, radius = 2500) {
  const gridSize = 20; // Number of grid cells in each direction
  const cellSize = (radius * 2) / gridSize;
  const points = [];
  
  // Convert radius from meters to degrees (approximate)
  const latDelta = radius / 111000; // 1 degree lat  111km
  const lngDelta = radius / (111000 * Math.cos(center.lat * Math.PI / 180));
  
  // Create grid
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      const lat = center.lat - latDelta + (i / gridSize) * 2 * latDelta;
      const lng = center.lng - lngDelta + (j / gridSize) * 2 * lngDelta;
      
      // Calculate competition intensity at this point
      let competitorScore = 0;
      let landmarkScore = 0;
      
      // Higher score = more competitors nearby = RED
      competitors.forEach(comp => {
        if (comp.lat && comp.lng) {
          const dist = getDistance(lat, lng, comp.lat, comp.lng);
          if (dist < cellSize * 2) {
            competitorScore += Math.max(0, 1 - dist / (cellSize * 2));
          }
        }
      });
      
      // Landmarks add opportunity (reduce competition effect slightly)
      landmarks.forEach(lm => {
        if (lm.lat && lm.lng) {
          const dist = getDistance(lat, lng, lm.lat, lm.lng);
          if (dist < cellSize * 2) {
            landmarkScore += Math.max(0, 0.3 * (1 - dist / (cellSize * 2)));
          }
        }
      });
      
      // Net intensity: positive = competition (red), negative = opportunity (green)
      // Normalize to 0-1 range
      const intensity = Math.min(1, Math.max(0, competitorScore - landmarkScore * 0.5));
      
      points.push({
        lat,
        lng,
        intensity,
        hasCompetitors: competitorScore > 0,
      });
    }
  }
  
  return points;
}

/**
 * Calculate distance between two points in meters
 */
function getDistance(lat1, lng1, lat2, lng2) {
  const R = 6371000; // Earth's radius in meters
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Get color based on intensity
 * Low intensity (0) = Green (opportunity)
 * High intensity (1) = Red (competition)
 */
function getHeatColor(intensity) {
  // Color gradient: Green -> Yellow -> Orange -> Red
  if (intensity < 0.25) {
    // Green to light green
    const t = intensity / 0.25;
    return {
      r: Math.round(34 + t * 100),
      g: Math.round(197 - t * 50),
      b: Math.round(94 - t * 50),
      a: 0.3 + t * 0.1
    };
  } else if (intensity < 0.5) {
    // Light green to yellow
    const t = (intensity - 0.25) / 0.25;
    return {
      r: Math.round(134 + t * 121),
      g: Math.round(147 + t * 53),
      b: Math.round(44 - t * 44),
      a: 0.4 + t * 0.1
    };
  } else if (intensity < 0.75) {
    // Yellow to orange
    const t = (intensity - 0.5) / 0.25;
    return {
      r: 255,
      g: Math.round(200 - t * 100),
      b: 0,
      a: 0.5 + t * 0.1
    };
  } else {
    // Orange to red
    const t = (intensity - 0.75) / 0.25;
    return {
      r: 255,
      g: Math.round(100 - t * 60),
      b: Math.round(t * 50),
      a: 0.6 + t * 0.15
    };
  }
}

export default function HeatmapOverlay({ 
  center, 
  competitors = [], 
  landmarks = [],
  radius = 2500,
  enabled = true 
}) {
  const map = useMap();
  const canvasRef = useRef(null);
  const overlayRef = useRef(null);

  useEffect(() => {
    if (!enabled || !center || !map) return;

    // Remove existing overlay
    if (overlayRef.current) {
      map.removeLayer(overlayRef.current);
    }

    // Generate heatmap points
    const points = generateHeatmapGrid(center, competitors, landmarks, radius);
    
    // If no competitors, don't show heatmap
    if (competitors.length === 0) return;

    // Calculate bounds
    const latDelta = radius / 111000;
    const lngDelta = radius / (111000 * Math.cos(center.lat * Math.PI / 180));
    const bounds = L.latLngBounds(
      [center.lat - latDelta, center.lng - lngDelta],
      [center.lat + latDelta, center.lng + lngDelta]
    );

    // Create canvas with higher resolution for smoother circle
    const canvas = document.createElement('canvas');
    const canvasSize = 400;
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const ctx = canvas.getContext('2d');

    // Define circular clipping region first
    const centerX = canvasSize / 2;
    const centerY = canvasSize / 2;
    const circleRadius = canvasSize / 2 - 2; // Slightly smaller for clean edge

    // Create circular clip path
    ctx.save();
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
    ctx.clip();

    // Draw heatmap cells within the circle
    const gridSize = 20;
    const cellWidth = canvasSize / gridSize;
    const cellHeight = canvasSize / gridSize;

    points.forEach((point, index) => {
      const i = Math.floor(index / gridSize);
      const j = index % gridSize;
      
      const x = j * cellWidth + cellWidth / 2;
      const y = (gridSize - 1 - i) * cellHeight + cellHeight / 2;
      
      // Check if point is within circle
      const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
      if (distFromCenter > circleRadius) return;
      
      const color = getHeatColor(point.intensity);
      const cellRadius = cellWidth * 1.0;
      
      // Create radial gradient for smooth effect
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, cellRadius);
      gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`);
      gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, cellRadius, 0, Math.PI * 2);
      ctx.fill();
    });

    // Restore context (removes clip)
    ctx.restore();

    // Draw circle border
    ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
    ctx.stroke();

    // Create image overlay
    const imageUrl = canvas.toDataURL();
    overlayRef.current = L.imageOverlay(imageUrl, bounds, {
      opacity: 0.7,
      interactive: false,
    });
    
    overlayRef.current.addTo(map);

    // Cleanup
    return () => {
      if (overlayRef.current) {
        map.removeLayer(overlayRef.current);
      }
    };
  }, [map, center, competitors, landmarks, radius, enabled]);

  return null;
}
</file>

<file path="frontend/src/components/Search/index.js">
export { default as SearchBar } from './SearchBar';
</file>

<file path="frontend/src/hooks/index.js">
export { default as useAnalysis } from './useAnalysis';
export { default as useLocation } from './useLocation';
export { default as useFilters } from './useFilters';
</file>

<file path="frontend/src/hooks/useFilters.js">
/**
 * useFilters Hook
 * Manages business type and proximity filter selections
 */

import { useState, useCallback, useMemo } from 'react';

// Popular filter presets
const POPULAR_FILTERS = ['metro', 'mall', 'office', 'college'];

export default function useFilters() {
  const [businessType, setBusinessType] = useState(null);
  const [proximityFilters, setProximityFilters] = useState([]);

  // Toggle a single proximity filter
  const toggleFilter = useCallback((filterId) => {
    setProximityFilters((prev) => {
      if (prev.includes(filterId)) {
        return prev.filter((f) => f !== filterId);
      }
      return [...prev, filterId];
    });
  }, []);

  // Select multiple filters at once
  const selectFilters = useCallback((filterIds) => {
    setProximityFilters(filterIds);
  }, []);

  // Select popular filters preset
  const selectPopularFilters = useCallback(() => {
    setProximityFilters(POPULAR_FILTERS);
  }, []);

  // Clear all proximity filters
  const clearFilters = useCallback(() => {
    setProximityFilters([]);
  }, []);

  // Clear everything (business type + filters)
  const clearAll = useCallback(() => {
    setBusinessType(null);
    setProximityFilters([]);
  }, []);

  // Check if a filter is selected
  const isFilterSelected = useCallback(
    (filterId) => proximityFilters.includes(filterId),
    [proximityFilters]
  );

  // Check if ready to analyze
  const canAnalyze = useMemo(() => {
    return businessType !== null;
  }, [businessType]);

  // Get filter summary for display
  const filterSummary = useMemo(() => {
    if (proximityFilters.length === 0) return 'No preferences set';
    if (proximityFilters.length === 1) return '1 preference';
    return `${proximityFilters.length} preferences`;
  }, [proximityFilters]);

  return {
    // State
    businessType,
    proximityFilters,
    canAnalyze,
    filterSummary,
    
    // Business Type Actions
    setBusinessType,
    
    // Proximity Filter Actions
    toggleFilter,
    selectFilters,
    selectPopularFilters,
    clearFilters,
    isFilterSelected,
    
    // Reset
    clearAll,
  };
}
</file>

<file path="frontend/src/hooks/useLocation.js">
/**
 * useLocation Hook
 * Manages selected location state
 */

import { useState, useCallback } from 'react';
import { searchLocations, geocodeLocation } from '../services/api';

export default function useLocation() {
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isGeocoding, setIsGeocoding] = useState(false);
  const [searchError, setSearchError] = useState(null);

  const search = useCallback(async (query) => {
    if (!query || query.length < 2) {
      setSearchResults([]);
      return;
    }

    setIsSearching(true);
    setSearchError(null);

    try {
      const results = await searchLocations(query);
      setSearchResults(results);
    } catch (error) {
      console.error('Search error:', error);
      setSearchError(error.message || 'Failed to search locations');
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  }, []);

  const selectLocation = useCallback(async (location) => {
    // If location already has coordinates, use it directly
    if (location.lat && location.lng) {
      setSelectedLocation(location);
      setSearchResults([]);
      return;
    }
    
    // Otherwise, geocode the location name to get coordinates
    setIsGeocoding(true);
    setSearchError(null);
    
    try {
      const geocoded = await geocodeLocation(location.name);
      setSelectedLocation({
        name: location.name,
        lat: geocoded.lat,
        lng: geocoded.lng,
        address: geocoded.address,
        geoid: location.geoid
      });
      setSearchResults([]);
    } catch (error) {
      console.error('Geocode error:', error);
      setSearchError('Could not find coordinates for this location');
      // Still set the location but without coordinates
      setSelectedLocation({
        ...location,
        lat: null,
        lng: null,
        needsGeocode: true
      });
    } finally {
      setIsGeocoding(false);
    }
  }, []);

  const selectFromCoords = useCallback((lat, lng, name = null) => {
    setSelectedLocation({
      lat,
      lng,
      name: name || `${lat.toFixed(4)}, ${lng.toFixed(4)}`,
    });
  }, []);

  const clearLocation = useCallback(() => {
    setSelectedLocation(null);
    setSearchResults([]);
    setSearchError(null);
  }, []);

  return {
    // State
    selectedLocation,
    searchResults,
    isSearching,
    isGeocoding,
    searchError,
    
    // Actions
    search,
    selectLocation,
    selectFromCoords,
    clearLocation,
  };
}
</file>

<file path="frontend/src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import 'leaflet/dist/leaflet.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class', // Enable class-based dark mode
  theme: {
    extend: {
      colors: {
        // Canvas - Background layers
        canvas: {
          deep: '#020617',  // slate-950
          base: '#0f172a',  // slate-900
        },
        // Light mode canvas
        'canvas-light': {
          deep: '#f8fafc',  // slate-50
          base: '#f1f5f9',  // slate-100
        },
        // Surface - Glass layers
        surface: {
          primary: 'rgba(15, 23, 42, 0.8)',
          secondary: 'rgba(30, 41, 59, 0.7)',
          elevated: 'rgba(51, 65, 85, 0.6)',
          border: 'rgba(255, 255, 255, 0.08)',
        },
        // Light mode surfaces
        'surface-light': {
          primary: 'rgba(255, 255, 255, 0.9)',
          secondary: 'rgba(248, 250, 252, 0.9)',
          elevated: 'rgba(241, 245, 249, 0.9)',
          border: 'rgba(0, 0, 0, 0.1)',
        },
        // Primary - Neon Emerald
        primary: {
          glow: '#10b981',     // emerald-500
          bright: '#34d399',   // emerald-400
          soft: 'rgba(16, 185, 129, 0.2)',
          pulse: 'rgba(16, 185, 129, 0.5)',
        },
        // Warning - Amber
        warning: {
          glow: '#f59e0b',     // amber-500
          soft: 'rgba(245, 158, 11, 0.2)',
        },
        // Destructive - Rose
        destructive: {
          glow: '#f43f5e',     // rose-500
          bright: '#fb7185',   // rose-400
          soft: 'rgba(244, 63, 94, 0.2)',
        },
        // Accent
        accent: {
          cyan: '#06b6d4',     // cyan-500
          violet: '#8b5cf6',   // violet-500
        }
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
        mono: ['JetBrains Mono', 'Fira Code', 'Consolas', 'monospace'],
      },
      boxShadow: {
        'glow-primary': '0 0 20px rgba(16, 185, 129, 0.4), 0 0 40px rgba(16, 185, 129, 0.2)',
        'glow-warning': '0 0 20px rgba(245, 158, 11, 0.4), 0 0 40px rgba(245, 158, 11, 0.2)',
        'glow-destructive': '0 0 20px rgba(244, 63, 94, 0.4), 0 0 40px rgba(244, 63, 94, 0.2)',
        'glow-violet': '0 0 20px rgba(139, 92, 246, 0.4), 0 0 40px rgba(139, 92, 246, 0.2)',
        'glass': '0 8px 32px rgba(0, 0, 0, 0.4)',
      },
      backdropBlur: {
        'glass': '12px',
      },
      animation: {
        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'slide-in-right': 'slideInRight 0.4s ease-out',
        'slide-in-up': 'slideInUp 0.3s ease-out',
        'fade-in': 'fadeIn 0.2s ease-out',
        'glow-pulse': 'glowPulse 2s ease-in-out infinite',
      },
      keyframes: {
        slideInRight: {
          '0%': { transform: 'translateX(20px)', opacity: '0' },
          '100%': { transform: 'translateX(0)', opacity: '1' },
        },
        slideInUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        glowPulse: {
          '0%, 100%': { boxShadow: '0 0 20px rgba(16, 185, 129, 0.4)' },
          '50%': { boxShadow: '0 0 30px rgba(16, 185, 129, 0.6), 0 0 60px rgba(16, 185, 129, 0.3)' },
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="frontend/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true
  }
})
</file>

<file path="README.md">
#  Hotspot IQ

<div align="center">

![Hotspot IQ](https://img.shields.io/badge/Hotspot-IQ-blue?style=for-the-badge&logo=mapbox&logoColor=white)
![Python](https://img.shields.io/badge/Python-Flask-green?style=for-the-badge&logo=python&logoColor=white)
![React](https://img.shields.io/badge/React-Vite-61DAFB?style=for-the-badge&logo=react&logoColor=black)
![AI Powered](https://img.shields.io/badge/AI-Powered-orange?style=for-the-badge&logo=openai&logoColor=white)

### **Hyper-Local Location Intelligence for Smarter Business Expansion**

*Stop guessing. Start knowing. Make data-driven decisions for your next store location.*

[Demo](#demo)  [Features](#features)  [Architecture](#architecture)  [Setup](#setup)  [API Docs](#api-documentation)

</div>

---

##  The Problem: Blind Expansion Kills Businesses

**60% of new retail stores fail within the first 3 years.** The #1 reason? **Poor location selection.**

Business owners today rely on:
-  Gut feeling and "foot traffic looks good"
-  Expensive consultants with outdated data
-  Generic tools not built for Indian contexts (pincodes, local landmarks)
-  No visibility into future infrastructure developments

**The cost of a wrong location decision:** 15-50 lakhs in sunk costs, 12-18 months of wasted effort.

---

##  The Solution: Hotspot IQ

Hotspot IQ is an **AI-powered location intelligence platform** that helps entrepreneurs, franchise owners, and retail chains validate potential store locations using:

| Feature | What It Does |
|---------|--------------|
|  **Opportunity Score** | Proprietary algorithm combining footfall, landmarks, and competition |
|  **Hyper-Local Data** | Powered by LatLong.ai for accurate Indian context (pincodes, Digipin) |
|  **AI Advisor** | Ask natural language questions like "Is this good for a gym?" |
|  **Growth Radar** | Scans news for upcoming infrastructure that could boost location value |
|  **Supply Chain Check** | Validates logistics feasibility from your warehouse |

---

##  Features

### Phase 1: Descriptive Analytics (Core)
- **Smart Location Search**  Autocomplete powered by LatLong.ai
- **Competitor Density Mapping**  See how many cafes, ATMs, gyms exist nearby
- **Landmark Intelligence**  Identify proximity to schools, metros, colleges
- **Opportunity Score Dashboard**  One number that tells you if a location is worth it
- **Interactive Heatmaps**  Visual overlay showing business potential

### Phase 2: Interactive Intelligence
- **Isochrone Visualization**  See exactly what's reachable in a 15-min bike/walk radius
- **GenAI Chat ("Ask Hotspot")**  Get AI-powered advice based on real POI data
- **Digipin Integration**  Share exact locations with investors using India's digital address code

### Phase 3: Future Radar & Operations
- **Growth Radar**  AI scans news for "New metro station in Whitefield" type developments
- **Supply Chain Validator**  Enter warehouse location, get logistics feasibility score

---

##  How It Works  User Flow

Hotspot IQ follows a **guided 4-step flow** to ensure users provide the right context before analysis:

```

                          USER JOURNEY FLOW                                  

                                                                             
   STEP 1              STEP 2              STEP 3              STEP 4       
                                           
                                                        
    Type            Filter           Search           Analyze       
                                           
   "What are          "What do           "Where do          "Show me       
    you starting?"     you need           you want           the data!"    
                       nearby?"           to open?"                        
                                                                             

```

### Step 1: Select Business Type 

The user **first selects what type of business** they are planning to open. This is critical because:
- It determines which POIs are counted as **competitors** (e.g., selecting "Cafe"  all nearby cafes are competitors)
- It influences the **Opportunity Score algorithm** weights
- It customizes AI recommendations in the chat

**Available Business Types:**
| Category | Icon | Competitor POI Categories |
|----------|------|---------------------------|
| Cafe / Coffee Shop |  | cafe, coffee_shop, bakery |
| Restaurant |  | restaurant, fast_food, food_court |
| Retail Store |  | retail, supermarket, convenience_store |
| Gym / Fitness Center |  | gym, fitness_center, sports_club |
| Pharmacy / Medical |  | pharmacy, clinic, medical_store |
| Salon / Spa |  | salon, spa, beauty_parlor |
| Electronics Store |  | electronics, mobile_shop, computer_store |
| Clothing / Fashion |  | clothing_store, boutique, fashion |
| Bookstore / Stationery |  | bookstore, stationery, office_supplies |
| Other (Custom) |  | User specifies custom category |

### Step 2: Select Proximity Preferences 

Next, the user selects **what they want nearby** using checkbox filters. These preferences:
- Add **bonus points** to the Opportunity Score when present
- Help identify locations that match the user's ideal criteria
- Filter the map to highlight relevant landmarks

**Available Proximity Filters:**
| Filter | Icon | Why It Matters |
|--------|------|----------------|
| Near Metro Station |  | High footfall, easy accessibility |
| Near Bus Stop |  | Public transit increases customer base |
| Near School |  | Family traffic, afternoon rush |
| Near College/University |  | Young demographic, evening crowd |
| Near Hospital |  | Essential services traffic |
| Near Mall/Shopping Complex |  | Captive audience, high spending power |
| Near Office Complex/IT Park |  | Weekday lunch & after-work crowd |
| Near Residential Area |  | Daily needs, repeat customers |
| Near Temple/Religious Place |  | Weekend/festival traffic |
| Near Park/Recreation |  | Morning/evening joggers, families |
| Near ATM/Bank |  | Financial convenience |
| Near Bar/Pub |  | Nightlife synergy (for restaurants/cafes) |

### Step 3: Search Location 

Now the user searches for a specific location using the **autocomplete search bar**:
- Powered by LatLong.ai Autocomplete API
- Supports addresses, landmarks, pincodes, and place names
- Shows suggestions as user types (debounced 300ms)
- Selecting a suggestion centers the map and drops a marker

### Step 4: Analyze & View Results 

Once location is selected, clicking **"Analyze Location"** triggers:
1. Backend fetches competitor POIs (based on Step 1 business type)
2. Backend fetches landmark POIs (based on Step 2 filters)
3. Opportunity Score is calculated
4. Dashboard cards animate in with results
5. Map updates with competitor markers and heatmap

---

##  Architecture

```mermaid
flowchart TB
    subgraph Client[" Frontend (React + Vite)"]
        UI[React Components]
        Map[React-Leaflet Map]
        Charts[Recharts Dashboard]
        Chat[Chat Widget]
    end

    subgraph BFF[" Backend-for-Frontend (Flask)"]
        API[Flask REST API]
        Score[Score Engine]
        Cache[Response Cache]
    end

    subgraph External[" External APIs"]
        LL[LatLong.ai]
        OAI[OpenAI GPT-4o mini]
        DDG[DuckDuckGo Search]
    end

    UI --> API
    Map --> API
    Chat --> API
    
    API --> LL
    API --> OAI
    API --> DDG
    
    LL --> |Geocoding, POI, Isochrones| API
    OAI --> |Natural Language Analysis| API
    DDG --> |Future News Search| API
    
    API --> Score
    Score --> Charts

    style Client fill:#e1f5fe
    style BFF fill:#fff3e0
    style External fill:#f3e5f5
```

### Why Backend-for-Frontend (BFF)?
1. **Security**  API keys never exposed to browser
2. **Aggregation**  Combine multiple API calls into one response
3. **Transformation**  Shape data exactly as frontend needs it
4. **Caching**  Reduce API costs by caching frequent queries

---

##  Tech Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Frontend** | React 18 + Vite | Fast, modern UI framework |
| **Styling** | Tailwind CSS | Utility-first CSS |
| **Maps** | React-Leaflet | Interactive map rendering |
| **Charts** | Recharts | Analytics visualization |
| **Backend** | Python Flask | REST API server |
| **Data** | Pandas | Data manipulation |
| **AI** | OpenAI GPT-4o mini | Natural language analysis |
| **Geo APIs** | LatLong.ai | Indian geospatial data |
| **Search** | DuckDuckGo | News & web search |

---

##  Setup Instructions

### Prerequisites
- Node.js 18+ & npm
- Python 3.10+
- API Keys: LatLong.ai, OpenAI

### 1. Clone the Repository
```bash
git clone https://github.com/your-team/hotspot-iq.git
cd hotspot-iq
```

### 2. Backend Setup
```bash
cd backend

# Create virtual environment
python -m venv venv

# Activate (Windows)
.\venv\Scripts\activate

# Activate (Mac/Linux)
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Configure environment
copy .env.example .env
# Edit .env with your API keys
```

### 3. Frontend Setup
```bash
cd frontend

# Install dependencies
npm install

# Configure environment
copy .env.example .env
# Edit .env if needed
```

### 4. Environment Variables

**Backend `.env`:**
```env
FLASK_ENV=development
FLASK_DEBUG=True
LATLONG_API_KEY=your_latlong_api_key
OPENAI_API_KEY=your_openai_api_key
```

**Frontend `.env`:**
```env
VITE_API_BASE_URL=http://localhost:5000/api
```

### 5. Run the Application

**Terminal 1  Backend:**
```bash
cd backend
python app.py
# Server runs on http://localhost:5000
```

**Terminal 2  Frontend:**
```bash
cd frontend
npm run dev
# App runs on http://localhost:5173
```

---

##  API Documentation

### Base URL
```
http://localhost:5000/api
```

### Endpoints

####  Location Search
```http
GET /api/autocomplete?query={search_term}
```
Returns location suggestions for autocomplete dropdown.

**Response:**
```json
{
  "suggestions": [
    { "place_id": "abc123", "name": "Indiranagar, Bangalore", "lat": 12.97, "lng": 77.64 }
  ]
}
```

---

####  Location Analysis
```http
POST /api/analyze
Content-Type: application/json

{
  "lat": 12.9716,
  "lng": 77.5946,
  "business_type": "cafe",
  "filters": ["near_metro", "near_college"]
}
```
Returns comprehensive location analysis including opportunity score.

**Response:**
```json
{
  "opportunity_score": 78,
  "competitors": { "count": 12, "nearby": [...] },
  "landmarks": { "metro": 2, "schools": 5, "colleges": 1 },
  "footfall_proxy": "high",
  "recommendation": "Strong potential for cafe"
}
```

---

####  Isochrone (Reachability)
```http
POST /api/isochrone
Content-Type: application/json

{
  "lat": 12.9716,
  "lng": 77.5946,
  "mode": "bike",
  "time_minutes": 15
}
```
Returns GeoJSON polygon for isochrone visualization.

**Response:**
```json
{
  "type": "Feature",
  "geometry": {
    "type": "Polygon",
    "coordinates": [[[77.59, 12.97], ...]]
  }
}
```

---

####  AI Chat
```http
POST /api/chat
Content-Type: application/json

{
  "message": "Is this location good for a gym?",
  "context": {
    "lat": 12.9716,
    "lng": 77.5946
  }
}
```
Returns AI-powered location advice.

**Response:**
```json
{
  "response": "Based on the data, this location shows strong potential for a gym. There are 3 corporate offices within 1km, high residential density, and only 1 competing gym. The footfall proxy indicates high morning and evening activity.",
  "data_sources": ["poi", "landmarks", "competitors"]
}
```

---

####  Digipin Lookup
```http
GET /api/digipin?lat={lat}&lng={lng}
```
Returns the official Digipin (Digital Address Code) for a location.

**Response:**
```json
{
  "digipin": "MH-12-ABC-1234",
  "formatted_address": "123, MG Road, Indiranagar, Bangalore - 560038"
}
```

---

####  Growth Radar
```http
POST /api/growth-radar
Content-Type: application/json

{
  "location": "Whitefield, Bangalore"
}
```
Returns news about infrastructure developments.

**Response:**
```json
{
  "developments": [
    {
      "title": "New Metro Line Extension to Whitefield",
      "source": "Economic Times",
      "date": "2025-01-15",
      "impact": "positive",
      "summary": "Expected to increase footfall by 40%"
    }
  ],
  "growth_outlook": "bullish"
}
```

---

####  Supply Chain Check
```http
POST /api/supply-chain
Content-Type: application/json

{
  "store_lat": 12.9716,
  "store_lng": 77.5946,
  "warehouse_lat": 13.0827,
  "warehouse_lng": 77.5877
}
```
Returns logistics feasibility analysis.

**Response:**
```json
{
  "distance_km": 18.5,
  "drive_time_minutes": 52,
  "feasibility": "warning",
  "message": "High Logistics Cost - Drive time exceeds 45 minutes",
  "recommendation": "Consider a closer warehouse or factor in higher delivery costs"
}
```

---

##  The Opportunity Score Algorithm

```
Opportunity Score = (Footfall Proxy  Landmark Value) / (Competitor Density + 1)
```

| Factor | Calculation | Weight |
|--------|-------------|--------|
| **Footfall Proxy** | Based on nearby transit, offices, residential density | 0-100 |
| **Landmark Value** | Weighted sum of valuable nearby POIs | 0-50 |
| **Competitor Density** | Count of similar businesses in 1km radius | Divisor |

**Score Interpretation:**
-  **70-100:** Prime Location  Move fast!
-  **40-69:** Moderate Potential  Needs differentiation
-  **0-39:** High Risk  Reconsider or pivot

---

##  Demo

*Screenshots and demo video coming soon!*

---

##  Team

Built with  for [Hackathon Name] 2025

| Role | Name |
|------|------|
| **Product & Architecture** | [Your Name] |
| **Frontend** | [Team Member] |
| **Backend** | [Team Member] |
| **AI/ML** | [Team Member] |

---

##  License

MIT License  Built for the hackathon, open for the community.

---

<div align="center">

** Hotspot IQ  Because your next location decision shouldn't be a gamble.**

[ Back to Top](#-hotspot-iq)

</div>
</file>

<file path="repomix-output.md">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/.env.example
backend/.gitignore
backend/app.py
backend/config.py
backend/requirements.txt
backend/routes/__init__.py
backend/routes/analysis_routes.py
backend/routes/chat_routes.py
backend/routes/location_routes.py
backend/services/__init__.py
backend/services/competitor_service.py
backend/services/latlong_service.py
backend/services/places_service.py
backend/utils/__init__.py
backend/utils/score_calculator.py
DESIGN.md
frontend/.env.example
frontend/.gitignore
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/src/App.jsx
frontend/src/components/Dashboard/AnalysisPanel.jsx
frontend/src/components/Dashboard/Charts/CompetitorChart.jsx
frontend/src/components/Dashboard/Charts/index.js
frontend/src/components/Dashboard/Charts/LandmarkRadar.jsx
frontend/src/components/Dashboard/Charts/ScoreGauge.jsx
frontend/src/components/Dashboard/CompetitorCard.jsx
frontend/src/components/Dashboard/index.js
frontend/src/components/Dashboard/LandmarksCard.jsx
frontend/src/components/Dashboard/LoadingProgress.jsx
frontend/src/components/Dashboard/MetricsGrid.jsx
frontend/src/components/Dashboard/RecommendedSpotsCard.jsx
frontend/src/components/Dashboard/ScoreCard.jsx
frontend/src/components/Filters/BusinessTypeSelector.jsx
frontend/src/components/Filters/index.js
frontend/src/components/Filters/ProximityFilters.jsx
frontend/src/components/Layout/Header.jsx
frontend/src/components/Layout/index.js
frontend/src/components/Map/HeatmapOverlay.jsx
frontend/src/components/Map/index.js
frontend/src/components/Map/MapView.jsx
frontend/src/components/Search/index.js
frontend/src/components/Search/SearchBar.jsx
frontend/src/hooks/index.js
frontend/src/hooks/useAnalysis.js
frontend/src/hooks/useFilters.js
frontend/src/hooks/useLocation.js
frontend/src/index.css
frontend/src/main.jsx
frontend/src/services/api.js
frontend/tailwind.config.js
frontend/vite.config.js
README.md
TASKS.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Dependencies
node_modules/
__pycache__/
*.pyc
venv/
.venv/

# Environment files
.env
.env.local
.env.*.local
*.env

# IDE
.vscode/
.idea/

# Build outputs
dist/
build/

# Logs
*.log
npm-debug.log*

# OS
.DS_Store
Thumbs.db
</file>

<file path="backend/.env.example">
# Hotspot IQ Backend Environment Variables
# Copy this file to .env and fill in your actual API keys

FLASK_ENV=development
FLASK_DEBUG=True
FLASK_PORT=5000

# LatLong.ai API Key (https://latlong.ai)
LATLONG_API_KEY=your_latlong_api_key_here

# OpenAI API Key (https://platform.openai.com)
OPENAI_API_KEY=your_openai_api_key_here

# Frontend URL for CORS
FRONTEND_URL=http://localhost:5173
</file>

<file path="backend/.gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
env/
.venv/

# Environment Variables
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# Logs
*.log
logs/

# Cache
.cache/
*.cache

# OS
.DS_Store
Thumbs.db
</file>

<file path="backend/config.py">
"""
Hotspot IQ - Configuration Module
Loads environment variables and validates API keys on startup.
"""

import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()


class Config:
    """Application configuration class."""
    
    # Flask Settings
    FLASK_ENV = os.getenv('FLASK_ENV', 'development')
    FLASK_DEBUG = os.getenv('FLASK_DEBUG', 'True').lower() == 'true'
    FLASK_PORT = int(os.getenv('FLASK_PORT', 5000))
    
    # API Keys
    LATLONG_API_KEY = os.getenv('LATLONG_API_KEY', '')
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY', '')
    
    # CORS Settings
    FRONTEND_URL = os.getenv('FRONTEND_URL', 'http://localhost:5173')
    
    # LatLong.ai API Base URL (API Hub)
    LATLONG_BASE_URL = 'https://apihub.latlong.ai'
    
    # Default location (Bangalore)
    DEFAULT_LAT = 12.9716
    DEFAULT_LNG = 77.5946
    DEFAULT_RADIUS = 1000  # meters
    
    @classmethod
    def validate(cls):
        """Validate that required API keys are present."""
        errors = []
        
        if not cls.LATLONG_API_KEY or cls.LATLONG_API_KEY == 'your_latlong_api_key_here':
            errors.append('LATLONG_API_KEY is not configured')
        
        if not cls.OPENAI_API_KEY or cls.OPENAI_API_KEY == 'your_openai_api_key_here':
            errors.append('OPENAI_API_KEY is not configured (optional for Phase 1)')
        
        if errors:
            print("  Configuration Warnings:")
            for error in errors:
                print(f"   - {error}")
            print("   Some features may not work without valid API keys.\n")
        else:
            print(" All API keys configured successfully!\n")
        
        return len(errors) == 0


# Business Type to Competitor POI Category Mapping
COMPETITOR_MAPPING = {
    'cafe': ['cafe', 'coffee_shop', 'bakery', 'tea_house'],
    'restaurant': ['restaurant', 'fast_food', 'food_court', 'dhaba'],
    'retail': ['supermarket', 'convenience_store', 'grocery', 'retail'],
    'gym': ['gym', 'fitness_center', 'yoga_studio', 'sports_club'],
    'pharmacy': ['pharmacy', 'medical_store', 'clinic'],
    'salon': ['salon', 'spa', 'beauty_parlor', 'barbershop'],
    'electronics': ['electronics_store', 'mobile_shop', 'computer_store'],
    'clothing': ['clothing_store', 'boutique', 'fashion_store'],
    'bookstore': ['bookstore', 'stationery_shop', 'library'],
    'other': []
}

# Proximity Filter to POI Category Mapping
FILTER_POI_MAPPING = {
    'near_metro': 'metro_station',
    'near_bus': 'bus_stop',
    'near_school': 'school',
    'near_college': 'college',
    'near_hospital': 'hospital',
    'near_mall': 'mall',
    'near_office': 'office',
    'near_residential': 'residential',
    'near_temple': 'temple',
    'near_park': 'park',
    'near_atm': 'atm',
    'near_bar': 'bar'
}

# Landmark weights for score calculation
LANDMARK_WEIGHTS = {
    'metro_station': 15,
    'bus_stop': 5,
    'school': 10,
    'college': 12,
    'hospital': 8,
    'mall': 15,
    'office': 12,
    'residential': 8,
    'temple': 6,
    'park': 5,
    'atm': 4,
    'bar': 7
}
</file>

<file path="backend/routes/__init__.py">
"""
Hotspot IQ - Routes Package
"""

from .location_routes import location_bp
from .analysis_routes import analysis_bp
from .chat_routes import chat_bp

__all__ = ['location_bp', 'analysis_bp', 'chat_bp']
</file>

<file path="backend/routes/chat_routes.py">
"""
Hotspot IQ - Chat Routes
Handles AI-powered chat endpoints.
"""

from flask import Blueprint, request, jsonify
from services.latlong_service import latlong_service
from utils.score_calculator import analyze_location
from config import Config

chat_bp = Blueprint('chat', __name__)


def generate_context_prompt(location_data: dict, user_question: str) -> str:
    """Generate a context-rich prompt for the AI."""
    
    context = f"""You are Hotspot IQ, an expert location intelligence advisor for businesses in India.
    
LOCATION DATA:
- Coordinates: {location_data.get('lat')}, {location_data.get('lng')}
- Address: {location_data.get('address', {}).get('formatted_address', 'N/A')}
- Business Type: {location_data.get('business_type', 'Not specified')}

ANALYSIS RESULTS:
- Opportunity Score: {location_data.get('opportunity_score', 'N/A')}/100
- Score Category: {location_data.get('interpretation', {}).get('category', 'N/A')}
- Footfall Level: {location_data.get('footfall_proxy', 'N/A')}
- Competitor Count: {location_data.get('competitors', {}).get('count', 0)} nearby

LANDMARKS NEARBY:
{_format_landmarks(location_data.get('landmarks', {}).get('by_category', {}))}

USER QUESTION: {user_question}

Please provide a helpful, actionable response based on this data. Be specific and use the numbers provided.
Keep your response concise (2-3 paragraphs max) and practical for a business owner."""
    
    return context


def _format_landmarks(landmarks: dict) -> str:
    """Format landmarks dict into readable string."""
    if not landmarks:
        return "No landmark data available"
    
    lines = []
    for category, count in landmarks.items():
        readable_name = category.replace('_', ' ').title()
        lines.append(f"- {readable_name}: {count}")
    
    return '\n'.join(lines) if lines else "No landmarks detected"


@chat_bp.route('/chat', methods=['POST'])
def chat():
    """
    POST /api/chat
    
    AI-powered location advice chat.
    
    Request body:
    {
        "message": "Is this location good for a gym?",
        "context": {
            "lat": 12.9716,
            "lng": 77.5946,
            "business_type": "gym",
            "analysis_data": {...}  // Optional, pre-fetched analysis
        }
    }
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    message = data.get('message', '')
    context = data.get('context', {})
    
    if not message:
        return jsonify({'error': 'message is required'}), 400
    
    lat = context.get('lat')
    lng = context.get('lng')
    business_type = context.get('business_type', 'other')
    
    # If we have coordinates but no analysis data, fetch it
    analysis_data = context.get('analysis_data')
    
    if lat and lng and not analysis_data:
        # Fetch fresh analysis data
        competitors = latlong_service.get_competitors(lat, lng, business_type)
        filters = ['near_metro', 'near_bus', 'near_school', 'near_college', 
                   'near_hospital', 'near_mall', 'near_office']
        landmarks = latlong_service.get_landmarks(lat, lng, filters)
        address_info = latlong_service.reverse_geocode(lat, lng)
        
        analysis_result = analyze_location(landmarks, competitors, business_type)
        
        analysis_data = {
            'lat': lat,
            'lng': lng,
            'address': address_info,
            'business_type': business_type,
            'opportunity_score': analysis_result['opportunity_score'],
            'interpretation': analysis_result['interpretation'],
            'footfall_proxy': 'high' if analysis_result['breakdown']['footfall_proxy'] > 60 else 'medium' if analysis_result['breakdown']['footfall_proxy'] > 30 else 'low',
            'competitors': analysis_result['competitors'],
            'landmarks': {
                'by_category': analysis_result['landmarks_summary']
            }
        }
    
    # Check if OpenAI is configured
    if not Config.OPENAI_API_KEY or Config.OPENAI_API_KEY == 'your_openai_api_key_here':
        # Return a template response without AI
        response_text = _generate_template_response(message, analysis_data)
        return jsonify({
            'response': response_text,
            'data_sources': ['poi', 'landmarks', 'competitors'],
            'ai_powered': False
        })
    
    # Generate AI response using OpenAI
    try:
        import openai
        client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)
        
        prompt = generate_context_prompt(analysis_data or {}, message)
        
        completion = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": "You are Hotspot IQ, a helpful location intelligence advisor."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=500,
            temperature=0.7
        )
        
        response_text = completion.choices[0].message.content
        
        return jsonify({
            'response': response_text,
            'data_sources': ['poi', 'landmarks', 'competitors'],
            'ai_powered': True
        })
        
    except Exception as e:
        print(f"OpenAI API Error: {str(e)}")
        # Fallback to template response
        response_text = _generate_template_response(message, analysis_data)
        return jsonify({
            'response': response_text,
            'data_sources': ['poi', 'landmarks', 'competitors'],
            'ai_powered': False,
            'error': 'AI service temporarily unavailable'
        })


def _generate_template_response(message: str, analysis_data: dict) -> str:
    """Generate a template response when AI is not available."""
    
    if not analysis_data:
        return "Please select a location on the map first so I can analyze it for you."
    
    score = analysis_data.get('opportunity_score', 0)
    category = analysis_data.get('interpretation', {}).get('category', 'Unknown')
    competitors = analysis_data.get('competitors', {}).get('count', 0)
    footfall = analysis_data.get('footfall_proxy', 'unknown')
    business_type = analysis_data.get('business_type', 'business')
    
    message_lower = message.lower()
    
    if 'good' in message_lower or 'suitable' in message_lower:
        if score >= 70:
            return f"Based on the data, this location shows **strong potential** for a {business_type}. With an Opportunity Score of {score}/100, you're looking at a prime location. There are {competitors} competitors nearby, and footfall appears to be {footfall}. I'd recommend moving quickly on this opportunity!"
        elif score >= 40:
            return f"This location has **moderate potential** for a {business_type}, scoring {score}/100. With {competitors} competitors in the area and {footfall} footfall, you'll need a strong differentiation strategy. Consider what unique value you can offer."
        else:
            return f"This location shows some **challenges** for a {business_type}, with a score of {score}/100. High competition ({competitors} nearby) or low footfall ({footfall}) could make success difficult. I'd recommend exploring alternative locations."
    
    elif 'competition' in message_lower or 'competitor' in message_lower:
        return f"There are **{competitors} competitors** (similar {business_type}s) within 1km of this location. {'This is a competitive area - differentiation will be key.' if competitors > 5 else 'Competition is manageable - focus on great service and location visibility.'}"
    
    elif 'landmark' in message_lower or 'nearby' in message_lower:
        landmarks = analysis_data.get('landmarks', {}).get('by_category', {})
        if landmarks:
            landmark_text = ', '.join([f"{count} {cat.replace('_', ' ')}s" for cat, count in landmarks.items() if count > 0])
            return f"Nearby landmarks include: **{landmark_text}**. These contribute to the footfall and accessibility of your location."
        return "I don't have detailed landmark data for this location yet."
    
    else:
        return f"This location has an Opportunity Score of **{score}/100** ({category}). There are {competitors} competitors nearby and {footfall} footfall. What specific aspect would you like me to analyze further?"
</file>

<file path="backend/routes/location_routes.py">
"""
Hotspot IQ - Location Routes
Handles autocomplete, reverse geocoding, and digipin endpoints.
"""

from flask import Blueprint, request, jsonify
from services.latlong_service import latlong_service

location_bp = Blueprint('location', __name__)


@location_bp.route('/autocomplete', methods=['GET'])
def autocomplete():
    """
    GET /api/autocomplete?query={search_term}&lat={lat}&lng={lng}&limit={limit}
    
    Returns location suggestions for autocomplete dropdown.
    
    LatLong API returns:
    {
        "data": [
            { "name": "Delhi, South West Delhi, Delhi", "geoid": 188443 }
        ]
    }
    
    Note: Autocomplete results don't include coordinates.
    For coordinates, use the geocode endpoint with the location name.
    """
    query = request.args.get('query', '')
    limit = request.args.get('limit', 10, type=int)
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    
    if len(query) < 2:
        return jsonify({'suggestions': []})
    
    suggestions = latlong_service.autocomplete(query, lat, lng, limit)
    
    return jsonify({'suggestions': suggestions})


@location_bp.route('/geocode', methods=['GET'])
def geocode():
    """
    GET /api/geocode?address={address}
    
    Returns coordinates from an address.
    Use this after autocomplete to get lat/lng for a location.
    """
    address = request.args.get('address', '')
    
    if not address:
        return jsonify({'error': 'address parameter is required'}), 400
    
    result = latlong_service.geocode(address)
    
    if 'error' in result:
        return jsonify({'error': 'Could not geocode address'}), 404
    
    return jsonify(result)


@location_bp.route('/reverse-geocode', methods=['GET'])
def reverse_geocode():
    """
    GET /api/reverse-geocode?lat={lat}&lng={lng}
    
    Returns address details from coordinates.
    """
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng parameters are required'}), 400
    
    result = latlong_service.reverse_geocode(lat, lng)
    
    return jsonify(result)


@location_bp.route('/digipin', methods=['GET'])
def get_digipin():
    """
    GET /api/digipin?lat={lat}&lng={lng}
    
    Returns Digipin (Digital Address Code) for a location.
    """
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng parameters are required'}), 400
    
    result = latlong_service.get_digipin(lat, lng)
    
    return jsonify(result)
</file>

<file path="backend/services/places_service.py">
"""
Hotspot IQ - Places Service
Fetches nearby businesses using OpenStreetMap Overpass API.
Provides clean, reliable competitor data for heatmap generation.
"""

import overpy
import time
from typing import List, Dict, Optional


# Category mapping: user keywords -> OpenStreetMap tags
CATEGORY_MAPPING: Dict[str, Dict[str, str]] = {
    "cafe": {"amenity": "cafe"},
    "restaurant": {"amenity": "restaurant"},
    "hotel": {"tourism": "hotel"},
    "pharmacy": {"amenity": "pharmacy"},
    "hospital": {"amenity": "hospital"},
    "gym": {"leisure": "fitness_centre"},
    # Extended categories for better coverage
    "fast_food": {"amenity": "fast_food"},
    "bar": {"amenity": "bar"},
    "bakery": {"shop": "bakery"},
    "supermarket": {"shop": "supermarket"},
    "bank": {"amenity": "bank"},
    "atm": {"amenity": "atm"},
    "school": {"amenity": "school"},
    "college": {"amenity": "college"},
    "clinic": {"amenity": "clinic"},
    "salon": {"shop": "hairdresser"},
    "beauty": {"shop": "beauty"},
}

# Alternative Overpass API endpoints (in case main one is rate limited)
OVERPASS_ENDPOINTS = [
    "https://overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter", 
    "https://maps.mail.ru/osm/tools/overpass/api/interpreter",
]


def _build_query(lat: float, lng: float, radius: int, tag_key: str, tag_value: str) -> str:
    """
    Build an Overpass QL query for nodes, ways, and relations.
    
    Args:
        lat: Latitude of center point
        lng: Longitude of center point
        radius: Search radius in meters
        tag_key: OSM tag key (e.g., "amenity")
        tag_value: OSM tag value (e.g., "cafe")
        
    Returns:
        Overpass QL query string
    """
    query = f"""
    [out:json][timeout:10];
    (
        node["{tag_key}"="{tag_value}"](around:{radius},{lat},{lng});
        way["{tag_key}"="{tag_value}"](around:{radius},{lat},{lng});
        relation["{tag_key}"="{tag_value}"](around:{radius},{lat},{lng});
    );
    out center;
    """
    return query


def fetch_nearby_places(
    lat: float, 
    lng: float, 
    radius: int = 1000, 
    category: str = "cafe",
    max_retries: int = 3
) -> List[Dict]:
    """
    Fetch nearby places of a specific category using OpenStreetMap Overpass API.
    Includes retry logic with multiple API endpoints to handle rate limiting.
    
    Args:
        lat: Latitude of the center point
        lng: Longitude of the center point
        radius: Search radius in meters (default: 1000m)
        category: Business category keyword (default: "cafe")
        max_retries: Maximum retry attempts (default: 3)
        
    Returns:
        List of places with name, lat, lng, and type.
        Only returns places that have a name.
        
    Example:
        places = fetch_nearby_places(12.9716, 77.5946, 2500, "cafe")
        # Returns: [{"name": "Starbucks", "lat": 12.97, "lng": 77.59, "type": "cafe"}, ...]
    """
    # Get OSM tag for the category
    tag_info = CATEGORY_MAPPING.get(category.lower())
    
    if not tag_info:
        print(f" Unknown category '{category}', defaulting to amenity search")
        tag_key = "amenity"
        tag_value = category.lower()
    else:
        tag_key = list(tag_info.keys())[0]
        tag_value = list(tag_info.values())[0]
    
    # Build the query
    query = _build_query(lat, lng, radius, tag_key, tag_value)
    
    # Try each endpoint with retries
    last_error = None
    for endpoint_idx, endpoint in enumerate(OVERPASS_ENDPOINTS):
        for attempt in range(max_retries):
            try:
                # Create Overpass API instance with specific endpoint
                api = overpy.Overpass(url=endpoint)
                
                # Add delay between retries to avoid rate limiting
                if attempt > 0:
                    delay = 2 ** attempt  # Exponential backoff: 2, 4, 8 seconds
                    print(f" Waiting {delay}s before retry {attempt + 1}...")
                    time.sleep(delay)
                
                result = api.query(query)
                
                places = []
                
                # Process nodes (points)
                for node in result.nodes:
                    name = node.tags.get("name")
                    if name:  # Only include places with names
                        places.append({
                            "name": name,
                            "lat": float(node.lat),
                            "lng": float(node.lon),
                            "type": category
                        })
                
                # Process ways (buildings/areas) - use center coordinates
                for way in result.ways:
                    name = way.tags.get("name")
                    if name and way.center_lat and way.center_lon:
                        places.append({
                            "name": name,
                            "lat": float(way.center_lat),
                            "lng": float(way.center_lon),
                            "type": category
                        })
                
                # Process relations - use center if available
                for relation in result.relations:
                    name = relation.tags.get("name")
                    if name:
                        rel_lat = getattr(relation, 'center_lat', None)
                        rel_lng = getattr(relation, 'center_lon', None)
                        if rel_lat and rel_lng:
                            places.append({
                                "name": name,
                                "lat": float(rel_lat),
                                "lng": float(rel_lng),
                                "type": category
                            })
                
                print(f" Found {len(places)} {category}(s) within {radius}m radius")
                return places
                
            except overpy.exception.OverpassTooManyRequests:
                last_error = "Rate limited"
                print(f" Rate limited on endpoint {endpoint_idx + 1}, attempt {attempt + 1}")
                continue
                
            except overpy.exception.OverpassGatewayTimeout:
                last_error = "Timeout"
                print(f" Timeout on endpoint {endpoint_idx + 1}, attempt {attempt + 1}")
                continue
                
            except Exception as e:
                last_error = str(e)
                print(f" Error on endpoint {endpoint_idx + 1}: {e}")
                break  # Move to next endpoint on other errors
    
    print(f" All Overpass API attempts failed: {last_error}")
    return []


def fetch_competitors(
    lat: float, 
    lng: float, 
    radius: int, 
    business_type: str
) -> List[Dict]:
    """
    Fetch competitors for a specific business type.
    This is an alias for fetch_nearby_places with business-focused naming.
    
    For cafes, also searches for coffee shops and fast food places.
    For restaurants, also searches for fast food.
    
    Args:
        lat: Latitude
        lng: Longitude
        radius: Search radius in meters
        business_type: Type of business (cafe, restaurant, gym, etc.)
        
    Returns:
        List of competitor places with name, lat, lng, type
    """
    competitors = []
    seen_names = set()  # Avoid duplicates
    
    # Primary category
    primary_places = fetch_nearby_places(lat, lng, radius, business_type)
    for place in primary_places:
        name_key = place["name"].lower()
        if name_key not in seen_names:
            seen_names.add(name_key)
            competitors.append(place)
    
    # Extended search for related categories
    related_categories = {
        "cafe": ["fast_food", "bakery"],
        "restaurant": ["fast_food"],
        "gym": [],
        "pharmacy": ["clinic"],
        "hotel": [],
        "hospital": ["clinic"],
        "salon": ["beauty"],
    }
    
    extra_categories = related_categories.get(business_type.lower(), [])
    for extra_cat in extra_categories:
        extra_places = fetch_nearby_places(lat, lng, radius, extra_cat)
        for place in extra_places:
            name_key = place["name"].lower()
            if name_key not in seen_names:
                seen_names.add(name_key)
                # Mark with original business type for consistency
                place["type"] = business_type
                competitors.append(place)
    
    print(f" Total competitors found: {len(competitors)}")
    return competitors


def fetch_landmarks(lat: float, lng: float, radius: int) -> List[Dict]:
    """
    Fetch various landmark types for area analysis.
    
    Args:
        lat: Latitude
        lng: Longitude
        radius: Search radius in meters
        
    Returns:
        List of landmarks with name, lat, lng, type
    """
    landmark_categories = ["school", "college", "hospital", "bank", "atm"]
    
    landmarks = []
    seen_names = set()
    
    for category in landmark_categories:
        places = fetch_nearby_places(lat, lng, radius, category)
        for place in places:
            name_key = place["name"].lower()
            if name_key not in seen_names:
                seen_names.add(name_key)
                landmarks.append(place)
    
    print(f" Total landmarks found: {len(landmarks)}")
    return landmarks


# Convenience functions for common use cases
def get_cafes(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all cafes within radius."""
    return fetch_competitors(lat, lng, radius, "cafe")


def get_restaurants(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all restaurants within radius."""
    return fetch_competitors(lat, lng, radius, "restaurant")


def get_gyms(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all gyms within radius."""
    return fetch_competitors(lat, lng, radius, "gym")


def get_pharmacies(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all pharmacies within radius."""
    return fetch_competitors(lat, lng, radius, "pharmacy")
</file>

<file path="backend/utils/__init__.py">
"""
Hotspot IQ - Utils Package
"""

from .score_calculator import (
    calculate_footfall_proxy,
    calculate_landmark_value,
    calculate_competitor_density,
    calculate_opportunity_score,
    get_score_interpretation,
    analyze_location
)

__all__ = [
    'calculate_footfall_proxy',
    'calculate_landmark_value',
    'calculate_competitor_density',
    'calculate_opportunity_score',
    'get_score_interpretation',
    'analyze_location'
]
</file>

<file path="DESIGN.md">
#  Hotspot IQ  Design Specification Document

> **Version:** 1.0  
> **Last Updated:** November 29, 2025  
> **Status:** Source of Truth for Frontend Development

---

## Table of Contents

1. [Visual Identity & Philosophy](#1-visual-identity--philosophy)
2. [The Color System](#2-the-color-system)
3. [Component Architecture](#3-component-architecture)
4. [Data Visualization Guidelines](#4-data-visualization-guidelines)
5. [Typography & Motion](#5-typography--motion)
6. [Spacing & Grid System](#6-spacing--grid-system)
7. [Responsive Behavior](#7-responsive-behavior)
8. [Accessibility Guidelines](#8-accessibility-guidelines)

---

## 1. Visual Identity & Philosophy

### 1.1 The Aesthetic: "Cyber-Enterprise"

Hotspot IQ embodies a **"Cyber-Enterprise"** aestheticthe sophisticated credibility of enterprise SaaS fused with the electric energy of cyberpunk interfaces. Think: *What if Mapbox Studio was redesigned by the UI team from Cyberpunk 2077?*

**Visual Anchors:**
| Inspiration | What We Take From It |
|-------------|---------------------|
| **Mapbox Studio** | Map-first layouts, floating control panels, dark canvas |
| **Vercel Dashboard** | Clean typography, subtle gradients, professional spacing |
| **Cyberpunk 2077** | Neon accents, scan-line effects, data-dense HUDs |
| **Bloomberg Terminal** | Information density, real-time updates, serious tone |

### 1.2 The Three Design Pillars

####  Pillar 1: "Dark Mode as Default"

The interface is **permanently dark**. There is no light mode toggledarkness is the product identity.

**Rationale:**
- Maps are the hero. Dark backgrounds make colorful map data pop.
- Reduces eye strain during extended analysis sessions.
- Conveys technical sophistication and premium positioning.
- Neon data points create instant visual hierarchy.

**Implementation:**
- The deepest background (`Canvas`) should feel like looking into space.
- All panels float above this void, creating depth through layering.
- Light elements (text, icons, data points) feel like they're *emitting* light, not reflecting it.

---

####  Pillar 2: "Glassmorphism  The Map Never Hides"

All UI panels use **glassmorphism**translucent surfaces with backdrop blur that allow the map to remain visible at all times.

**Rationale:**
- The map IS the product. Covering it with opaque panels defeats the purpose.
- Users maintain spatial context while reading data.
- Creates a sense of floating, futuristic HUD overlays.
- Reinforces the "intelligence layer on top of geography" metaphor.

**Implementation Rules:**
```

  GLASSMORPHISM RECIPE                                       

  Background:    rgba(15, 23, 42, 0.80)  /* Slate-900 @ 80% */
  Backdrop Blur: blur(12px)                                  
  Border:        1px solid rgba(255, 255, 255, 0.08)         
  Border Radius: 16px (panels) / 12px (cards) / 8px (inputs)
  Shadow:        0 8px 32px rgba(0, 0, 0, 0.4)              

```

**The Opacity Hierarchy:**
| Layer | Opacity | Use Case |
|-------|---------|----------|
| **Primary Panels** | 80% | Sidebar, Main Dashboard |
| **Secondary Cards** | 70% | Score cards, Stat blocks |
| **Tertiary Overlays** | 60% | Tooltips, Dropdowns |
| **Ghost Elements** | 40% | Disabled states, Placeholders |

---

####  Pillar 3: "Reactive  The Interface Breathes"

The UI is **reactive**it responds instantly to user input without waiting for explicit submissions.

**Rationale:**
- Location intelligence is exploratory. Users want to "play" with the map.
- Immediate feedback creates a sense of power and control.
- Reduces friction between thought and action.
- Makes the product feel alive and intelligent.

**Implementation Rules:**

| Interaction | Expected Behavior |
|-------------|-------------------|
| **Typing in Search** | Autocomplete appears after 2 characters, updates on every keystroke (debounced 300ms) |
| **Selecting Location** | Map flies to location, marker appears, analysis begins automatically |
| **Changing Filters** | Dashboard recalculates immediately, cards animate to new values |
| **Hovering Map Pins** | Tooltip fades in (150ms), pin scales up (1.2x) |
| **Adjusting Isochrone** | Polygon redraws in real-time as slider moves |

**The "No Submit Button" Rule:**
Wherever possible, eliminate explicit "Submit" or "Go" buttons. The interface should:
1. Detect user intent from input
2. Begin processing immediately
3. Show loading state inline
4. Resolve with animated result

*Exception: The main "Analyze Location" action retains a button for deliberate, high-stakes actions.*

---

## 2. The Color System

### 2.1 Philosophy: Semantic, Not Decorative

Colors in Hotspot IQ are **functional signals**, not aesthetic choices. Every color communicates meaning.

```

  "If a color doesn't mean something, it shouldn't exist."  

```

### 2.2 The Semantic Palette

####  CANVAS  The Void (Background Layer)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--canvas-deep` | `#020617` | `slate-950` | `rgb(2, 6, 23)` |
| `--canvas-base` | `#0f172a` | `slate-900` | `rgb(15, 23, 42)` |

**When to Use:**
- `canvas-deep`: The absolute background. The map container. The void behind everything.
- `canvas-base`: Secondary backgrounds, input fields, code blocks.

**Never Use For:** Text, icons, or anything that needs to be "seen."

---

####  SURFACE  The Glass Layers

| Token | Hex + Opacity | Tailwind | Usage |
|-------|---------------|----------|-------|
| `--surface-primary` | `#0f172a` @ 80% | `slate-900/80` | Main panels (Sidebar, Dashboard) |
| `--surface-secondary` | `#1e293b` @ 70% | `slate-800/70` | Cards within panels |
| `--surface-elevated` | `#334155` @ 60% | `slate-700/60` | Hover states, Active items |
| `--surface-border` | `#ffffff` @ 8% | `white/8` | All panel/card borders |

**When to Use:**
- Wrap all floating UI in `surface-primary`.
- Nest cards inside panels using `surface-secondary`.
- Use `surface-elevated` for interactive hover/focus states.

**The Golden Rule:** Surfaces are always semi-transparent. If you're reaching for an opaque color, you're doing it wrong.

---

####  PRIMARY  The Neon Emerald (Action & Success)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--primary-glow` | `#10b981` | `emerald-500` | `rgb(16, 185, 129)` |
| `--primary-bright` | `#34d399` | `emerald-400` | `rgb(52, 211, 153)` |
| `--primary-soft` | `#10b981` @ 20% | `emerald-500/20` | Backgrounds, Fills |
| `--primary-pulse` | `#10b981` @ 50% | `emerald-500/50` | Glows, Shadows |

**When to Use:**
- **Primary CTA buttons:** "Analyze Location", "Get Insights"
- **Positive scores:** Opportunity Score  70
- **Success states:** "Location Added", "Analysis Complete"
- **Active navigation:** Selected menu items
- **Data highlights:** Important numbers, charts ascending

**Glow Effect Recipe:**
```css
.primary-glow {
  box-shadow: 
    0 0 20px rgba(16, 185, 129, 0.4),
    0 0 40px rgba(16, 185, 129, 0.2),
    0 0 60px rgba(16, 185, 129, 0.1);
}
```

---

####  WARNING  The Amber Signal (Caution)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--warning-glow` | `#f59e0b` | `amber-500` | `rgb(245, 158, 11)` |
| `--warning-soft` | `#f59e0b` @ 20% | `amber-500/20` | Backgrounds |

**When to Use:**
- **Medium scores:** Opportunity Score 40-69
- **Caution alerts:** "Moderate competition detected"
- **Pending states:** "Calculating...", "Loading data"
- **Attention flags:** Items that need review

---

####  DESTRUCTIVE  The Neon Rose (Danger & Errors)

| Token | Hex | Tailwind | RGB |
|-------|-----|----------|-----|
| `--destructive-glow` | `#f43f5e` | `rose-500` | `rgb(244, 63, 94)` |
| `--destructive-bright` | `#fb7185` | `rose-400` | `rgb(251, 113, 133)` |
| `--destructive-soft` | `#f43f5e` @ 20% | `rose-500/20` | Backgrounds |

**When to Use:**
- **Low scores:** Opportunity Score < 40
- **Saturation warnings:** "High competitor density!"
- **Error states:** API failures, Invalid inputs
- **Negative trends:** Charts descending, Bad metrics
- **Destructive actions:** "Remove location", "Clear all"

---

####  TEXT  The Light Spectrum

| Token | Hex | Tailwind | Opacity | Usage |
|-------|-----|----------|---------|-------|
| `--text-primary` | `#f8fafc` | `slate-50` | 100% | Headlines, Key data, CTAs |
| `--text-secondary` | `#cbd5e1` | `slate-300` | 85% | Body text, Descriptions |
| `--text-tertiary` | `#64748b` | `slate-500` | 60% | Metadata, Timestamps, Labels |
| `--text-disabled` | `#475569` | `slate-600` | 40% | Disabled inputs, Placeholders |

**Hierarchy Rules:**
1. Only ONE piece of information per screen should use `text-primary` (usually the score or key metric).
2. Supporting information uses `text-secondary`.
3. Metadata (dates, IDs, labels) uses `text-tertiary`.
4. Never use pure white (`#ffffff`)it's too harsh on dark backgrounds.

---

####  ACCENT  The Cyan Highlight (Information)

| Token | Hex | Tailwind | Usage |
|-------|-----|----------|-------|
| `--accent-cyan` | `#06b6d4` | `cyan-500` | Links, Info icons, Neutral highlights |
| `--accent-violet` | `#8b5cf6` | `violet-500` | AI/Chat features, Special badges |

**When to Use:**
- `accent-cyan`: Hyperlinks, informational tooltips, neutral data points.
- `accent-violet`: AI-generated content, "Ask Hotspot" chat, premium features.

---

### 2.3 Color Application Matrix

| Element | Background | Border | Text | Icon |
|---------|------------|--------|------|------|
| **Panel** | `surface-primary` | `surface-border` |  |  |
| **Card** | `surface-secondary` | `surface-border` |  |  |
| **Primary Button** | `primary-glow` | `primary-bright` | `canvas-deep` | `canvas-deep` |
| **Ghost Button** | `transparent` | `surface-border` | `text-secondary` | `text-tertiary` |
| **Input Field** | `canvas-base` | `surface-border` | `text-primary` | `text-tertiary` |
| **Input Focused** | `canvas-base` | `primary-glow` | `text-primary` | `primary-glow` |
| **Score High** | `primary-soft` | `primary-glow` | `primary-bright` |  |
| **Score Medium** | `warning-soft` | `warning-glow` | `warning-glow` |  |
| **Score Low** | `destructive-soft` | `destructive-glow` | `destructive-bright` |  |

---

## 3. Component Architecture

### 3.1 The Layered Interface Model

Hotspot IQ uses a **Z-axis layered architecture**. Think of the interface as stacked transparent sheets of glass:

```

  Z-INDEX STACK (Bottom to Top)                              

                                                             
  z-50    MODAL LAYER (Dialogs, Alerts)          
                                                  
                                                             
  z-40    CHAT WIDGET (Floating FAB)             
                                                  
                                                             
  z-30                   
              DATA HUD (Score Cards)                       
                         
                                                             
  z-20                                             
        CONTROL  CONTROL DECK (Sidebar)                   
         DECK                                             
                                                   
                                                             
  z-10   
                      MAP OVERLAYS                         
            (Markers, Isochrones, Heatmaps)               
         
                                                             
  z-0    
                                                          
                      THE MAP CANVAS                      
                   (100% width  100% height)             
                                                          
         
                                                             

```

---

### 3.2 The Map Canvas (`z-0`)

**Role:** The foundational layer. The reason users come to Hotspot IQ.

**Specifications:**
| Property | Value | Rationale |
|----------|-------|-----------|
| **Position** | `fixed`, `inset-0` | Covers entire viewport |
| **Dimensions** | `100vw  100vh` | Edge to edge |
| **Tile Style** | Dark/Monochrome | Reduces visual noise |
| **Default Center** | `12.9716, 77.5946` (Bangalore) | Indian market focus |
| **Default Zoom** | `13` | Neighborhood level |
| **Interaction** | Pan, Zoom, Click-to-select | Always interactive |

**Map Style Guidelines:**
- Use a **dark basemap** (Mapbox Dark, CartoDB Dark Matter, or custom).
- Desaturate colors so data overlays pop.
- Road labels should be `text-tertiary` color.
- Water bodies should be `canvas-deep` (near black).
- Parks/green spaces should be a muted dark teal.

**The Map is Never Blocked:**
- No panel should exceed 400px width.
- No panel should exceed 70% viewport height.
- Users must always be able to see at least 50% of the map.

---

### 3.3 The Control Deck (`z-20`)  Left Sidebar

**Role:** The command center. Where users input their intent.

**Position:** Fixed left, vertically centered.

```

  CONTROL DECK ANATOMY                  

                                        
    
     HOTSPOT IQ                        Logo/Brand
       Location Intelligence          
    
                                        
    
    STEP 1: What are you opening?       Section Label
        
      Cafe / Coffee Shop            Business Type Dropdown
        
    
                                        
    
    STEP 2: What do you need nearby?     Section Label
          
     Metro  School  College       Filter Chips
              (Multi-select)
          
     Hosp  Mall   Office    
          
          
     ATM   Bar    Temple    
          
    
                                        
    
    STEP 3: Where do you want to open?    Section Label
     Search Location...                Autocomplete Input
        
     Indiranagar, Bangalore            Suggestion Item
     Indira Nagar Metro Station     
     Indirapuram, Ghaziabad         
        
    
                                        
    
     ANALYZE LOCATION                   Primary CTA (Glowing)
    
                                        
    
     Digipin: J7Q4-M2X9               Location ID (Copyable)
    
                                        

```

**Specifications:**
| Property | Value |
|----------|-------|
| **Width** | `360px` (desktop), `100%` (mobile drawer) |
| **Height** | Auto, max `calc(100vh - 48px)` |
| **Position** | `fixed`, `left: 24px`, `top: 50%`, `transform: translateY(-50%)` |
| **Background** | `surface-primary` (glassmorphism) |
| **Border Radius** | `16px` |
| **Padding** | `24px` |
| **Gap** | `16px` between sections |

**Interaction States:**
- Panel can be collapsed to icon-only mode (hamburger toggle).
- On mobile, becomes a bottom drawer (swipe up to expand).

---

### 3.3.1 User Input Components (Control Deck Details)

The Control Deck follows a **strict sequential flow**. Users must complete each step before proceeding.

#### Component A: Business Type Selector

**Purpose:** Determines what category of business the user is opening. This selection defines which POIs are treated as **competitors**.

```

  BUSINESS TYPE DROPDOWN                                     

                                                             
  CLOSED STATE:                                              
     
     What are you opening?                              
          
       Cafe / Coffee Shop                           
          
     
                                                             
  OPEN STATE (Dropdown Expanded):                           
     
       Cafe / Coffee Shop                  Selected 
       Restaurant / Fast Food                        
       Retail Store                                  
       Gym / Fitness Center                          
       Pharmacy / Medical                            
       Salon / Spa                                   
       Electronics Store                             
       Clothing / Fashion                            
       Bookstore / Stationery                        
       Other (Custom)...                             
     
                                                             

```

**Specifications:**
| Property | Value |
|----------|-------|
| **Height** | `48px` (closed), auto (open) |
| **Background** | `canvas-base` |
| **Border** | `1px solid surface-border` |
| **Border (Focus)** | `1px solid primary-glow` + glow shadow |
| **Border Radius** | `8px` |
| **Icon Size** | `20px` (emoji/icon) |
| **Font** | `text-body`, `text-primary` |
| **Dropdown Shadow** | `0 8px 24px rgba(0,0,0,0.4)` |

**States:**
| State | Visual Treatment |
|-------|------------------|
| **Empty/Placeholder** | "Select business type..." in `text-tertiary` |
| **Hover** | Background lightens to `surface-secondary` |
| **Open** | Border glows `primary-glow`, dropdown appears |
| **Selected** | Shows icon + business name, checkmark in dropdown |
| **Error** | Red border, "Please select a business type" below |

**Competitor Mapping (Data Logic):**
```
Business Type           Competitor POI Categories

 Cafe / Coffee Shop   cafe, coffee_shop, bakery, tea_house
 Restaurant          restaurant, fast_food, food_court, dhaba
 Retail Store         supermarket, convenience_store, grocery
 Gym / Fitness        gym, fitness_center, yoga_studio, sports_club
 Pharmacy             pharmacy, medical_store, clinic
 Salon / Spa          salon, spa, beauty_parlor, barbershop
 Electronics          electronics_store, mobile_shop, computer_store
 Clothing             clothing_store, boutique, fashion_store
 Bookstore            bookstore, stationery_shop, library
 Other                User enters custom POI category
```

---

#### Component B: Proximity Preference Filters

**Purpose:** User selects what landmarks/amenities they want **nearby**. These add bonus points to the Opportunity Score and filter the map display.

```

  PROXIMITY FILTER CHIPS                                     

                                                             
  Section Label: "What do you want nearby?" (text-secondary) 
                                                             
  CHIP GRID (3 columns, wrapping):                          
     
            
      Metro       School      College        
       [Active]     [Inactive]    [Active]         
            
                                                          
            
      Hospital    Mall        Office         
      [Inactive]    [Inactive]    [Active]         
            
                                                          
            
      Resident    Temple      Park           
      [Inactive]    [Inactive]    [Inactive]       
            
                                                          
            
      ATM/Bank    Bar/Pub     Bus Stop       
      [Inactive]    [Inactive]    [Inactive]       
            
                                                          
             
      Select Popular     Clear All               
             
     
                                                             

```

**Available Filter Options:**
| Filter | Icon | POI Category | Score Bonus |
|--------|------|--------------|-------------|
| Metro Station |  | `metro_station` | +15 |
| Bus Stop |  | `bus_stop` | +5 |
| School |  | `school` | +10 |
| College/University |  | `college`, `university` | +12 |
| Hospital |  | `hospital`, `clinic` | +8 |
| Mall/Shopping |  | `mall`, `shopping_center` | +15 |
| Office/IT Park |  | `office`, `it_park`, `business_center` | +12 |
| Residential Area |  | `residential`, `apartment_complex` | +8 |
| Temple/Religious |  | `temple`, `mosque`, `church`, `gurudwara` | +6 |
| Park/Recreation |  | `park`, `playground`, `garden` | +5 |
| ATM/Bank |  | `atm`, `bank` | +4 |
| Bar/Pub |  | `bar`, `pub`, `nightclub` | +7 |

**Chip Specifications:**
| Property | Inactive State | Active State |
|----------|----------------|--------------|
| **Background** | `transparent` | `primary-soft` |
| **Border** | `1px solid surface-border` | `1px solid primary-glow` |
| **Text Color** | `text-tertiary` | `text-primary` |
| **Icon Opacity** | 60% | 100% |
| **Shadow** | None | `0 0 12px primary-pulse` |
| **Padding** | `8px 12px` | `8px 12px` |
| **Border Radius** | `20px` (pill shape) | `20px` |
| **Transition** | `all 200ms ease-out` |  |

**Interaction:**
- Click to toggle (multi-select allowed)
- Active chips glow with neon green
- "Select Popular" pre-selects: Metro, College, Office, Mall
- "Clear All" deselects all chips

---

#### Component C: Location Search (Autocomplete)

Appears **after** Business Type and Filters. See main Search specification above.

---

#### Input Flow Validation

The Control Deck enforces a **progressive disclosure** pattern:

```

  VALIDATION STATES                                          

                                                             
  STATE 1: Initial (Nothing Selected)                       
     
    Step 1: Business Type    [ Select...  ]            
    Step 2: Nearby Filters   [  Disabled/Dimmed  ]        
    Step 3: Search Location  [  Disabled/Dimmed  ]        
    [ ANALYZE LOCATION ]     [  Disabled/Grey   ]         
     
                                                             
  STATE 2: Business Type Selected                           
     
    Step 1: Business Type    [  Cafe     ]            
    Step 2: Nearby Filters   [  Now Active!    ]        
    Step 3: Search Location  [  Disabled/Dimmed  ]        
    [ ANALYZE LOCATION ]     [  Disabled/Grey   ]         
     
                                                             
  STATE 3: Filters Selected (Optional)                      
     
    Step 1: Business Type    [  Cafe     ]            
    Step 2: Nearby Filters   [    selected ]      
    Step 3: Search Location  [  Now Active!    ]        
    [ ANALYZE LOCATION ]     [  Disabled/Grey   ]         
     
                                                             
  STATE 4: Location Selected (Ready!)                       
     
    Step 1: Business Type    [  Cafe     ]            
    Step 2: Nearby Filters   [    selected ]      
    Step 3: Search Location  [ Indiranagar... ]         
    [  ANALYZE LOCATION ]   [  GLOWING GREEN  ]       
     
                                                             

```

**Note:** Step 2 (Filters) is technically **optional**  users can skip to Step 3. However, the UI encourages selection by highlighting the section.

---

### 3.4 The Data HUD (`z-30`)  Dashboard Cards

**Role:** Display analysis results. The "payoff" after searching.

**Position:** Fixed right side, stacked vertically or in a grid.

```

  DATA HUD LAYOUT                                            

                                                             
                              
                                OPPORTUNITY SCORE          
                                                    
                                        78               
                                                    
                                    Prime Location       
                              
                                                             
                                    
                              COMPETITORS LANDMARKS      
                                  12          8          
                                nearby      nearby       
                                    
                                                             
                              
                                FOOTFALL ANALYSIS          
                                  HIGH     
                                Peak: 6-9 PM weekdays      
                              
                                                             
                              
                                 GROWTH RADAR            
                                "New Metro line by 2026"   
                                Impact: +15% footfall      
                              
                                                             

```

**Specifications:**
| Property | Value |
|----------|-------|
| **Width** | `320px` per card |
| **Position** | `fixed`, `right: 24px`, `top: 24px` |
| **Layout** | Vertical stack with `12px` gap |
| **Background** | `surface-secondary` (glassmorphism) |
| **Border Radius** | `12px` |
| **Padding** | `20px` |
| **Max Height** | Each card max `300px`, scrollable if overflow |

**Card States:**
| State | Visual Treatment |
|-------|------------------|
| **Loading** | Skeleton pulse animation, no content |
| **Empty** | Ghost icon + "Select a location" message |
| **Populated** | Full data display |
| **Error** | Red border, error icon, retry button |

**Animation on Appear:**
- Cards slide in from right (`translateX: 100px  0`).
- Staggered delay: Card 1 at `0ms`, Card 2 at `100ms`, Card 3 at `200ms`.
- Duration: `400ms`, Easing: `ease-out`.

---

### 3.5 The Chat Widget (`z-40`)  AI Assistant

**Role:** Natural language interface to Hotspot IQ's intelligence.

**Position:** Floating Action Button (FAB) in bottom-right corner.

```

  CHAT WIDGET STATES                                         

                                                             
  STATE 1: COLLAPSED (FAB Only)                             
                                                             
                                                   
                                                        
                                           Ask            
                                                   
                                                             
  STATE 2: EXPANDED (Chat Panel)                            
                                                             
                              
                                Ask Hotspot            
                              
                                                           
                                Hi! I'm your location   
                                  intelligence assistant.  
                                                           
                                Is this good for a gym? 
                                                           
                                Based on the data, this 
                                  location shows strong    
                                  potential. There are 3   
                                  offices within 1km...    
                                                           
                              
                               Type a question...        
                              
                                                             

```

**FAB Specifications:**
| Property | Value |
|----------|-------|
| **Size** | `56px  56px` |
| **Position** | `fixed`, `right: 24px`, `bottom: 24px` |
| **Background** | `accent-violet` (AI = Purple) |
| **Border Radius** | `50%` (circular) |
| **Shadow** | Violet glow effect |
| **Icon** | Chat bubble or sparkle  |

**Expanded Panel Specifications:**
| Property | Value |
|----------|-------|
| **Width** | `380px` |
| **Height** | `500px` max |
| **Position** | `fixed`, `right: 24px`, `bottom: 96px` |
| **Background** | `surface-primary` |
| **Border Radius** | `16px` |

**Message Bubbles:**
| Sender | Background | Alignment | Border Radius |
|--------|------------|-----------|---------------|
| **User** | `primary-soft` | Right | `12px 12px 4px 12px` |
| **AI** | `surface-elevated` | Left | `12px 12px 12px 4px` |

**Suggested Questions (Chips):**
Display above input when chat is empty:
- "Is this good for a [business_type]?"
- "What's the competition like here?"
- "Show me the best spots nearby"

---

## 4. Data Visualization Guidelines

### 4.1 The Opportunity Score Ring

**Purpose:** The hero metric. The single number users remember.

```

  SCORE RING ANATOMY                                         

                                                             
                                         
                                                 
                                    Progress Arc     
                                     (Colored by      
                                      score range)    
                           78         Score Number     
                         /100          (Large, Bold)    
                                                      
                               Background Track 
                                         (surface-border) 
                       PRIME          Status Label     
                       LOCATION                           
                                         
                                                             

```

**Visual Specifications:**
| Property | Value |
|----------|-------|
| **Diameter** | `160px` |
| **Stroke Width** | `12px` |
| **Track Color** | `surface-border` |
| **Progress Color** | Dynamic (see below) |
| **Score Font Size** | `48px` |
| **Score Font Weight** | `700` (Bold) |
| **Label Font Size** | `14px` |
| **Label Font Weight** | `600` (Semi-bold) |

**Color by Score Range:**
| Score | Arc Color | Label | Glow |
|-------|-----------|-------|------|
| **70-100** | `primary-glow` | "PRIME LOCATION" | Green glow |
| **40-69** | `warning-glow` | "MODERATE POTENTIAL" | Amber glow |
| **0-39** | `destructive-glow` | "HIGH RISK" | Red glow |

**Animation:**
- On load: Arc animates from 0% to final value.
- Duration: `1200ms`
- Easing: `ease-out`
- Number counts up from 0 to final score.

---

### 4.2 Isochrone Rendering

**Purpose:** Show "What can I reach in X minutes?" as a polygon overlay.

```

  ISOCHRONE VISUAL STYLE                                     

                                                             
                                        
                                                    
                                            
                                                 
                      YOU                              
                                                  
               (15-min bike radius)                      
                                                         
                                                         
                                                     
                                                   
                                                  
                                         
                                                             

```

**Polygon Specifications:**
| Property | Value |
|----------|-------|
| **Fill Color** | `primary-glow` @ 15% opacity |
| **Stroke Color** | `primary-glow` @ 80% opacity |
| **Stroke Width** | `2px` |
| **Stroke Style** | Solid (not dashed) |

**Multiple Isochrones (Time Comparison):**
When showing multiple time ranges (5, 10, 15 mins):

| Time | Fill Opacity | Stroke Opacity |
|------|--------------|----------------|
| **5 min** | 25% | 100% |
| **10 min** | 15% | 70% |
| **15 min** | 10% | 50% |

**Animation:**
- On draw: Polygon fades in (`opacity: 0  1`).
- Duration: `600ms`
- When changing time: Morphs smoothly to new shape (if library supports).

---

### 4.3 Map Markers & Pins

**Purpose:** Represent locations, competitors, landmarks on the map.

**Marker Types:**

| Type | Shape | Size | Color | Icon |
|------|-------|------|-------|------|
| **Selected Location** | Circle with pulse | `24px` | `primary-glow` | None (solid dot) |
| **Competitor** | Circle | `16px` | `destructive-glow` | Business icon |
| **Landmark (Positive)** | Circle | `14px` | `primary-soft` | Category icon |
| **Landmark (Neutral)** | Circle | `12px` | `text-tertiary` | Category icon |
| **Warehouse** | Square | `20px` | `accent-cyan` |  |

**Selected Location Marker:**
```

  PULSE ANIMATION                                            

                                                             
                                                 
                              Outer pulse ring           
                        (expanding, fading)        
                           Inner solid dot            
                                                   
                                                           
                                                 
                                                             

```

- Inner dot: `12px`, solid `primary-glow`.
- Outer ring: Expands from `12px` to `36px`, fades from 50% to 0% opacity.
- Animation: Infinite loop, `2s` duration.

---

### 4.4 Heatmap Overlay

**Purpose:** Show opportunity density across an area.

**Color Gradient:**
```
Low Opportunity                              High Opportunity
     
             
     
     destructive  warning  amber  primary  primary-bright
```

**Specifications:**
| Property | Value |
|----------|-------|
| **Opacity** | 40-60% (must see map beneath) |
| **Blur** | Soft edges, no hard boundaries |
| **Radius** | Based on data density |
| **Update** | Real-time as user pans |

---

### 4.5 Charts (Recharts)

**Bar Chart (Competitor Breakdown):**
| Property | Value |
|----------|-------|
| **Bar Color** | `destructive-glow` (competitors are threats) |
| **Background** | `transparent` |
| **Grid Lines** | `surface-border` @ 50% |
| **Axis Labels** | `text-tertiary` |
| **Bar Radius** | `4px` top corners |

**Radar Chart (Landmark Categories):**
| Property | Value |
|----------|-------|
| **Fill** | `primary-soft` |
| **Stroke** | `primary-glow` |
| **Grid** | `surface-border` |
| **Dots** | `primary-bright`, `6px` |

**Line Chart (Trends):**
| Property | Value |
|----------|-------|
| **Line Color** | `primary-glow` |
| **Line Width** | `2px` |
| **Area Fill** | Gradient from `primary-soft` to `transparent` |
| **Dots** | Show only on hover |

---

## 5. Typography & Motion

### 5.1 Font Stack

**Primary Font: Inter**
```css
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
```

**Monospace Font: JetBrains Mono** (for data, codes, Digipin)
```css
font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
```

### 5.2 Type Scale

| Token | Size | Weight | Line Height | Use Case |
|-------|------|--------|-------------|----------|
| `--text-hero` | `48px` | 700 | 1.1 | Opportunity Score number |
| `--text-h1` | `28px` | 700 | 1.2 | Panel titles |
| `--text-h2` | `20px` | 600 | 1.3 | Card headers |
| `--text-h3` | `16px` | 600 | 1.4 | Section labels |
| `--text-body` | `14px` | 400 | 1.5 | Default body text |
| `--text-small` | `12px` | 400 | 1.5 | Metadata, captions |
| `--text-micro` | `10px` | 500 | 1.4 | Badges, tags |

### 5.3 Font Weights

| Weight | Value | Usage |
|--------|-------|-------|
| **Regular** | 400 | Body text, descriptions |
| **Medium** | 500 | Labels, interactive elements |
| **Semi-bold** | 600 | Subheadings, emphasis |
| **Bold** | 700 | Headlines, scores, CTAs |

### 5.4 Motion System

**The Motion Philosophy:**
> "Movement should feel like data flowing through a systemswift, precise, purposeful."

**Timing Functions:**
| Token | Value | Use Case |
|-------|-------|----------|
| `--ease-out` | `cubic-bezier(0.0, 0.0, 0.2, 1)` | Elements entering (cards appearing) |
| `--ease-in` | `cubic-bezier(0.4, 0.0, 1, 1)` | Elements exiting (modals closing) |
| `--ease-in-out` | `cubic-bezier(0.4, 0.0, 0.2, 1)` | Elements transforming (toggles, sliders) |
| `--spring` | `cubic-bezier(0.34, 1.56, 0.64, 1)` | Playful interactions (FAB press) |

**Duration Scale:**
| Token | Value | Use Case |
|-------|-------|----------|
| `--duration-instant` | `100ms` | Hover states, focus rings |
| `--duration-fast` | `200ms` | Button clicks, toggles |
| `--duration-normal` | `300ms` | Card transitions, dropdowns |
| `--duration-slow` | `500ms` | Page transitions, large panels |
| `--duration-glacial` | `1000ms` | Score animations, charts drawing |

### 5.5 Micro-Interactions Catalog

| Interaction | Animation |
|-------------|-----------|
| **Button Hover** | Background lightens 10%, subtle glow appears (`200ms`) |
| **Button Press** | Scale down to `0.97`, shadow reduces (`100ms`) |
| **Card Appear** | Slide from right (`translateX: 20px  0`) + fade in (`400ms`) |
| **Card Hover** | Border color brightens, subtle lift (`translateY: -2px`) |
| **Input Focus** | Border color  `primary-glow`, glow shadow appears (`200ms`) |
| **Dropdown Open** | Scale from `0.95` to `1`, fade in (`200ms`) |
| **Score Count-Up** | Number counts from 0 to value (`1200ms`, ease-out) |
| **Progress Arc** | Draws from 0% to value (`1200ms`, ease-out) |
| **Marker Pulse** | Infinite expanding ring (`2s` loop) |
| **Chat Message** | Slide up from bottom + fade in (`300ms`) |
| **Toast Notification** | Slide in from right, auto-dismiss after `4s` |
| **Loading Skeleton** | Shimmer effect (gradient moving left to right, `1.5s` loop) |

---

## 6. Spacing & Grid System

### 6.1 Spacing Scale

Based on `4px` base unit:

| Token | Value | Use Case |
|-------|-------|----------|
| `--space-1` | `4px` | Tight gaps (icon + text) |
| `--space-2` | `8px` | Inline spacing |
| `--space-3` | `12px` | Card gaps, small padding |
| `--space-4` | `16px` | Default padding, section gaps |
| `--space-5` | `20px` | Card padding |
| `--space-6` | `24px` | Panel padding, large gaps |
| `--space-8` | `32px` | Section separation |
| `--space-10` | `40px` | Major section breaks |
| `--space-12` | `48px` | Page margins |

### 6.2 Component Spacing

| Component | Padding | Gap (between children) | Margin (from viewport) |
|-----------|---------|------------------------|------------------------|
| **Sidebar Panel** | `24px` | `16px` | `24px` from edges |
| **Dashboard Card** | `20px` | `12px` |  |
| **Input Field** | `12px 16px` |  |  |
| **Button** | `12px 24px` | `8px` (icon + text) |  |
| **Chip/Tag** | `6px 12px` |  | `8px` between chips |
| **Modal** | `32px` | `24px` | Centered |

---

## 7. Responsive Behavior

### 7.1 Breakpoints

| Token | Value | Description |
|-------|-------|-------------|
| `--breakpoint-sm` | `640px` | Mobile landscape |
| `--breakpoint-md` | `768px` | Tablets |
| `--breakpoint-lg` | `1024px` | Small laptops |
| `--breakpoint-xl` | `1280px` | Desktops |
| `--breakpoint-2xl` | `1536px` | Large monitors |

### 7.2 Layout Adaptation

| Viewport | Sidebar | Dashboard | Chat |
|----------|---------|-----------|------|
| **Desktop (1024px)** | Fixed left, always visible | Fixed right, always visible | FAB bottom-right |
| **Tablet (768-1023px)** | Collapsible, hamburger toggle | Below map, scrollable | FAB bottom-right |
| **Mobile (<768px)** | Bottom drawer (swipe up) | Full-screen modal on demand | FAB bottom-right |

### 7.3 Mobile Considerations

- **Touch targets:** Minimum `44px  44px` for all interactive elements.
- **Swipe gestures:** Sidebar opens with swipe-right, closes with swipe-left.
- **Map remains hero:** On mobile, map takes 60% of screen, panels overlay from bottom.
- **Simplified HUD:** On mobile, show only Score + 2 key metrics (not full dashboard).

---

## 8. Accessibility Guidelines

### 8.1 Color Contrast

All text must meet WCAG 2.1 AA standards:
- **Normal text:** Minimum `4.5:1` contrast ratio.
- **Large text (18px+):** Minimum `3:1` contrast ratio.

| Combination | Contrast Ratio | Pass? |
|-------------|----------------|-------|
| `text-primary` on `canvas-deep` | `17.4:1` |  AAA |
| `text-secondary` on `canvas-deep` | `9.7:1` |  AAA |
| `text-tertiary` on `canvas-deep` | `5.1:1` |  AA |
| `primary-glow` on `canvas-deep` | `6.2:1` |  AA |

### 8.2 Focus States

All interactive elements must have visible focus indicators:
```css
:focus-visible {
  outline: 2px solid var(--primary-glow);
  outline-offset: 2px;
}
```

### 8.3 Screen Reader Support

- All images have descriptive `alt` text.
- Icon-only buttons have `aria-label`.
- Score changes announced with `aria-live="polite"`.
- Map markers have accessible names.

### 8.4 Reduced Motion

Respect user preference:
```css
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}
```

---

##  Appendix: Quick Reference

### Color Tokens (Copy-Paste)
```css
:root {
  /* Canvas */
  --canvas-deep: #020617;
  --canvas-base: #0f172a;
  
  /* Surface */
  --surface-primary: rgba(15, 23, 42, 0.8);
  --surface-secondary: rgba(30, 41, 59, 0.7);
  --surface-elevated: rgba(51, 65, 85, 0.6);
  --surface-border: rgba(255, 255, 255, 0.08);
  
  /* Primary */
  --primary-glow: #10b981;
  --primary-bright: #34d399;
  --primary-soft: rgba(16, 185, 129, 0.2);
  
  /* Warning */
  --warning-glow: #f59e0b;
  --warning-soft: rgba(245, 158, 11, 0.2);
  
  /* Destructive */
  --destructive-glow: #f43f5e;
  --destructive-soft: rgba(244, 63, 94, 0.2);
  
  /* Text */
  --text-primary: #f8fafc;
  --text-secondary: #cbd5e1;
  --text-tertiary: #64748b;
  --text-disabled: #475569;
  
  /* Accent */
  --accent-cyan: #06b6d4;
  --accent-violet: #8b5cf6;
}
```

### Tailwind Mapping
```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        canvas: {
          deep: '#020617',
          base: '#0f172a',
        },
        surface: {
          primary: 'rgba(15, 23, 42, 0.8)',
          secondary: 'rgba(30, 41, 59, 0.7)',
        },
        // ... etc
      }
    }
  }
}
```

---

<div align="center">

** Design with purpose. Build with precision. Ship with confidence.**

*Hotspot IQ Design System v1.0*

</div>
</file>

<file path="frontend/.env.example">
# Frontend Environment Variables
VITE_API_BASE_URL=http://localhost:5000/api
</file>

<file path="frontend/.gitignore">
# Dependencies
node_modules/

# Build output
dist/
build/

# Environment
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Cache
.cache/
.eslintcache
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hotspot IQ - Location Intelligence</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  </head>
  <body class="bg-canvas-deep text-slate-50 font-sans">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "hotspot-iq-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "leaflet": "^1.9.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-leaflet": "^4.2.1",
    "recharts": "^2.10.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "vite": "^5.0.8"
  }
}
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/src/components/Dashboard/Charts/CompetitorChart.jsx">
/**
 * Competitor Chart Component
 * Bar chart showing competitor distribution by category
 */

import { useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  Cell,
} from 'recharts';

// Category colors
const CATEGORY_COLORS = {
  cafe: '#10b981',
  restaurant: '#f59e0b',
  retail: '#3b82f6',
  gym: '#8b5cf6',
  pharmacy: '#ec4899',
  salon: '#14b8a6',
  electronics: '#6366f1',
  clothing: '#f43f5e',
  default: '#64748b',
};

// Custom tooltip
const CustomTooltip = ({ active, payload }) => {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;
  return (
    <div className="bg-canvas-base border border-surface-border rounded-lg p-3 shadow-glass">
      <p className="text-slate-200 font-medium">{data.name}</p>
      <p className="text-sm text-slate-400">
        <span className="text-destructive-glow font-semibold">{data.count}</span> competitors
      </p>
    </div>
  );
};

export default function CompetitorChart({ competitors = [], isLoading }) {
  // Safely convert to array
  const competitorList = Array.isArray(competitors) ? competitors : [];
  
  // Group competitors by category
  const chartData = useMemo(() => {
    const grouped = competitorList.reduce((acc, competitor) => {
      const category = competitor.category?.toLowerCase() || 'other';
      if (!acc[category]) {
        acc[category] = { name: category, count: 0 };
      }
      acc[category].count++;
      return acc;
    }, {});

    return Object.values(grouped)
      .sort((a, b) => b.count - a.count)
      .slice(0, 6); // Top 6 categories
  }, [competitorList]);

  if (isLoading) {
    return (
      <div className="glass-panel p-4">
        <div className="h-4 bg-slate-700 rounded w-32 mb-4 animate-pulse" />
        <div className="h-48 bg-slate-700/30 rounded animate-pulse" />
      </div>
    );
  }

  if (competitorList.length === 0) {
    return (
      <div className="glass-panel p-4">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <span></span> Competitor Distribution
        </h3>
        <div className="h-48 flex items-center justify-center text-slate-500">
          <div className="text-center">
            <span className="text-3xl mb-2 block"></span>
            <p>No competitors to show</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="glass-panel p-4">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <span></span> Competitor Distribution
      </h3>
      
      <div className="h-48">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            layout="vertical"
            margin={{ top: 0, right: 0, bottom: 0, left: 0 }}
          >
            <XAxis 
              type="number" 
              hide 
              domain={[0, 'dataMax + 1']}
            />
            <YAxis
              type="category"
              dataKey="name"
              width={80}
              tick={{ fill: '#94a3b8', fontSize: 12 }}
              axisLine={false}
              tickLine={false}
              tickFormatter={(value) => 
                value.charAt(0).toUpperCase() + value.slice(1)
              }
            />
            <Tooltip content={<CustomTooltip />} cursor={false} />
            <Bar
              dataKey="count"
              radius={[0, 4, 4, 0]}
              maxBarSize={24}
            >
              {chartData.map((entry, index) => (
                <Cell
                  key={`cell-${index}`}
                  fill={CATEGORY_COLORS[entry.name] || CATEGORY_COLORS.default}
                  fillOpacity={0.8}
                />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </div>
      
      {/* Legend */}
      <div className="flex flex-wrap gap-2 mt-3 pt-3 border-t border-surface-border">
        {chartData.map((item) => (
          <div key={item.name} className="flex items-center gap-1.5 text-xs">
            <div
              className="w-2.5 h-2.5 rounded-sm"
              style={{ backgroundColor: CATEGORY_COLORS[item.name] || CATEGORY_COLORS.default }}
            />
            <span className="text-slate-500 capitalize">{item.name}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/Charts/index.js">
export { default as CompetitorChart } from './CompetitorChart';
export { default as LandmarkRadar } from './LandmarkRadar';
export { default as ScoreGauge } from './ScoreGauge';
</file>

<file path="frontend/src/components/Dashboard/Charts/LandmarkRadar.jsx">
/**
 * Landmark Radar Chart Component
 * Radar chart showing landmark category distribution
 */

import { useMemo } from 'react';
import {
  RadarChart,
  PolarGrid,
  PolarAngleAxis,
  PolarRadiusAxis,
  Radar,
  ResponsiveContainer,
  Tooltip,
} from 'recharts';

// Category configuration
const CATEGORY_CONFIG = {
  metro_station: { label: 'Metro', maxScore: 5 },
  bus_stop: { label: 'Bus', maxScore: 10 },
  school: { label: 'School', maxScore: 8 },
  college: { label: 'College', maxScore: 5 },
  hospital: { label: 'Hospital', maxScore: 5 },
  mall: { label: 'Mall', maxScore: 3 },
  office: { label: 'Office', maxScore: 10 },
  residential: { label: 'Residential', maxScore: 15 },
  temple: { label: 'Temple', maxScore: 5 },
  park: { label: 'Park', maxScore: 5 },
};

// Custom tooltip
const CustomTooltip = ({ active, payload }) => {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;
  return (
    <div className="bg-canvas-base border border-surface-border rounded-lg p-3 shadow-glass">
      <p className="text-slate-200 font-medium">{data.fullLabel}</p>
      <p className="text-sm text-slate-400">
        <span className="text-primary-glow font-semibold">{data.count}</span> nearby
      </p>
    </div>
  );
};

export default function LandmarkRadar({ landmarks = [], isLoading }) {
  // Safely convert to array
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  
  // Process landmarks into radar data
  const chartData = useMemo(() => {
    // Count landmarks by category
    const counts = landmarkList.reduce((acc, landmark) => {
      const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'other';
      acc[category] = (acc[category] || 0) + 1;
      return acc;
    }, {});

    // Convert to chart format with normalized values
    return Object.entries(CATEGORY_CONFIG).map(([key, config]) => {
      const count = counts[key] || 0;
      const normalized = Math.min(100, (count / config.maxScore) * 100);
      return {
        category: config.label,
        fullLabel: config.label,
        value: normalized,
        count,
      };
    });
  }, [landmarkList]);

  if (isLoading) {
    return (
      <div className="glass-panel p-4">
        <div className="h-4 bg-slate-700 rounded w-32 mb-4 animate-pulse" />
        <div className="h-64 bg-slate-700/30 rounded-full animate-pulse mx-auto w-64" />
      </div>
    );
  }

  if (landmarkList.length === 0) {
    return (
      <div className="glass-panel p-4">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <span></span> Landmark Coverage
        </h3>
        <div className="h-64 flex items-center justify-center text-slate-500">
          <div className="text-center">
            <span className="text-3xl mb-2 block"></span>
            <p>No landmarks detected</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="glass-panel p-4">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <span></span> Landmark Coverage
      </h3>
      
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <RadarChart data={chartData} margin={{ top: 20, right: 30, bottom: 20, left: 30 }}>
            <PolarGrid 
              stroke="#334155" 
              strokeOpacity={0.5}
            />
            <PolarAngleAxis
              dataKey="category"
              tick={{ fill: '#94a3b8', fontSize: 11 }}
              tickLine={false}
            />
            <PolarRadiusAxis
              angle={90}
              domain={[0, 100]}
              tick={false}
              axisLine={false}
            />
            <Tooltip content={<CustomTooltip />} />
            <Radar
              name="Coverage"
              dataKey="value"
              stroke="#10b981"
              fill="#10b981"
              fillOpacity={0.3}
              strokeWidth={2}
            />
          </RadarChart>
        </ResponsiveContainer>
      </div>
      
      {/* Summary */}
      <div className="mt-3 pt-3 border-t border-surface-border">
        <div className="flex items-center justify-between text-xs">
          <span className="text-slate-500">Total landmarks detected</span>
          <span className="text-primary-glow font-semibold">{landmarkList.length}</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/Charts/ScoreGauge.jsx">
/**
 * Score Gauge Component
 * Circular gauge visualization for opportunity score
 */

import { useMemo } from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer } from 'recharts';

export default function ScoreGauge({ score = 0, size = 'md', showLabel = true, isLoading }) {
  const normalizedScore = Math.min(100, Math.max(0, score));
  
  // Determine color based on score
  const scoreColor = useMemo(() => {
    if (normalizedScore >= 70) return '#10b981'; // Green - Excellent
    if (normalizedScore >= 50) return '#06b6d4'; // Cyan - Good
    if (normalizedScore >= 30) return '#f59e0b'; // Amber - Fair
    return '#f43f5e'; // Rose - Poor
  }, [normalizedScore]);

  const scoreLabel = useMemo(() => {
    if (normalizedScore >= 70) return 'Excellent';
    if (normalizedScore >= 50) return 'Good';
    if (normalizedScore >= 30) return 'Fair';
    return 'Poor';
  }, [normalizedScore]);

  // Chart data for gauge effect
  const data = [
    { name: 'score', value: normalizedScore },
    { name: 'remaining', value: 100 - normalizedScore },
  ];

  // Size configurations
  const sizes = {
    sm: { width: 100, height: 100, inner: 35, outer: 45, fontSize: 'text-xl' },
    md: { width: 160, height: 160, inner: 55, outer: 70, fontSize: 'text-3xl' },
    lg: { width: 200, height: 200, inner: 70, outer: 90, fontSize: 'text-4xl' },
  };

  const config = sizes[size] || sizes.md;

  if (isLoading) {
    return (
      <div 
        className="relative flex items-center justify-center"
        style={{ width: config.width, height: config.height }}
      >
        <div 
          className="absolute rounded-full border-8 border-slate-700 animate-pulse"
          style={{ 
            width: config.outer * 2, 
            height: config.outer * 2,
          }}
        />
        <div className="w-8 h-8 border-2 border-slate-600 border-t-primary-glow rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div 
      className="relative"
      style={{ width: config.width, height: config.height }}
    >
      <ResponsiveContainer width="100%" height="100%">
        <PieChart>
          <Pie
            data={data}
            cx="50%"
            cy="50%"
            startAngle={180}
            endAngle={0}
            innerRadius={config.inner}
            outerRadius={config.outer}
            paddingAngle={0}
            dataKey="value"
            stroke="none"
          >
            <Cell fill={scoreColor} />
            <Cell fill="#1e293b" />
          </Pie>
        </PieChart>
      </ResponsiveContainer>
      
      {/* Center content */}
      <div className="absolute inset-0 flex flex-col items-center justify-center">
        <span 
          className={`font-bold ${config.fontSize} transition-colors duration-500`}
          style={{ color: scoreColor }}
        >
          {normalizedScore}
        </span>
        {showLabel && (
          <span 
            className="text-xs font-medium transition-colors duration-500 -mt-1"
            style={{ color: scoreColor }}
          >
            {scoreLabel}
          </span>
        )}
      </div>
      
      {/* Scale markers */}
      <div className="absolute bottom-0 left-0 right-0 flex justify-between px-2 text-xs text-slate-600">
        <span>0</span>
        <span>50</span>
        <span>100</span>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/LoadingProgress.jsx">
/**
 * LoadingProgress Component
 * Shows progressive loading status during analysis
 */

export default function LoadingProgress({ status, isLoading }) {
  if (!isLoading && status.step === '') return null;

  const { step, message, progress, details } = status;

  return (
    <div className="bg-surface-elevated border border-surface-border rounded-xl p-4 mb-4 animate-fadeIn">
      {/* Progress Bar */}
      <div className="mb-3">
        <div className="flex justify-between items-center mb-1">
          <span className="text-sm font-medium text-slate-300">{message}</span>
          <span className="text-xs text-slate-500">{progress}%</span>
        </div>
        <div className="w-full h-2 bg-surface-secondary rounded-full overflow-hidden">
          <div 
            className="h-full bg-gradient-to-r from-primary-glow to-emerald-400 transition-all duration-500 ease-out"
            style={{ width: `${progress}%` }}
          />
        </div>
      </div>

      {/* Details List */}
      {details.length > 0 && (
        <div className="space-y-1 max-h-32 overflow-y-auto">
          {details.map((detail, index) => (
            <div 
              key={index}
              className="text-xs text-slate-400 flex items-center gap-2 animate-slideIn"
              style={{ animationDelay: `${index * 50}ms` }}
            >
              <span className="w-1.5 h-1.5 bg-primary-glow rounded-full" />
              {detail}
            </div>
          ))}
        </div>
      )}

      {/* Loading Spinner for active steps */}
      {isLoading && step !== 'complete' && step !== 'error' && (
        <div className="flex items-center gap-2 mt-3 pt-3 border-t border-surface-border">
          <div className="w-4 h-4 border-2 border-primary-glow border-t-transparent rounded-full animate-spin" />
          <span className="text-xs text-slate-500">
            {step === 'analysis' ? 'This may take a moment...' : 'Processing...'}
          </span>
        </div>
      )}

      {/* Completion Message */}
      {step === 'complete' && (
        <div className="flex items-center gap-2 mt-3 pt-3 border-t border-surface-border text-emerald-400">
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
          <span className="text-xs font-medium">Analysis ready! Scroll down to see results.</span>
        </div>
      )}

      {/* Error State */}
      {step === 'error' && (
        <div className="flex items-center gap-2 mt-3 pt-3 border-t border-surface-border text-rose-400">
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
          <span className="text-xs font-medium">Analysis failed. Please try again.</span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/MetricsGrid.jsx">
/**
 * Metrics Grid Component
 * Displays key metrics in a compact grid layout
 */

export default function MetricsGrid({ analysis, isLoading }) {
  const metrics = [
    {
      id: 'footfall',
      label: 'Footfall Index',
      value: analysis?.footfall_index || 0,
      max: 100,
      icon: '',
      color: 'primary',
      description: 'Estimated foot traffic potential',
    },
    {
      id: 'competitors',
      label: 'Competitors',
      value: analysis?.competitors?.length || 0,
      suffix: ' nearby',
      icon: '',
      color: 'destructive',
      description: 'Same category businesses',
    },
    {
      id: 'landmarks',
      label: 'Landmarks',
      value: analysis?.landmarks?.length || 0,
      suffix: ' found',
      icon: '',
      color: 'accent',
      description: 'Key locations nearby',
    },
    {
      id: 'density',
      label: 'Competition Density',
      value: analysis?.competitor_density?.toFixed(1) || '0.0',
      suffix: '/km',
      icon: '',
      color: 'warning',
      description: 'Competitors per square km',
    },
  ];

  const getColorClasses = (color) => {
    const colors = {
      primary: 'text-primary-glow bg-primary-glow/10 border-primary-glow/30',
      destructive: 'text-destructive-glow bg-destructive-glow/10 border-destructive-glow/30',
      accent: 'text-accent-glow bg-accent-glow/10 border-accent-glow/30',
      warning: 'text-warning-glow bg-warning-glow/10 border-warning-glow/30',
    };
    return colors[color] || colors.primary;
  };

  if (isLoading) {
    return (
      <div className="grid grid-cols-2 gap-3">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="glass-card p-4 animate-pulse">
            <div className="flex items-center gap-2 mb-2">
              <div className="w-8 h-8 bg-slate-700 rounded-lg" />
              <div className="h-4 bg-slate-700 rounded w-20" />
            </div>
            <div className="h-6 bg-slate-700 rounded w-16 mb-1" />
            <div className="h-3 bg-slate-700/50 rounded w-24" />
          </div>
        ))}
      </div>
    );
  }

  return (
    <div className="grid grid-cols-2 gap-3">
      {metrics.map((metric) => (
        <div
          key={metric.id}
          className="glass-card p-4 hover:bg-surface-elevated transition-colors group"
        >
          {/* Header */}
          <div className="flex items-center gap-2 mb-2">
            <div className={`w-8 h-8 rounded-lg flex items-center justify-center text-lg border ${getColorClasses(metric.color)}`}>
              {metric.icon}
            </div>
            <span className="text-xs text-slate-500 font-medium uppercase tracking-wide">
              {metric.label}
            </span>
          </div>
          
          {/* Value */}
          <div className="flex items-baseline gap-1">
            <span className={`text-2xl font-bold ${getColorClasses(metric.color).split(' ')[0]}`}>
              {metric.value}
            </span>
            {metric.suffix && (
              <span className="text-sm text-slate-500">{metric.suffix}</span>
            )}
            {metric.max && (
              <span className="text-sm text-slate-600">/{metric.max}</span>
            )}
          </div>
          
          {/* Description (on hover) */}
          <p className="text-xs text-slate-600 mt-1 group-hover:text-slate-500 transition-colors">
            {metric.description}
          </p>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/RecommendedSpotsCard.jsx">
/**
 * Recommended Spots Card Component
 * Displays optimal locations for setting up a business based on analysis
 */

import { useState } from 'react';

// Rating badge component
const RatingBadge = ({ rating, color }) => {
  const colorClasses = {
    green: 'bg-emerald-500/20 text-emerald-400 border-emerald-500/30',
    cyan: 'bg-cyan-500/20 text-cyan-400 border-cyan-500/30',
    yellow: 'bg-amber-500/20 text-amber-400 border-amber-500/30',
    orange: 'bg-orange-500/20 text-orange-400 border-orange-500/30',
  };
  
  return (
    <span className={`px-2 py-0.5 text-xs font-medium rounded-full border ${colorClasses[color] || colorClasses.cyan}`}>
      {rating}
    </span>
  );
};

// Individual spot card
const SpotItem = ({ spot, index, isExpanded, onToggle, onViewOnMap }) => {
  const rankColors = {
    1: 'from-emerald-500 to-emerald-600',
    2: 'from-cyan-500 to-cyan-600',
    3: 'from-blue-500 to-blue-600',
    4: 'from-purple-500 to-purple-600',
    5: 'from-slate-500 to-slate-600',
  };

  return (
    <div 
      className={`rounded-lg border transition-all duration-200 ${
        isExpanded 
          ? 'bg-surface-elevated border-primary-glow/30' 
          : 'bg-surface-secondary border-surface-border hover:border-slate-600'
      }`}
    >
      {/* Header - always visible */}
      <button
        onClick={onToggle}
        className="w-full flex items-center gap-3 p-3 text-left"
      >
        {/* Rank badge */}
        <div className={`w-8 h-8 rounded-lg bg-gradient-to-br ${rankColors[spot.rank] || rankColors[5]} flex items-center justify-center text-white font-bold text-sm shadow-lg`}>
          {spot.rank}
        </div>
        
        {/* Location info */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-slate-200 font-medium">Spot #{spot.rank}</span>
            <RatingBadge rating={spot.rating} color={spot.rating_color} />
          </div>
          <p className="text-xs text-slate-500 font-mono truncate">
            {spot.lat}, {spot.lng}
          </p>
        </div>
        
        {/* Score */}
        <div className="text-right">
          <div className="text-lg font-bold text-primary-glow">{Math.round(spot.score)}</div>
          <div className="text-[10px] text-slate-500 uppercase tracking-wide">Score</div>
        </div>
        
        {/* Expand indicator */}
        <svg 
          className={`w-4 h-4 text-slate-500 transition-transform ${isExpanded ? 'rotate-180' : ''}`} 
          fill="none" 
          viewBox="0 0 24 24" 
          stroke="currentColor"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      
      {/* Expanded content */}
      {isExpanded && (
        <div className="px-3 pb-3 space-y-3 border-t border-surface-border pt-3">
          {/* Stats row */}
          <div className="grid grid-cols-2 gap-2">
            <div className="bg-surface-secondary rounded-lg p-2 text-center">
              <div className="text-rose-400 font-semibold">{spot.nearby_competitors}</div>
              <div className="text-[10px] text-slate-500">Competitors Nearby</div>
            </div>
            <div className="bg-surface-secondary rounded-lg p-2 text-center">
              <div className="text-cyan-400 font-semibold">{spot.nearby_landmarks}</div>
              <div className="text-[10px] text-slate-500">Landmarks</div>
            </div>
          </div>
          
          {/* Distance to nearest competitor */}
          {spot.min_competitor_distance && (
            <div className="flex items-center gap-2 text-xs">
              <span className="text-slate-500">Nearest competitor:</span>
              <span className={`font-medium ${spot.min_competitor_distance > 300 ? 'text-emerald-400' : 'text-amber-400'}`}>
                {spot.min_competitor_distance}m away
              </span>
            </div>
          )}
          
          {/* Reasons */}
          <div className="space-y-1.5">
            <p className="text-xs text-slate-400 font-medium">Why this spot:</p>
            <ul className="space-y-1">
              {spot.reasons.map((reason, i) => (
                <li key={i} className="flex items-start gap-2 text-xs text-slate-300">
                  <span className="text-emerald-400 mt-0.5"></span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
          
          {/* Action button */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              onViewOnMap(spot);
            }}
            className="w-full py-2 bg-primary-glow/10 hover:bg-primary-glow/20 text-primary-glow text-xs font-medium rounded-lg transition-colors flex items-center justify-center gap-2"
          >
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            View on Map
          </button>
        </div>
      )}
    </div>
  );
};

export default function RecommendedSpotsCard({ spots = [], isLoading, onViewSpot }) {
  const [expandedIndex, setExpandedIndex] = useState(0); // First spot expanded by default

  if (isLoading) {
    return (
      <div className="glass-panel p-5">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <span className="text-lg"></span>
          Recommended Locations
        </h3>
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="bg-surface-secondary rounded-lg p-4 animate-pulse">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 rounded-lg bg-slate-700" />
                <div className="flex-1">
                  <div className="h-4 bg-slate-700 rounded w-24 mb-2" />
                  <div className="h-3 bg-slate-700/50 rounded w-32" />
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (!spots || spots.length === 0) {
    return (
      <div className="glass-panel p-5">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <span className="text-lg"></span>
          Recommended Locations
        </h3>
        <div className="text-center py-8">
          <div className="text-4xl mb-3"></div>
          <p className="text-slate-400 text-sm">
            No optimal spots found in this area.
          </p>
          <p className="text-slate-500 text-xs mt-1">
            Try expanding the search radius or selecting a different area.
          </p>
        </div>
      </div>
    );
  }

  const topSpot = spots[0];

  return (
    <div className="glass-panel p-5">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <span className="text-lg"></span>
          Recommended Locations
        </h3>
        <span className="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-xs rounded-full font-medium">
          {spots.length} spots found
        </span>
      </div>
      
      {/* Best spot highlight */}
      {topSpot && (
        <div className="mb-4 p-3 rounded-lg bg-gradient-to-r from-emerald-500/10 to-cyan-500/10 border border-emerald-500/20">
          <div className="flex items-center gap-2 mb-1">
            <span className="text-lg"></span>
            <span className="text-emerald-400 font-semibold text-sm">Best Location Found</span>
          </div>
          <p className="text-xs text-slate-300">
            {topSpot.reasons[0] || 'Optimal balance of low competition and good footfall'}
          </p>
        </div>
      )}
      
      {/* Spots list */}
      <div className="space-y-2 max-h-[400px] overflow-y-auto custom-scrollbar">
        {spots.map((spot, index) => (
          <SpotItem
            key={`spot-${spot.rank}`}
            spot={spot}
            index={index}
            isExpanded={expandedIndex === index}
            onToggle={() => setExpandedIndex(expandedIndex === index ? -1 : index)}
            onViewOnMap={onViewSpot}
          />
        ))}
      </div>
      
      {/* Legend */}
      <div className="mt-4 pt-3 border-t border-surface-border">
        <p className="text-[10px] text-slate-500 text-center">
          Spots are ranked by opportunity score: low competition + high footfall = better
        </p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/ScoreCard.jsx">
/**
 * Score Card Component
 * Displays the Opportunity Score with a radial progress ring
 */

export default function ScoreCard({ score, label, isLoading }) {
  // Score should be 0-100
  const normalizedScore = Math.min(100, Math.max(0, score || 0));
  
  // Calculate stroke-dasharray for progress ring
  const radius = 45;
  const circumference = 2 * Math.PI * radius;
  const strokeDashoffset = circumference - (normalizedScore / 100) * circumference;
  
  // Determine color based on score
  const getScoreColor = (score) => {
    if (score >= 70) return '#10b981'; // Green - Excellent
    if (score >= 50) return '#06b6d4'; // Cyan - Good
    if (score >= 30) return '#f59e0b'; // Amber - Fair
    return '#f43f5e'; // Rose - Poor
  };
  
  const getScoreLabel = (score) => {
    if (score >= 70) return 'Excellent';
    if (score >= 50) return 'Good';
    if (score >= 30) return 'Fair';
    return 'Poor';
  };
  
  const scoreColor = getScoreColor(normalizedScore);
  const scoreLabel = getScoreLabel(normalizedScore);

  return (
    <div className="glass-panel p-5">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <span className="text-lg"></span>
        Opportunity Score
      </h3>
      
      <div className="flex items-center gap-6">
        {/* Radial Progress Ring */}
        <div className="relative w-28 h-28">
          <svg className="w-full h-full transform -rotate-90">
            {/* Background circle */}
            <circle
              cx="56"
              cy="56"
              r={radius}
              stroke="currentColor"
              strokeWidth="8"
              fill="none"
              className="text-slate-700"
            />
            {/* Progress circle */}
            <circle
              cx="56"
              cy="56"
              r={radius}
              stroke={isLoading ? '#475569' : scoreColor}
              strokeWidth="8"
              fill="none"
              strokeLinecap="round"
              strokeDasharray={circumference}
              strokeDashoffset={isLoading ? circumference : strokeDashoffset}
              className="transition-all duration-1000 ease-out"
              style={{
                filter: isLoading ? 'none' : `drop-shadow(0 0 8px ${scoreColor}80)`,
              }}
            />
          </svg>
          
          {/* Center text */}
          <div className="absolute inset-0 flex flex-col items-center justify-center">
            {isLoading ? (
              <div className="w-8 h-8 border-2 border-slate-600 border-t-primary-glow rounded-full animate-spin" />
            ) : (
              <>
                <span 
                  className="text-3xl font-bold transition-colors duration-500"
                  style={{ color: scoreColor }}
                >
                  {normalizedScore}
                </span>
                <span className="text-xs text-slate-500">/100</span>
              </>
            )}
          </div>
        </div>
        
        {/* Score details */}
        <div className="flex-1 space-y-2">
          {isLoading ? (
            <div className="space-y-2">
              <div className="h-5 bg-slate-700 rounded animate-pulse w-24" />
              <div className="h-4 bg-slate-700/50 rounded animate-pulse w-32" />
            </div>
          ) : (
            <>
              <p 
                className="text-lg font-semibold transition-colors duration-500"
                style={{ color: scoreColor }}
              >
                {scoreLabel}
              </p>
              {label && (
                <p className="text-sm text-slate-400">{label}</p>
              )}
            </>
          )}
        </div>
      </div>
      
      {/* Score breakdown hint */}
      {!isLoading && score !== undefined && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <p className="text-xs text-slate-500">
            Based on footfall, competitor density & nearby landmarks
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Filters/BusinessTypeSelector.jsx">
/**
 * Business Type Selector Component
 * Step 1 in the user flow - Select what type of business you're opening
 */

import { useState, useRef, useEffect } from 'react';

// Business type options with icons and competitor mappings
const BUSINESS_TYPES = [
  { id: 'cafe', label: 'Cafe / Coffee Shop', icon: '' },
  { id: 'restaurant', label: 'Restaurant / Fast Food', icon: '' },
  { id: 'retail', label: 'Retail Store', icon: '' },
  { id: 'gym', label: 'Gym / Fitness Center', icon: '' },
  { id: 'pharmacy', label: 'Pharmacy / Medical', icon: '' },
  { id: 'salon', label: 'Salon / Spa', icon: '' },
  { id: 'electronics', label: 'Electronics Store', icon: '' },
  { id: 'clothing', label: 'Clothing / Fashion', icon: '' },
  { id: 'bookstore', label: 'Bookstore / Stationery', icon: '' },
  { id: 'other', label: 'Other (Custom)', icon: '' },
];

export default function BusinessTypeSelector({ value, onChange, disabled }) {
  const [isOpen, setIsOpen] = useState(false);
  const [customType, setCustomType] = useState('');
  const dropdownRef = useRef(null);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const selectedType = BUSINESS_TYPES.find((t) => t.id === value);

  const handleSelect = (type) => {
    if (type.id === 'other') {
      onChange(type.id);
      // Keep dropdown open for custom input
    } else {
      onChange(type.id);
      setIsOpen(false);
    }
  };

  const handleCustomSubmit = (e) => {
    e.preventDefault();
    if (customType.trim()) {
      onChange(customType.trim().toLowerCase());
      setIsOpen(false);
    }
  };

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-slate-400">
        Step 1: What are you opening?
      </label>
      
      <div className="relative" ref={dropdownRef}>
        {/* Trigger Button */}
        <button
          type="button"
          onClick={() => !disabled && setIsOpen(!isOpen)}
          disabled={disabled}
          className={`
            w-full flex items-center justify-between gap-3
            bg-canvas-base border rounded-lg px-4 py-3
            text-left transition-all duration-200
            ${isOpen 
              ? 'border-primary-glow shadow-glow-primary' 
              : 'border-surface-border hover:border-slate-600'
            }
            ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
          `}
        >
          <div className="flex items-center gap-3">
            <span className="text-xl">
              {selectedType?.icon || ''}
            </span>
            <span className={selectedType ? 'text-slate-50' : 'text-slate-500'}>
              {selectedType?.label || 'Select business type...'}
            </span>
          </div>
          <svg 
            className={`w-5 h-5 text-slate-400 transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`}
            fill="none" 
            viewBox="0 0 24 24" 
            stroke="currentColor"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
          </svg>
        </button>

        {/* Dropdown Menu - Fixed position to escape stacking context */}
        {isOpen && (
          <div 
            className="absolute left-0 right-0 mt-2 bg-canvas-base border border-surface-border rounded-lg shadow-glass overflow-hidden animate-slide-in-up"
            style={{ zIndex: 9999 }}
          >
            <div className="max-h-64 overflow-y-auto">
              {BUSINESS_TYPES.map((type) => (
                <button
                  key={type.id}
                  type="button"
                  onClick={() => handleSelect(type)}
                  className={`
                    w-full flex items-center gap-3 px-4 py-3
                    hover:bg-surface-elevated transition-colors duration-150
                    ${value === type.id ? 'bg-surface-secondary' : ''}
                  `}
                >
                  <span className="text-xl">{type.icon}</span>
                  <span className="flex-1 text-left text-slate-200">{type.label}</span>
                  {value === type.id && (
                    <svg className="w-5 h-5 text-primary-glow" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                    </svg>
                  )}
                </button>
              ))}
            </div>

            {/* Custom Input (shown when 'Other' is selected) */}
            {value === 'other' && (
              <form onSubmit={handleCustomSubmit} className="p-3 border-t border-surface-border">
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={customType}
                    onChange={(e) => setCustomType(e.target.value)}
                    placeholder="Enter custom type..."
                    className="glass-input flex-1 py-2 text-sm"
                    autoFocus
                  />
                  <button
                    type="submit"
                    className="px-4 py-2 bg-primary-glow text-canvas-deep text-sm font-medium rounded-lg hover:bg-primary-bright transition-colors"
                  >
                    Set
                  </button>
                </div>
              </form>
            )}
          </div>
        )}
      </div>

      {/* Validation hint */}
      {!value && (
        <p className="text-xs text-slate-500 flex items-center gap-1">
          <span className="text-warning-glow"></span>
          Required to identify competitors
        </p>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Filters/index.js">
export { default as BusinessTypeSelector } from './BusinessTypeSelector';
export { default as ProximityFilters } from './ProximityFilters';
</file>

<file path="frontend/src/components/Filters/ProximityFilters.jsx">
/**
 * Proximity Filters Component
 * Step 2 in the user flow - Select what you want nearby
 */

import { useState } from 'react';

// Proximity filter options with icons and POI mappings
const PROXIMITY_FILTERS = [
  { id: 'near_metro', label: 'Metro', icon: '', popular: true },
  { id: 'near_bus', label: 'Bus Stop', icon: '', popular: false },
  { id: 'near_school', label: 'School', icon: '', popular: false },
  { id: 'near_college', label: 'College', icon: '', popular: true },
  { id: 'near_hospital', label: 'Hospital', icon: '', popular: false },
  { id: 'near_mall', label: 'Mall', icon: '', popular: true },
  { id: 'near_office', label: 'Office/IT', icon: '', popular: true },
  { id: 'near_residential', label: 'Residential', icon: '', popular: false },
  { id: 'near_temple', label: 'Temple', icon: '', popular: false },
  { id: 'near_park', label: 'Park', icon: '', popular: false },
  { id: 'near_atm', label: 'ATM/Bank', icon: '', popular: false },
  { id: 'near_bar', label: 'Bar/Pub', icon: '', popular: false },
];

export default function ProximityFilters({ value = [], onChange, disabled }) {
  const [showAll, setShowAll] = useState(false);

  const toggleFilter = (filterId) => {
    if (disabled) return;
    
    const newFilters = value.includes(filterId)
      ? value.filter((f) => f !== filterId)
      : [...value, filterId];
    
    onChange(newFilters);
  };

  const selectPopular = () => {
    const popularFilters = PROXIMITY_FILTERS.filter((f) => f.popular).map((f) => f.id);
    onChange(popularFilters);
  };

  const clearAll = () => {
    onChange([]);
  };

  // Show only first 6 filters by default, or all if expanded
  const visibleFilters = showAll ? PROXIMITY_FILTERS : PROXIMITY_FILTERS.slice(0, 6);

  return (
    <div className="space-y-3 relative z-20">
      <div className="flex items-center justify-between">
        <label className="block text-sm font-medium text-slate-400">
          Step 2: What do you want nearby?
        </label>
        <span className="text-xs text-slate-500">
          {value.length} selected
        </span>
      </div>

      {/* Filter Chips Grid */}
      <div className={`grid grid-cols-3 gap-2 ${disabled ? 'opacity-50 pointer-events-none' : ''}`}>
        {visibleFilters.map((filter) => {
          const isActive = value.includes(filter.id);
          return (
            <button
              key={filter.id}
              type="button"
              onClick={() => toggleFilter(filter.id)}
              className={`
                chip flex flex-col items-center justify-center gap-1 py-2
                ${isActive ? 'chip-active' : 'chip-inactive'}
              `}
            >
              <span className="text-lg">{filter.icon}</span>
              <span className="text-xs truncate w-full text-center">{filter.label}</span>
            </button>
          );
        })}
      </div>

      {/* Show More / Less Toggle */}
      {PROXIMITY_FILTERS.length > 6 && (
        <button
          type="button"
          onClick={() => setShowAll(!showAll)}
          className="text-xs text-slate-500 hover:text-slate-300 transition-colors"
        >
          {showAll ? ' Show less' : `Show ${PROXIMITY_FILTERS.length - 6} more `}
        </button>
      )}

      {/* Quick Actions */}
      <div className="flex gap-2">
        <button
          type="button"
          onClick={selectPopular}
          disabled={disabled}
          className="flex-1 text-xs py-1.5 px-2 rounded border border-surface-border text-slate-400 hover:text-primary-bright hover:border-primary-glow transition-colors disabled:opacity-50"
        >
           Select Popular
        </button>
        <button
          type="button"
          onClick={clearAll}
          disabled={disabled || value.length === 0}
          className="flex-1 text-xs py-1.5 px-2 rounded border border-surface-border text-slate-400 hover:text-destructive-bright hover:border-destructive-glow transition-colors disabled:opacity-50"
        >
           Clear All
        </button>
      </div>

      {/* Optional hint */}
      <p className="text-xs text-slate-500">
        Optional  Filters affect score calculation
      </p>
    </div>
  );
}
</file>

<file path="frontend/src/components/Layout/Header.jsx">
/**
 * Header Component
 * App header with branding
 */

export default function Header() {
  return (
    <header className="bg-surface-elevated/80 backdrop-blur-sm border-b border-surface-border px-4 py-3 flex items-center justify-between">
      <div className="flex items-center gap-3">
        {/* Logo */}
        <div className="w-10 h-10 bg-gradient-to-br from-primary-glow to-accent-glow rounded-lg flex items-center justify-center shadow-glow-primary">
          <span className="text-xl"></span>
        </div>
        
        {/* Brand */}
        <div>
          <h1 className="text-lg font-bold text-slate-100 tracking-tight">
            Hotspot<span className="text-primary-glow">IQ</span>
          </h1>
          <p className="text-xs text-slate-500">
            Location Intelligence Platform
          </p>
        </div>
      </div>
      
      {/* Powered by */}
      <div className="flex items-center gap-2 text-xs text-slate-500">
        <span>Powered by</span>
        <span className="text-primary-glow font-medium">LatLong.ai</span>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/Layout/index.js">
export { default as Header } from './Header';
</file>

<file path="frontend/src/components/Map/HeatmapOverlay.jsx">
/**
 * Heatmap Overlay Component
 * Shows competition density as a heatmap overlay on the map
 * Red = High competition (avoid), Green = Low competition (opportunity)
 */

import { useEffect, useRef } from 'react';
import { useMap } from 'react-leaflet';
import L from 'leaflet';

/**
 * Generate heatmap data points based on competitors and landmarks
 * Creates a grid of points with intensity values
 */
function generateHeatmapGrid(center, competitors, landmarks, radius = 2500) {
  const gridSize = 20; // Number of grid cells in each direction
  const cellSize = (radius * 2) / gridSize;
  const points = [];
  
  // Convert radius from meters to degrees (approximate)
  const latDelta = radius / 111000; // 1 degree lat  111km
  const lngDelta = radius / (111000 * Math.cos(center.lat * Math.PI / 180));
  
  // Create grid
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      const lat = center.lat - latDelta + (i / gridSize) * 2 * latDelta;
      const lng = center.lng - lngDelta + (j / gridSize) * 2 * lngDelta;
      
      // Calculate competition intensity at this point
      let competitorScore = 0;
      let landmarkScore = 0;
      
      // Higher score = more competitors nearby = RED
      competitors.forEach(comp => {
        if (comp.lat && comp.lng) {
          const dist = getDistance(lat, lng, comp.lat, comp.lng);
          if (dist < cellSize * 2) {
            competitorScore += Math.max(0, 1 - dist / (cellSize * 2));
          }
        }
      });
      
      // Landmarks add opportunity (reduce competition effect slightly)
      landmarks.forEach(lm => {
        if (lm.lat && lm.lng) {
          const dist = getDistance(lat, lng, lm.lat, lm.lng);
          if (dist < cellSize * 2) {
            landmarkScore += Math.max(0, 0.3 * (1 - dist / (cellSize * 2)));
          }
        }
      });
      
      // Net intensity: positive = competition (red), negative = opportunity (green)
      // Normalize to 0-1 range
      const intensity = Math.min(1, Math.max(0, competitorScore - landmarkScore * 0.5));
      
      points.push({
        lat,
        lng,
        intensity,
        hasCompetitors: competitorScore > 0,
      });
    }
  }
  
  return points;
}

/**
 * Calculate distance between two points in meters
 */
function getDistance(lat1, lng1, lat2, lng2) {
  const R = 6371000; // Earth's radius in meters
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Get color based on intensity
 * Low intensity (0) = Green (opportunity)
 * High intensity (1) = Red (competition)
 */
function getHeatColor(intensity) {
  // Color gradient: Green -> Yellow -> Orange -> Red
  if (intensity < 0.25) {
    // Green to light green
    const t = intensity / 0.25;
    return {
      r: Math.round(34 + t * 100),
      g: Math.round(197 - t * 50),
      b: Math.round(94 - t * 50),
      a: 0.3 + t * 0.1
    };
  } else if (intensity < 0.5) {
    // Light green to yellow
    const t = (intensity - 0.25) / 0.25;
    return {
      r: Math.round(134 + t * 121),
      g: Math.round(147 + t * 53),
      b: Math.round(44 - t * 44),
      a: 0.4 + t * 0.1
    };
  } else if (intensity < 0.75) {
    // Yellow to orange
    const t = (intensity - 0.5) / 0.25;
    return {
      r: 255,
      g: Math.round(200 - t * 100),
      b: 0,
      a: 0.5 + t * 0.1
    };
  } else {
    // Orange to red
    const t = (intensity - 0.75) / 0.25;
    return {
      r: 255,
      g: Math.round(100 - t * 60),
      b: Math.round(t * 50),
      a: 0.6 + t * 0.15
    };
  }
}

export default function HeatmapOverlay({ 
  center, 
  competitors = [], 
  landmarks = [],
  radius = 2500,
  enabled = true 
}) {
  const map = useMap();
  const canvasRef = useRef(null);
  const overlayRef = useRef(null);

  useEffect(() => {
    if (!enabled || !center || !map) return;

    // Remove existing overlay
    if (overlayRef.current) {
      map.removeLayer(overlayRef.current);
    }

    // Generate heatmap points
    const points = generateHeatmapGrid(center, competitors, landmarks, radius);
    
    // If no competitors, don't show heatmap
    if (competitors.length === 0) return;

    // Calculate bounds
    const latDelta = radius / 111000;
    const lngDelta = radius / (111000 * Math.cos(center.lat * Math.PI / 180));
    const bounds = L.latLngBounds(
      [center.lat - latDelta, center.lng - lngDelta],
      [center.lat + latDelta, center.lng + lngDelta]
    );

    // Create canvas with higher resolution for smoother circle
    const canvas = document.createElement('canvas');
    const canvasSize = 400;
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const ctx = canvas.getContext('2d');

    // Define circular clipping region first
    const centerX = canvasSize / 2;
    const centerY = canvasSize / 2;
    const circleRadius = canvasSize / 2 - 2; // Slightly smaller for clean edge

    // Create circular clip path
    ctx.save();
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
    ctx.clip();

    // Draw heatmap cells within the circle
    const gridSize = 20;
    const cellWidth = canvasSize / gridSize;
    const cellHeight = canvasSize / gridSize;

    points.forEach((point, index) => {
      const i = Math.floor(index / gridSize);
      const j = index % gridSize;
      
      const x = j * cellWidth + cellWidth / 2;
      const y = (gridSize - 1 - i) * cellHeight + cellHeight / 2;
      
      // Check if point is within circle
      const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
      if (distFromCenter > circleRadius) return;
      
      const color = getHeatColor(point.intensity);
      const cellRadius = cellWidth * 1.0;
      
      // Create radial gradient for smooth effect
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, cellRadius);
      gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`);
      gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, cellRadius, 0, Math.PI * 2);
      ctx.fill();
    });

    // Restore context (removes clip)
    ctx.restore();

    // Draw circle border
    ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
    ctx.stroke();

    // Create image overlay
    const imageUrl = canvas.toDataURL();
    overlayRef.current = L.imageOverlay(imageUrl, bounds, {
      opacity: 0.7,
      interactive: false,
    });
    
    overlayRef.current.addTo(map);

    // Cleanup
    return () => {
      if (overlayRef.current) {
        map.removeLayer(overlayRef.current);
      }
    };
  }, [map, center, competitors, landmarks, radius, enabled]);

  return null;
}
</file>

<file path="frontend/src/components/Search/index.js">
export { default as SearchBar } from './SearchBar';
</file>

<file path="frontend/src/hooks/index.js">
export { default as useAnalysis } from './useAnalysis';
export { default as useLocation } from './useLocation';
export { default as useFilters } from './useFilters';
</file>

<file path="frontend/src/hooks/useFilters.js">
/**
 * useFilters Hook
 * Manages business type and proximity filter selections
 */

import { useState, useCallback, useMemo } from 'react';

// Popular filter presets
const POPULAR_FILTERS = ['metro', 'mall', 'office', 'college'];

export default function useFilters() {
  const [businessType, setBusinessType] = useState(null);
  const [proximityFilters, setProximityFilters] = useState([]);

  // Toggle a single proximity filter
  const toggleFilter = useCallback((filterId) => {
    setProximityFilters((prev) => {
      if (prev.includes(filterId)) {
        return prev.filter((f) => f !== filterId);
      }
      return [...prev, filterId];
    });
  }, []);

  // Select multiple filters at once
  const selectFilters = useCallback((filterIds) => {
    setProximityFilters(filterIds);
  }, []);

  // Select popular filters preset
  const selectPopularFilters = useCallback(() => {
    setProximityFilters(POPULAR_FILTERS);
  }, []);

  // Clear all proximity filters
  const clearFilters = useCallback(() => {
    setProximityFilters([]);
  }, []);

  // Clear everything (business type + filters)
  const clearAll = useCallback(() => {
    setBusinessType(null);
    setProximityFilters([]);
  }, []);

  // Check if a filter is selected
  const isFilterSelected = useCallback(
    (filterId) => proximityFilters.includes(filterId),
    [proximityFilters]
  );

  // Check if ready to analyze
  const canAnalyze = useMemo(() => {
    return businessType !== null;
  }, [businessType]);

  // Get filter summary for display
  const filterSummary = useMemo(() => {
    if (proximityFilters.length === 0) return 'No preferences set';
    if (proximityFilters.length === 1) return '1 preference';
    return `${proximityFilters.length} preferences`;
  }, [proximityFilters]);

  return {
    // State
    businessType,
    proximityFilters,
    canAnalyze,
    filterSummary,
    
    // Business Type Actions
    setBusinessType,
    
    // Proximity Filter Actions
    toggleFilter,
    selectFilters,
    selectPopularFilters,
    clearFilters,
    isFilterSelected,
    
    // Reset
    clearAll,
  };
}
</file>

<file path="frontend/src/hooks/useLocation.js">
/**
 * useLocation Hook
 * Manages selected location state
 */

import { useState, useCallback } from 'react';
import { searchLocations, geocodeLocation } from '../services/api';

export default function useLocation() {
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isGeocoding, setIsGeocoding] = useState(false);
  const [searchError, setSearchError] = useState(null);

  const search = useCallback(async (query) => {
    if (!query || query.length < 2) {
      setSearchResults([]);
      return;
    }

    setIsSearching(true);
    setSearchError(null);

    try {
      const results = await searchLocations(query);
      setSearchResults(results);
    } catch (error) {
      console.error('Search error:', error);
      setSearchError(error.message || 'Failed to search locations');
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  }, []);

  const selectLocation = useCallback(async (location) => {
    // If location already has coordinates, use it directly
    if (location.lat && location.lng) {
      setSelectedLocation(location);
      setSearchResults([]);
      return;
    }
    
    // Otherwise, geocode the location name to get coordinates
    setIsGeocoding(true);
    setSearchError(null);
    
    try {
      const geocoded = await geocodeLocation(location.name);
      setSelectedLocation({
        name: location.name,
        lat: geocoded.lat,
        lng: geocoded.lng,
        address: geocoded.address,
        geoid: location.geoid
      });
      setSearchResults([]);
    } catch (error) {
      console.error('Geocode error:', error);
      setSearchError('Could not find coordinates for this location');
      // Still set the location but without coordinates
      setSelectedLocation({
        ...location,
        lat: null,
        lng: null,
        needsGeocode: true
      });
    } finally {
      setIsGeocoding(false);
    }
  }, []);

  const selectFromCoords = useCallback((lat, lng, name = null) => {
    setSelectedLocation({
      lat,
      lng,
      name: name || `${lat.toFixed(4)}, ${lng.toFixed(4)}`,
    });
  }, []);

  const clearLocation = useCallback(() => {
    setSelectedLocation(null);
    setSearchResults([]);
    setSearchError(null);
  }, []);

  return {
    // State
    selectedLocation,
    searchResults,
    isSearching,
    isGeocoding,
    searchError,
    
    // Actions
    search,
    selectLocation,
    selectFromCoords,
    clearLocation,
  };
}
</file>

<file path="frontend/src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import 'leaflet/dist/leaflet.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Canvas - Background layers
        canvas: {
          deep: '#020617',  // slate-950
          base: '#0f172a',  // slate-900
        },
        // Surface - Glass layers
        surface: {
          primary: 'rgba(15, 23, 42, 0.8)',
          secondary: 'rgba(30, 41, 59, 0.7)',
          elevated: 'rgba(51, 65, 85, 0.6)',
          border: 'rgba(255, 255, 255, 0.08)',
        },
        // Primary - Neon Emerald
        primary: {
          glow: '#10b981',     // emerald-500
          bright: '#34d399',   // emerald-400
          soft: 'rgba(16, 185, 129, 0.2)',
          pulse: 'rgba(16, 185, 129, 0.5)',
        },
        // Warning - Amber
        warning: {
          glow: '#f59e0b',     // amber-500
          soft: 'rgba(245, 158, 11, 0.2)',
        },
        // Destructive - Rose
        destructive: {
          glow: '#f43f5e',     // rose-500
          bright: '#fb7185',   // rose-400
          soft: 'rgba(244, 63, 94, 0.2)',
        },
        // Accent
        accent: {
          cyan: '#06b6d4',     // cyan-500
          violet: '#8b5cf6',   // violet-500
        }
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
        mono: ['JetBrains Mono', 'Fira Code', 'Consolas', 'monospace'],
      },
      boxShadow: {
        'glow-primary': '0 0 20px rgba(16, 185, 129, 0.4), 0 0 40px rgba(16, 185, 129, 0.2)',
        'glow-warning': '0 0 20px rgba(245, 158, 11, 0.4), 0 0 40px rgba(245, 158, 11, 0.2)',
        'glow-destructive': '0 0 20px rgba(244, 63, 94, 0.4), 0 0 40px rgba(244, 63, 94, 0.2)',
        'glow-violet': '0 0 20px rgba(139, 92, 246, 0.4), 0 0 40px rgba(139, 92, 246, 0.2)',
        'glass': '0 8px 32px rgba(0, 0, 0, 0.4)',
      },
      backdropBlur: {
        'glass': '12px',
      },
      animation: {
        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'slide-in-right': 'slideInRight 0.4s ease-out',
        'slide-in-up': 'slideInUp 0.3s ease-out',
        'fade-in': 'fadeIn 0.2s ease-out',
        'glow-pulse': 'glowPulse 2s ease-in-out infinite',
      },
      keyframes: {
        slideInRight: {
          '0%': { transform: 'translateX(20px)', opacity: '0' },
          '100%': { transform: 'translateX(0)', opacity: '1' },
        },
        slideInUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        glowPulse: {
          '0%, 100%': { boxShadow: '0 0 20px rgba(16, 185, 129, 0.4)' },
          '50%': { boxShadow: '0 0 30px rgba(16, 185, 129, 0.6), 0 0 60px rgba(16, 185, 129, 0.3)' },
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="frontend/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true
  }
})
</file>

<file path="README.md">
#  Hotspot IQ

<div align="center">

![Hotspot IQ](https://img.shields.io/badge/Hotspot-IQ-blue?style=for-the-badge&logo=mapbox&logoColor=white)
![Python](https://img.shields.io/badge/Python-Flask-green?style=for-the-badge&logo=python&logoColor=white)
![React](https://img.shields.io/badge/React-Vite-61DAFB?style=for-the-badge&logo=react&logoColor=black)
![AI Powered](https://img.shields.io/badge/AI-Powered-orange?style=for-the-badge&logo=openai&logoColor=white)

### **Hyper-Local Location Intelligence for Smarter Business Expansion**

*Stop guessing. Start knowing. Make data-driven decisions for your next store location.*

[Demo](#demo)  [Features](#features)  [Architecture](#architecture)  [Setup](#setup)  [API Docs](#api-documentation)

</div>

---

##  The Problem: Blind Expansion Kills Businesses

**60% of new retail stores fail within the first 3 years.** The #1 reason? **Poor location selection.**

Business owners today rely on:
-  Gut feeling and "foot traffic looks good"
-  Expensive consultants with outdated data
-  Generic tools not built for Indian contexts (pincodes, local landmarks)
-  No visibility into future infrastructure developments

**The cost of a wrong location decision:** 15-50 lakhs in sunk costs, 12-18 months of wasted effort.

---

##  The Solution: Hotspot IQ

Hotspot IQ is an **AI-powered location intelligence platform** that helps entrepreneurs, franchise owners, and retail chains validate potential store locations using:

| Feature | What It Does |
|---------|--------------|
|  **Opportunity Score** | Proprietary algorithm combining footfall, landmarks, and competition |
|  **Hyper-Local Data** | Powered by LatLong.ai for accurate Indian context (pincodes, Digipin) |
|  **AI Advisor** | Ask natural language questions like "Is this good for a gym?" |
|  **Growth Radar** | Scans news for upcoming infrastructure that could boost location value |
|  **Supply Chain Check** | Validates logistics feasibility from your warehouse |

---

##  Features

### Phase 1: Descriptive Analytics (Core)
- **Smart Location Search**  Autocomplete powered by LatLong.ai
- **Competitor Density Mapping**  See how many cafes, ATMs, gyms exist nearby
- **Landmark Intelligence**  Identify proximity to schools, metros, colleges
- **Opportunity Score Dashboard**  One number that tells you if a location is worth it
- **Interactive Heatmaps**  Visual overlay showing business potential

### Phase 2: Interactive Intelligence
- **Isochrone Visualization**  See exactly what's reachable in a 15-min bike/walk radius
- **GenAI Chat ("Ask Hotspot")**  Get AI-powered advice based on real POI data
- **Digipin Integration**  Share exact locations with investors using India's digital address code

### Phase 3: Future Radar & Operations
- **Growth Radar**  AI scans news for "New metro station in Whitefield" type developments
- **Supply Chain Validator**  Enter warehouse location, get logistics feasibility score

---

##  How It Works  User Flow

Hotspot IQ follows a **guided 4-step flow** to ensure users provide the right context before analysis:

```

                          USER JOURNEY FLOW                                  

                                                                             
   STEP 1              STEP 2              STEP 3              STEP 4       
                                           
                                                        
    Type            Filter           Search           Analyze       
                                           
   "What are          "What do           "Where do          "Show me       
    you starting?"     you need           you want           the data!"    
                       nearby?"           to open?"                        
                                                                             

```

### Step 1: Select Business Type 

The user **first selects what type of business** they are planning to open. This is critical because:
- It determines which POIs are counted as **competitors** (e.g., selecting "Cafe"  all nearby cafes are competitors)
- It influences the **Opportunity Score algorithm** weights
- It customizes AI recommendations in the chat

**Available Business Types:**
| Category | Icon | Competitor POI Categories |
|----------|------|---------------------------|
| Cafe / Coffee Shop |  | cafe, coffee_shop, bakery |
| Restaurant |  | restaurant, fast_food, food_court |
| Retail Store |  | retail, supermarket, convenience_store |
| Gym / Fitness Center |  | gym, fitness_center, sports_club |
| Pharmacy / Medical |  | pharmacy, clinic, medical_store |
| Salon / Spa |  | salon, spa, beauty_parlor |
| Electronics Store |  | electronics, mobile_shop, computer_store |
| Clothing / Fashion |  | clothing_store, boutique, fashion |
| Bookstore / Stationery |  | bookstore, stationery, office_supplies |
| Other (Custom) |  | User specifies custom category |

### Step 2: Select Proximity Preferences 

Next, the user selects **what they want nearby** using checkbox filters. These preferences:
- Add **bonus points** to the Opportunity Score when present
- Help identify locations that match the user's ideal criteria
- Filter the map to highlight relevant landmarks

**Available Proximity Filters:**
| Filter | Icon | Why It Matters |
|--------|------|----------------|
| Near Metro Station |  | High footfall, easy accessibility |
| Near Bus Stop |  | Public transit increases customer base |
| Near School |  | Family traffic, afternoon rush |
| Near College/University |  | Young demographic, evening crowd |
| Near Hospital |  | Essential services traffic |
| Near Mall/Shopping Complex |  | Captive audience, high spending power |
| Near Office Complex/IT Park |  | Weekday lunch & after-work crowd |
| Near Residential Area |  | Daily needs, repeat customers |
| Near Temple/Religious Place |  | Weekend/festival traffic |
| Near Park/Recreation |  | Morning/evening joggers, families |
| Near ATM/Bank |  | Financial convenience |
| Near Bar/Pub |  | Nightlife synergy (for restaurants/cafes) |

### Step 3: Search Location 

Now the user searches for a specific location using the **autocomplete search bar**:
- Powered by LatLong.ai Autocomplete API
- Supports addresses, landmarks, pincodes, and place names
- Shows suggestions as user types (debounced 300ms)
- Selecting a suggestion centers the map and drops a marker

### Step 4: Analyze & View Results 

Once location is selected, clicking **"Analyze Location"** triggers:
1. Backend fetches competitor POIs (based on Step 1 business type)
2. Backend fetches landmark POIs (based on Step 2 filters)
3. Opportunity Score is calculated
4. Dashboard cards animate in with results
5. Map updates with competitor markers and heatmap

---

##  Architecture

```mermaid
flowchart TB
    subgraph Client[" Frontend (React + Vite)"]
        UI[React Components]
        Map[React-Leaflet Map]
        Charts[Recharts Dashboard]
        Chat[Chat Widget]
    end

    subgraph BFF[" Backend-for-Frontend (Flask)"]
        API[Flask REST API]
        Score[Score Engine]
        Cache[Response Cache]
    end

    subgraph External[" External APIs"]
        LL[LatLong.ai]
        OAI[OpenAI GPT-4o mini]
        DDG[DuckDuckGo Search]
    end

    UI --> API
    Map --> API
    Chat --> API
    
    API --> LL
    API --> OAI
    API --> DDG
    
    LL --> |Geocoding, POI, Isochrones| API
    OAI --> |Natural Language Analysis| API
    DDG --> |Future News Search| API
    
    API --> Score
    Score --> Charts

    style Client fill:#e1f5fe
    style BFF fill:#fff3e0
    style External fill:#f3e5f5
```

### Why Backend-for-Frontend (BFF)?
1. **Security**  API keys never exposed to browser
2. **Aggregation**  Combine multiple API calls into one response
3. **Transformation**  Shape data exactly as frontend needs it
4. **Caching**  Reduce API costs by caching frequent queries

---

##  Tech Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Frontend** | React 18 + Vite | Fast, modern UI framework |
| **Styling** | Tailwind CSS | Utility-first CSS |
| **Maps** | React-Leaflet | Interactive map rendering |
| **Charts** | Recharts | Analytics visualization |
| **Backend** | Python Flask | REST API server |
| **Data** | Pandas | Data manipulation |
| **AI** | OpenAI GPT-4o mini | Natural language analysis |
| **Geo APIs** | LatLong.ai | Indian geospatial data |
| **Search** | DuckDuckGo | News & web search |

---

##  Setup Instructions

### Prerequisites
- Node.js 18+ & npm
- Python 3.10+
- API Keys: LatLong.ai, OpenAI

### 1. Clone the Repository
```bash
git clone https://github.com/your-team/hotspot-iq.git
cd hotspot-iq
```

### 2. Backend Setup
```bash
cd backend

# Create virtual environment
python -m venv venv

# Activate (Windows)
.\venv\Scripts\activate

# Activate (Mac/Linux)
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Configure environment
copy .env.example .env
# Edit .env with your API keys
```

### 3. Frontend Setup
```bash
cd frontend

# Install dependencies
npm install

# Configure environment
copy .env.example .env
# Edit .env if needed
```

### 4. Environment Variables

**Backend `.env`:**
```env
FLASK_ENV=development
FLASK_DEBUG=True
LATLONG_API_KEY=your_latlong_api_key
OPENAI_API_KEY=your_openai_api_key
```

**Frontend `.env`:**
```env
VITE_API_BASE_URL=http://localhost:5000/api
```

### 5. Run the Application

**Terminal 1  Backend:**
```bash
cd backend
python app.py
# Server runs on http://localhost:5000
```

**Terminal 2  Frontend:**
```bash
cd frontend
npm run dev
# App runs on http://localhost:5173
```

---

##  API Documentation

### Base URL
```
http://localhost:5000/api
```

### Endpoints

####  Location Search
```http
GET /api/autocomplete?query={search_term}
```
Returns location suggestions for autocomplete dropdown.

**Response:**
```json
{
  "suggestions": [
    { "place_id": "abc123", "name": "Indiranagar, Bangalore", "lat": 12.97, "lng": 77.64 }
  ]
}
```

---

####  Location Analysis
```http
POST /api/analyze
Content-Type: application/json

{
  "lat": 12.9716,
  "lng": 77.5946,
  "business_type": "cafe",
  "filters": ["near_metro", "near_college"]
}
```
Returns comprehensive location analysis including opportunity score.

**Response:**
```json
{
  "opportunity_score": 78,
  "competitors": { "count": 12, "nearby": [...] },
  "landmarks": { "metro": 2, "schools": 5, "colleges": 1 },
  "footfall_proxy": "high",
  "recommendation": "Strong potential for cafe"
}
```

---

####  Isochrone (Reachability)
```http
POST /api/isochrone
Content-Type: application/json

{
  "lat": 12.9716,
  "lng": 77.5946,
  "mode": "bike",
  "time_minutes": 15
}
```
Returns GeoJSON polygon for isochrone visualization.

**Response:**
```json
{
  "type": "Feature",
  "geometry": {
    "type": "Polygon",
    "coordinates": [[[77.59, 12.97], ...]]
  }
}
```

---

####  AI Chat
```http
POST /api/chat
Content-Type: application/json

{
  "message": "Is this location good for a gym?",
  "context": {
    "lat": 12.9716,
    "lng": 77.5946
  }
}
```
Returns AI-powered location advice.

**Response:**
```json
{
  "response": "Based on the data, this location shows strong potential for a gym. There are 3 corporate offices within 1km, high residential density, and only 1 competing gym. The footfall proxy indicates high morning and evening activity.",
  "data_sources": ["poi", "landmarks", "competitors"]
}
```

---

####  Digipin Lookup
```http
GET /api/digipin?lat={lat}&lng={lng}
```
Returns the official Digipin (Digital Address Code) for a location.

**Response:**
```json
{
  "digipin": "MH-12-ABC-1234",
  "formatted_address": "123, MG Road, Indiranagar, Bangalore - 560038"
}
```

---

####  Growth Radar
```http
POST /api/growth-radar
Content-Type: application/json

{
  "location": "Whitefield, Bangalore"
}
```
Returns news about infrastructure developments.

**Response:**
```json
{
  "developments": [
    {
      "title": "New Metro Line Extension to Whitefield",
      "source": "Economic Times",
      "date": "2025-01-15",
      "impact": "positive",
      "summary": "Expected to increase footfall by 40%"
    }
  ],
  "growth_outlook": "bullish"
}
```

---

####  Supply Chain Check
```http
POST /api/supply-chain
Content-Type: application/json

{
  "store_lat": 12.9716,
  "store_lng": 77.5946,
  "warehouse_lat": 13.0827,
  "warehouse_lng": 77.5877
}
```
Returns logistics feasibility analysis.

**Response:**
```json
{
  "distance_km": 18.5,
  "drive_time_minutes": 52,
  "feasibility": "warning",
  "message": "High Logistics Cost - Drive time exceeds 45 minutes",
  "recommendation": "Consider a closer warehouse or factor in higher delivery costs"
}
```

---

##  The Opportunity Score Algorithm

```
Opportunity Score = (Footfall Proxy  Landmark Value) / (Competitor Density + 1)
```

| Factor | Calculation | Weight |
|--------|-------------|--------|
| **Footfall Proxy** | Based on nearby transit, offices, residential density | 0-100 |
| **Landmark Value** | Weighted sum of valuable nearby POIs | 0-50 |
| **Competitor Density** | Count of similar businesses in 1km radius | Divisor |

**Score Interpretation:**
-  **70-100:** Prime Location  Move fast!
-  **40-69:** Moderate Potential  Needs differentiation
-  **0-39:** High Risk  Reconsider or pivot

---

##  Demo

*Screenshots and demo video coming soon!*

---

##  Team

Built with  for [Hackathon Name] 2025

| Role | Name |
|------|------|
| **Product & Architecture** | [Your Name] |
| **Frontend** | [Team Member] |
| **Backend** | [Team Member] |
| **AI/ML** | [Team Member] |

---

##  License

MIT License  Built for the hackathon, open for the community.

---

<div align="center">

** Hotspot IQ  Because your next location decision shouldn't be a gamble.**

[ Back to Top](#-hotspot-iq)

</div>
</file>

<file path="TASKS.md">
#  Hotspot IQ  Implementation Roadmap

> **Track your progress!** Check off tasks as you complete them.
> 
> **Estimated Total Time:** 24-32 hours (Hackathon Sprint)

---

##  Phase 0: Project Setup & Foundation

### Environment Setup
- [x] Create project root directory structure
  ```
  hotspot-iq/
   backend/
   frontend/
   docs/
   README.md
  ```
- [x] Initialize Git repository with `.gitignore`
- [x] Create `backend/.gitignore` (include `venv/`, `__pycache__/`, `.env`)
- [x] Create `frontend/.gitignore` (include `node_modules/`, `.env`, `dist/`)

### Backend Scaffolding
- [x] Create Python virtual environment (`python -m venv venv`)
- [x] Create `backend/requirements.txt`:
  ```
  flask==3.0.0
  flask-cors==4.0.0
  python-dotenv==1.0.0
  requests==2.31.0
  pandas==2.1.0
  openai==1.6.0
  duckduckgo-search==4.1.0
  ```
- [x] Install dependencies (`pip install -r requirements.txt`)
- [x] Create `backend/.env.example` with placeholder keys
- [x] Create `backend/.env` with actual API keys (DO NOT COMMIT!)
- [x] Create basic `backend/app.py` with Flask boilerplate
- [x] Add CORS configuration for frontend origin
- [ ] Test server starts on `http://localhost:5000`

### Frontend Scaffolding
- [x] Initialize Vite React project (`npm create vite@latest frontend -- --template react`)
- [x] Install core dependencies:
  ```bash
  npm install react-leaflet leaflet recharts axios tailwindcss postcss autoprefixer
  ```
- [x] Initialize Tailwind CSS (`npx tailwindcss init -p`)
- [x] Configure `tailwind.config.js` with content paths
- [x] Add Tailwind directives to `src/index.css`
- [x] Create `frontend/.env.example`
- [x] Create `frontend/.env` with `VITE_API_BASE_URL=http://localhost:5000/api`
- [ ] Test frontend starts on `http://localhost:5173`

### Project Structure
- [x] Create backend folder structure:
  ```
  backend/
   app.py
   config.py
   requirements.txt
   .env
   services/
      __init__.py
      latlong_service.py
      openai_service.py
      search_service.py
   routes/
      __init__.py
      location_routes.py
      analysis_routes.py
      chat_routes.py
   utils/
       __init__.py
       score_calculator.py
  ```
- [x] Create frontend folder structure:
  ```
  frontend/src/
   components/
      Map/
      Search/
      Dashboard/
      Chat/
      common/
   hooks/
   services/
   utils/
   pages/
  ```

---

##  Phase 1: Backend  Core Services

### Configuration Module
- [x] Create `backend/config.py` with environment variable loading
- [x] Implement API key validation on startup
- [x] Add configuration for API base URLs

### LatLong Service Wrapper (`services/latlong_service.py`)
- [x] Create base HTTP client with API key header
- [x] Implement `autocomplete(query: str)` method
  - [x] Call LatLong Autocomplete API
  - [x] Parse and return formatted suggestions
  - [x] Handle API errors gracefully
- [x] Implement `reverse_geocode(lat: float, lng: float)` method
  - [x] Get address details from coordinates
  - [x] Extract landmarks and POI info
- [x] Implement `get_poi(lat: float, lng: float, category: str, radius: int)` method
  - [x] Fetch POIs by category (cafe, atm, gym, etc.)
  - [x] Return count and list of nearby POIs
- [x] Implement `get_isochrone(lat: float, lng: float, mode: str, time: int)` method
  - [x] Call Isochrone API
  - [x] Return GeoJSON polygon
- [x] Implement `get_digipin(lat: float, lng: float)` method
  - [x] Fetch Digipin code
  - [x] Return formatted address
- [x] Implement `distance_matrix(origins: list, destinations: list)` method
  - [x] Calculate drive times between points
  - [x] Parse duration and distance from response
- [ ] Add request caching (optional, for demo performance)
- [ ] Write unit tests for each method

### Score Calculator (`utils/score_calculator.py`)
- [x] Define score constants and weights:
  ```python
  LANDMARK_WEIGHTS = {
      'metro_station': 15,
      'bus_stop': 5,
      'school': 10,
      'college': 12,
      'hospital': 8,
      'mall': 15,
      'office_complex': 12
  }
  ```
- [x] Implement `calculate_footfall_proxy(landmarks: dict, poi_data: dict)` function
- [x] Implement `calculate_landmark_value(landmarks: dict)` function
- [x] Implement `calculate_competitor_density(competitors: list, radius: float)` function
- [x] Implement `calculate_opportunity_score(footfall, landmark_value, competitor_density)` function
  - [x] Formula: `(footfall * landmark_value) / (competitor_density + 1)`
  - [x] Normalize to 0-100 scale
- [x] Implement `get_score_interpretation(score: int)` function
  - [x] Return category (Prime/Moderate/High Risk)
  - [x] Return recommendation text
- [ ] Write unit tests with sample data

### Location Routes (`routes/location_routes.py`)
- [x] Create Flask Blueprint for location routes
- [x] Implement `GET /api/autocomplete`
  - [x] Accept `query` parameter
  - [x] Call LatLong service
  - [x] Return JSON suggestions
- [x] Implement `GET /api/reverse-geocode`
  - [x] Accept `lat`, `lng` parameters
  - [x] Return address and landmark info
- [x] Implement `GET /api/digipin`
  - [x] Accept `lat`, `lng` parameters
  - [x] Return Digipin code

### Analysis Routes (`routes/analysis_routes.py`)
- [x] Create Flask Blueprint for analysis routes
- [x] Implement `POST /api/analyze`
  - [x] Accept JSON body: `{ lat, lng, business_type, filters }`
  - [x] Orchestrate multiple LatLong API calls:
    - [x] Get nearby competitors (same business type)
    - [x] Get nearby landmarks
    - [x] Get reverse geocode data
  - [x] Calculate opportunity score
  - [x] Return comprehensive analysis response
- [x] Implement `POST /api/isochrone`
  - [x] Accept JSON body: `{ lat, lng, mode, time_minutes }`
  - [x] Return GeoJSON polygon
- [x] Add input validation with error messages

### Integration & Testing
- [x] Register all blueprints in `app.py`
- [ ] Test all endpoints with Postman/curl
- [x] Handle and log API errors
- [x] Add request logging middleware

---

##  Phase 1: Frontend  Core UI

### API Service Layer (`services/api.js`)
- [x] Create Axios instance with base URL from env
- [x] Implement `searchLocations(query)` function
- [x] Implement `analyzeLocation(lat, lng, businessType, filters)` function
- [x] Implement `getIsochrone(lat, lng, mode, time)` function
- [x] Implement `getDigipin(lat, lng)` function
- [x] Implement `chat(message, context)` function
- [x] Add error handling wrapper

### Layout & Navigation
- [x] Create `components/Layout/Header.jsx` with logo and tagline
- [ ] Create `components/Layout/Sidebar.jsx` for filters
- [x] Create main `App.jsx` layout structure
- [x] Add responsive grid (sidebar + map + dashboard)

### Search Component (`components/Search/`)
- [x] Create `SearchBar.jsx` with autocomplete input
- [x] Implement debounced API calls (300ms delay)
- [x] Create `SearchSuggestions.jsx` dropdown list
- [x] Handle suggestion selection  update map
- [x] Add loading spinner during search
- [x] Style with Tailwind (rounded, shadow, etc.)

### Step 1: Business Type Selector (FIRST in user flow)
- [x] Create `components/Filters/BusinessTypeSelector.jsx`
- [x] Add dropdown with business types (with icons):
  - [x]  Cafe / Coffee Shop
  - [x]  Restaurant / Fast Food
  - [x]  Retail Store
  - [x]  Gym / Fitness Center
  - [x]  Pharmacy / Medical Store
  - [x]  Salon / Spa
  - [x]  Electronics Store
  - [x]  Clothing / Fashion
  - [x]  Bookstore / Stationery
  - [x]  Other (custom input field appears)
- [x] Store selected business type in global state
- [x] Map business type to competitor POI categories:
  ```javascript
  const COMPETITOR_MAPPING = {
    'cafe': ['cafe', 'coffee_shop', 'bakery'],
    'restaurant': ['restaurant', 'fast_food', 'food_court'],
    'gym': ['gym', 'fitness_center', 'sports_club'],
    // ... etc
  };
  ```
- [x] Disable "Analyze" button until business type is selected
- [x] Show validation message if user tries to skip

### Step 2: Proximity Preference Filters (SECOND in user flow)
- [x] Create `components/Filters/ProximityFilters.jsx`
- [x] Create `components/Filters/FilterChip.jsx` (individual chip component)
- [x] Add checkbox filter options with icons:
  - [x]  Near Metro Station
  - [x]  Near Bus Stop
  - [x]  Near School
  - [x]  Near College/University
  - [x]  Near Hospital
  - [x]  Near Mall/Shopping Complex
  - [x]  Near Office/IT Park
  - [x]  Near Residential Area
  - [x]  Near Temple/Religious Place
  - [x]  Near Park/Recreation
  - [x]  Near ATM/Bank
  - [x]  Near Bar/Pub
- [x] Implement multi-select toggle functionality
- [x] Visual feedback: selected chips glow green, unselected are muted
- [x] Store selected filters array in global state
- [x] Add "Clear All" and "Select Popular" quick actions
- [x] Map filter names to POI categories for API calls:
  ```javascript
  const FILTER_POI_MAPPING = {
    'near_metro': 'metro_station',
    'near_school': 'school',
    'near_college': 'college',
    // ... etc
  };
  ```

### Map Component (`components/Map/`)
- [x] Create `MapContainer.jsx` with React-Leaflet
- [x] Set default center to Bangalore (12.9716, 77.5946)
- [x] Add OpenStreetMap tile layer
- [x] Create `LocationMarker.jsx` for selected location
- [x] Create `CompetitorMarkers.jsx` for nearby competitors
- [x] Create `LandmarkMarkers.jsx` with different icons
- [ ] Create `HeatmapLayer.jsx` for opportunity visualization
- [x] Implement click-to-select location
- [x] Add zoom controls and fullscreen button

### Dashboard Component (`components/Dashboard/`)
- [x] Create `ScoreCard.jsx`  large opportunity score display
  - [x] Color coded: green/yellow/red
  - [x] Score interpretation text
- [x] Create `CompetitorCard.jsx`  competitor count & list
- [x] Create `LandmarksCard.jsx`  nearby landmarks breakdown
- [x] Create `MetricsGrid.jsx`  footfall, density stats
- [x] Style cards with shadows and hover effects

### Charts (`components/Dashboard/Charts/`)
- [x] Create `CompetitorChart.jsx`  bar chart of competitor types
- [x] Create `LandmarkRadar.jsx`  radar chart of landmark categories
- [x] Create `ScoreGauge.jsx`  circular gauge for score
- [x] Use Recharts with consistent color theme

### State Management
- [x] Create `hooks/useLocation.js`  manage selected location
- [x] Create `hooks/useAnalysis.js`  manage analysis data
- [x] Create `hooks/useFilters.js`  manage filter selections
- [x] Wire up state flow: Search  Map  Analysis  Dashboard

### Integration Testing
- [ ] Test search  select  analyze flow
- [ ] Verify map updates correctly
- [ ] Verify dashboard shows correct data
- [ ] Test error states (API down, no results)
- [ ] Test loading states

---

##  Phase 2: Advanced Features

### Isochrone Visualization
- [ ] Create `components/Map/IsochroneLayer.jsx`
- [ ] Add mode selector (walk/bike/car)
- [ ] Add time selector (5/10/15/30 mins)
- [ ] Fetch isochrone on selection change
- [ ] Render GeoJSON polygon on map
- [ ] Style polygon with semi-transparent fill
- [ ] Add legend for isochrone

### OpenAI Service (`services/openai_service.py`)
- [ ] Create OpenAI client initialization
- [ ] Design system prompt for location advisor:
  ```
  You are Hotspot IQ, an expert location intelligence advisor for 
  businesses in India. Analyze the provided data about a location 
  and give practical, actionable advice.
  ```
- [ ] Implement `generate_advice(user_question, location_data)` function
- [ ] Format location data as context for GPT
- [ ] Handle rate limits and errors
- [ ] Add response streaming (optional)

### Chat Routes (`routes/chat_routes.py`)
- [ ] Create Flask Blueprint for chat
- [ ] Implement `POST /api/chat`
  - [ ] Accept JSON: `{ message, context: { lat, lng } }`
  - [ ] Fetch location data from LatLong
  - [ ] Build prompt with context
  - [ ] Call OpenAI service
  - [ ] Return AI response

### Chat Widget (`components/Chat/`)
- [ ] Create `ChatWidget.jsx`  floating button + panel
- [ ] Create `ChatMessage.jsx`  message bubble component
- [ ] Create `ChatInput.jsx`  input with send button
- [ ] Implement message history state
- [ ] Add typing indicator during AI response
- [ ] Style as floating widget (bottom-right)
- [ ] Add minimize/maximize toggle
- [ ] Add suggested questions:
  - [ ] "Is this good for a [business_type]?"
  - [ ] "What's the competition like?"
  - [ ] "What landmarks are nearby?"

### Digipin Integration
- [ ] Add Digipin fetch to analysis flow
- [ ] Create `components/Dashboard/DigipinCard.jsx`
- [ ] Display Digipin code prominently
- [ ] Add "Copy to Clipboard" button
- [ ] Add "Share Location" button (generate shareable link)

### UI Polish
- [ ] Add loading skeletons for all cards
- [ ] Add error boundaries
- [ ] Add empty states with helpful messages
- [ ] Implement toast notifications
- [ ] Add keyboard shortcuts (Escape to close, Enter to search)

---

##  Phase 3: Moonshot Features

### DuckDuckGo Search Service (`services/search_service.py`)
- [ ] Install and configure `duckduckgo-search`
- [ ] Implement `search_infrastructure_news(location: str)` function
- [ ] Search queries:
  - [ ] "Infrastructure projects in {location}"
  - [ ] "New metro {location}"
  - [ ] "Real estate development {location}"
  - [ ] "Commercial construction {location}"
- [ ] Parse and deduplicate results
- [ ] Extract relevant snippets

### Growth Radar Feature
- [ ] Create `routes/growth_routes.py`
- [ ] Implement `POST /api/growth-radar`
  - [ ] Accept location name
  - [ ] Call search service
  - [ ] Analyze sentiment (positive/negative impact)
  - [ ] Return structured developments list
- [ ] Create `components/Dashboard/GrowthRadar.jsx`
  - [ ] List upcoming developments
  - [ ] Show impact indicator (bullish/bearish)
  - [ ] Link to source articles

### Supply Chain Validator
- [ ] Implement `POST /api/supply-chain` endpoint
  - [ ] Accept store and warehouse coordinates
  - [ ] Call LatLong Distance Matrix API
  - [ ] Calculate drive time
  - [ ] Apply logic:
    - [ ] < 30 mins:  Excellent
    - [ ] 30-45 mins:  Acceptable
    - [ ] > 45 mins:  High Logistics Cost
  - [ ] Return feasibility assessment
- [ ] Create `components/SupplyChain/WarehouseInput.jsx`
  - [ ] Search for warehouse location
  - [ ] Display on map with route line
- [ ] Create `components/SupplyChain/FeasibilityCard.jsx`
  - [ ] Show drive time and distance
  - [ ] Color-coded status
  - [ ] Recommendation text

### Advanced Map Features
- [ ] Add draw polygon tool for custom areas
- [ ] Add multiple location comparison
- [ ] Add "Find best location" auto-suggestion
- [ ] Add street view integration (if available)

---

##  Phase 4: Demo & Polish (Hackathon Prep)

### Demo Data & Fallbacks
- [ ] Create mock data for demo locations (Indiranagar, Koramangala, HSR)
- [ ] Add fallback data if APIs fail
- [ ] Pre-cache common searches

### Performance Optimization
- [ ] Add API response caching (Redis or in-memory)
- [ ] Implement request debouncing
- [ ] Lazy load map components
- [ ] Optimize bundle size

### UI/UX Polish
- [ ] Add onboarding tour for first-time users
- [ ] Add tooltips explaining each metric
- [ ] Ensure mobile responsiveness
- [ ] Add dark mode toggle (optional)
- [ ] Add print/export report feature

### Documentation & Presentation
- [ ] Record demo video (2-3 minutes)
- [ ] Create presentation slides
- [ ] Prepare live demo script
- [ ] Document known limitations
- [ ] Prepare FAQ for judges

### Final Testing
- [ ] End-to-end testing of all flows
- [ ] Test with real API keys
- [ ] Test error scenarios
- [ ] Test on multiple browsers
- [ ] Performance testing

---

##  Progress Tracker

| Phase | Tasks | Completed | Status |
|-------|-------|-----------|--------|
| Phase 0 | 18 | 16 |  Almost Done |
| Phase 1 Backend | 28 | 26 |  Almost Done |
| Phase 1 Frontend | 35 | 35 |  Complete |
| Phase 2 | 25 | 0 |  Not Started |
| Phase 3 | 18 | 0 |  Not Started |
| Phase 4 | 16 | 0 |  Not Started |
| **Total** | **140** | **77** | **55%** |

---

##  Quick Start Commands

```bash
# Backend
cd backend
python -m venv venv
.\venv\Scripts\activate  # Windows
pip install -r requirements.txt
python app.py

# Frontend
cd frontend
npm install
npm run dev
```

---

##  Troubleshooting

| Issue | Solution |
|-------|----------|
| CORS errors | Check Flask-CORS config, verify frontend URL |
| API key errors | Verify `.env` file exists and keys are valid |
| Map not loading | Check Leaflet CSS import in index.html |
| Blank dashboard | Check browser console for API errors |

---

**Good luck with the hackathon! **
</file>

<file path="backend/app.py">
"""
Hotspot IQ - Flask Application
Main entry point for the backend API server.
"""

from flask import Flask, jsonify
from flask_cors import CORS
from config import Config
from routes import location_bp, analysis_bp, chat_bp


def create_app():
    """Create and configure the Flask application."""
    
    app = Flask(__name__)
    
    # Configure CORS - allow multiple Vite dev server ports
    CORS(app, origins=[
        Config.FRONTEND_URL, 
        "http://localhost:5173", 
        "http://localhost:5174",
        "http://localhost:5175",
        "http://localhost:5176",
        "http://127.0.0.1:5173",
        "http://127.0.0.1:5174",
        "http://127.0.0.1:5175",
        "http://127.0.0.1:5176"
    ])
    
    # Register blueprints
    app.register_blueprint(location_bp, url_prefix='/api')
    app.register_blueprint(analysis_bp, url_prefix='/api')
    app.register_blueprint(chat_bp, url_prefix='/api')
    
    # Health check endpoint
    @app.route('/api/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'service': 'Hotspot IQ API',
            'version': '1.0.0'
        })
    
    # Root endpoint
    @app.route('/', methods=['GET'])
    def root():
        return jsonify({
            'name': 'Hotspot IQ API',
            'description': 'Hyper-Local Location Intelligence for Smarter Business Expansion',
            'version': '1.0.0',
            'endpoints': {
                'health': '/api/health',
                'autocomplete': '/api/autocomplete?query={search_term}',
                'analyze': 'POST /api/analyze',
                'isochrone': 'POST /api/isochrone',
                'digipin': '/api/digipin?lat={lat}&lng={lng}',
                'chat': 'POST /api/chat',
                'supply_chain': 'POST /api/supply-chain'
            }
        })
    
    # Error handlers
    @app.errorhandler(404)
    def not_found(e):
        return jsonify({'error': 'Endpoint not found'}), 404
    
    @app.errorhandler(500)
    def server_error(e):
        return jsonify({'error': 'Internal server error'}), 500
    
    return app


# Create app instance
app = create_app()


if __name__ == '__main__':
    print("\n Hotspot IQ Backend Server")
    print("=" * 40)
    
    # Validate configuration
    Config.validate()
    
    print(f" Starting server on http://localhost:{Config.FLASK_PORT}")
    print(f" CORS enabled for: {Config.FRONTEND_URL}")
    print("=" * 40 + "\n")
    
    app.run(
        host='0.0.0.0',
        port=Config.FLASK_PORT,
        debug=Config.FLASK_DEBUG
    )
</file>

<file path="backend/requirements.txt">
flask==3.0.0
flask-cors==4.0.0
python-dotenv==1.0.0
requests==2.31.0
pandas==2.1.0
openai==1.6.0
duckduckgo-search==4.1.0
overpy==0.7
</file>

<file path="backend/services/__init__.py">
"""
Hotspot IQ - Services Package
"""

from .latlong_service import latlong_service, LatLongService
from .competitor_service import (
    get_competitor_count,
    get_competitors_detailed,
    get_available_categories,
    get_cafe_count,
    get_restaurant_count,
    get_gym_count,
    get_pharmacy_count,
)

__all__ = [
    'latlong_service',
    'LatLongService',
    'get_competitor_count',
    'get_competitors_detailed',
    'get_available_categories',
    'get_cafe_count',
    'get_restaurant_count',
    'get_gym_count',
    'get_pharmacy_count',
]
</file>

<file path="backend/services/competitor_service.py">
"""
Hotspot IQ - Competitor Service
Uses OpenStreetMap Overpass API via overpy to count competitors near a location.
"""

import overpy
from typing import Dict, List, Optional


# Map business categories to OpenStreetMap tags
CATEGORY_TAG_MAPPING: Dict[str, List[Dict[str, str]]] = {
    # Food & Beverage - expanded for better coverage
    'cafe': [
        {'amenity': 'cafe'},
        {'shop': 'coffee'},
        {'cuisine': 'coffee_shop'},
        {'amenity': 'fast_food'},  # Many cafes are tagged as fast_food
    ],
    'coffee': [{'amenity': 'cafe'}, {'shop': 'coffee'}],
    'restaurant': [
        {'amenity': 'restaurant'},
        {'amenity': 'fast_food'},
        {'amenity': 'food_court'},
    ],
    'fast_food': [{'amenity': 'fast_food'}],
    'bar': [{'amenity': 'bar'}, {'amenity': 'pub'}],
    'pub': [{'amenity': 'pub'}, {'amenity': 'bar'}],
    'bakery': [{'shop': 'bakery'}, {'shop': 'pastry'}],
    'ice_cream': [{'amenity': 'ice_cream'}, {'shop': 'ice_cream'}, {'shop': 'frozen_yogurt'}],
    
    # Health & Fitness
    'gym': [{'leisure': 'fitness_centre'}, {'amenity': 'gym'}],
    'pharmacy': [{'amenity': 'pharmacy'}],
    'hospital': [{'amenity': 'hospital'}],
    'clinic': [{'amenity': 'clinic'}],
    'dentist': [{'amenity': 'dentist'}],
    
    # Retail
    'supermarket': [{'shop': 'supermarket'}],
    'grocery': [{'shop': 'grocery'}, {'shop': 'convenience'}],
    'convenience': [{'shop': 'convenience'}],
    'clothing': [{'shop': 'clothes'}],
    'electronics': [{'shop': 'electronics'}],
    'mall': [{'shop': 'mall'}],
    'retail': [{'shop': 'retail'}],
    
    # Services
    'salon': [{'shop': 'hairdresser'}, {'shop': 'beauty'}],
    'spa': [{'leisure': 'spa'}, {'shop': 'massage'}],
    'laundry': [{'shop': 'laundry'}],
    'bank': [{'amenity': 'bank'}],
    'atm': [{'amenity': 'atm'}],
    
    # Education
    'school': [{'amenity': 'school'}],
    'college': [{'amenity': 'college'}],
    'university': [{'amenity': 'university'}],
    'tuition': [{'amenity': 'tutoring'}],
    
    # Entertainment
    'cinema': [{'amenity': 'cinema'}],
    'theatre': [{'amenity': 'theatre'}],
    'nightclub': [{'amenity': 'nightclub'}],
    
    # Accommodation
    'hotel': [{'tourism': 'hotel'}],
    'hostel': [{'tourism': 'hostel'}],
    'guest_house': [{'tourism': 'guest_house'}],
}


def _build_overpass_query(lat: float, lng: float, radius: int, tags: List[Dict[str, str]]) -> str:
    """
    Build an Overpass QL query to find nodes, ways, and relations
    matching the given tags within the specified radius.
    
    Args:
        lat: Latitude of center point
        lng: Longitude of center point
        radius: Search radius in meters
        tags: List of OSM tag dictionaries to search for
        
    Returns:
        Overpass QL query string
    """
    query_parts = []
    
    for tag_dict in tags:
        for key, value in tag_dict.items():
            # Query for nodes, ways, and relations with this tag
            tag_filter = f'["{key}"="{value}"]'
            around_filter = f'(around:{radius},{lat},{lng})'
            
            query_parts.append(f'node{tag_filter}{around_filter};')
            query_parts.append(f'way{tag_filter}{around_filter};')
            query_parts.append(f'relation{tag_filter}{around_filter};')
    
    # Combine all queries with union
    query = f"""
    [out:json][timeout:25];
    (
        {chr(10).join(query_parts)}
    );
    out count;
    """
    
    return query


def _build_detailed_query(lat: float, lng: float, radius: int, tags: List[Dict[str, str]]) -> str:
    """
    Build an Overpass QL query that returns actual elements (not just count).
    Used when we need names and locations of competitors.
    
    Args:
        lat: Latitude of center point
        lng: Longitude of center point
        radius: Search radius in meters
        tags: List of OSM tag dictionaries to search for
        
    Returns:
        Overpass QL query string
    """
    query_parts = []
    
    for tag_dict in tags:
        for key, value in tag_dict.items():
            tag_filter = f'["{key}"="{value}"]'
            around_filter = f'(around:{radius},{lat},{lng})'
            
            query_parts.append(f'node{tag_filter}{around_filter};')
            query_parts.append(f'way{tag_filter}{around_filter};')
            query_parts.append(f'relation{tag_filter}{around_filter};')
    
    query = f"""
    [out:json][timeout:25];
    (
        {chr(10).join(query_parts)}
    );
    out body center;
    """
    
    return query


def get_competitor_count(lat: float, lng: float, radius: int, category: str) -> int:
    """
    Count the number of competitors of a given category within a radius.
    
    Uses OpenStreetMap Overpass API to query for POIs matching the category.
    
    Args:
        lat: Latitude of the center point
        lng: Longitude of the center point
        radius: Search radius in meters (e.g., 500 for 500m)
        category: Business category (e.g., "cafe", "restaurant", "gym")
        
    Returns:
        Number of competitors found, or -1 if the query failed
        
    Example:
        count = get_competitor_count(12.9716, 77.5946, 500, "cafe")
    """
    # Get OSM tags for the category
    tags = CATEGORY_TAG_MAPPING.get(category.lower())
    
    if not tags:
        print(f"Warning: Unknown category '{category}', using generic amenity search")
        tags = [{'amenity': category.lower()}]
    
    # Build the query
    query = _build_detailed_query(lat, lng, radius, tags)
    
    try:
        # Create Overpass API instance
        api = overpy.Overpass()
        
        # Execute query with timeout
        result = api.query(query)
        
        # Count all results (nodes + ways + relations)
        count = len(result.nodes) + len(result.ways) + len(result.relations)
        
        return count
        
    except overpy.exception.OverpassTooManyRequests:
        print(f"Overpass API rate limited, returning -1")
        return -1
        
    except overpy.exception.OverpassGatewayTimeout:
        print(f"Overpass API timeout, returning -1")
        return -1
        
    except overpy.exception.OverpassBadRequest as e:
        print(f"Overpass API bad request: {e}")
        return -1
        
    except Exception as e:
        print(f"Overpass API error: {e}")
        return -1


def get_competitors_detailed(lat: float, lng: float, radius: int, category: str) -> List[Dict]:
    """
    Get detailed information about competitors within a radius.
    
    Returns names, locations, and other metadata about each competitor.
    
    Args:
        lat: Latitude of the center point
        lng: Longitude of the center point
        radius: Search radius in meters
        category: Business category (e.g., "cafe", "restaurant")
        
    Returns:
        List of competitor dictionaries with name, lat, lng, and tags
        Returns empty list if query fails
        
    Example:
        competitors = get_competitors_detailed(12.9716, 77.5946, 500, "cafe")
    """
    tags = CATEGORY_TAG_MAPPING.get(category.lower())
    
    if not tags:
        tags = [{'amenity': category.lower()}]
    
    query = _build_detailed_query(lat, lng, radius, tags)
    
    try:
        api = overpy.Overpass()
        result = api.query(query)
        
        competitors = []
        
        # Process nodes
        for node in result.nodes:
            competitor = {
                'id': f'node_{node.id}',
                'name': node.tags.get('name', 'Unknown'),
                'lat': float(node.lat),
                'lng': float(node.lon),
                'type': 'node',
                'tags': dict(node.tags),
                'category': category
            }
            competitors.append(competitor)
        
        # Process ways (use center point)
        for way in result.ways:
            # Ways have center_lat and center_lon when queried with 'out center'
            competitor = {
                'id': f'way_{way.id}',
                'name': way.tags.get('name', 'Unknown'),
                'lat': float(way.center_lat) if way.center_lat else lat,
                'lng': float(way.center_lon) if way.center_lon else lng,
                'type': 'way',
                'tags': dict(way.tags),
                'category': category
            }
            competitors.append(competitor)
        
        # Process relations (use center point)
        for relation in result.relations:
            competitor = {
                'id': f'relation_{relation.id}',
                'name': relation.tags.get('name', 'Unknown'),
                'lat': float(relation.center_lat) if hasattr(relation, 'center_lat') and relation.center_lat else lat,
                'lng': float(relation.center_lon) if hasattr(relation, 'center_lon') and relation.center_lon else lng,
                'type': 'relation',
                'tags': dict(relation.tags),
                'category': category
            }
            competitors.append(competitor)
        
        return competitors
        
    except Exception as e:
        print(f"Overpass API error getting detailed competitors: {e}")
        return []


# Landmark categories for OSM query
LANDMARK_TAG_MAPPING: Dict[str, List[Dict[str, str]]] = {
    'metro': [{'railway': 'station'}, {'station': 'subway'}],
    'bus_stop': [{'highway': 'bus_stop'}, {'amenity': 'bus_station'}],
    'school': [{'amenity': 'school'}],
    'college': [{'amenity': 'college'}, {'amenity': 'university'}],
    'hospital': [{'amenity': 'hospital'}],
    'mall': [{'shop': 'mall'}],
    'park': [{'leisure': 'park'}],
    'bank': [{'amenity': 'bank'}],
    'atm': [{'amenity': 'atm'}],
    'temple': [{'amenity': 'place_of_worship'}],
}


def get_landmarks_from_osm(lat: float, lng: float, radius: int) -> List[Dict]:
    """
    Get landmarks from OpenStreetMap within a radius.
    Fetches multiple landmark types for better area coverage.
    
    Args:
        lat: Latitude of center
        lng: Longitude of center
        radius: Search radius in meters
        
    Returns:
        List of landmarks with name, lat, lng, category
    """
    landmarks = []
    
    # Fetch each landmark type
    for category, tags in LANDMARK_TAG_MAPPING.items():
        query = _build_detailed_query(lat, lng, radius, tags)
        
        try:
            api = overpy.Overpass()
            result = api.query(query)
            
            # Process nodes
            for node in result.nodes:
                name = node.tags.get('name', '')
                if name:
                    landmarks.append({
                        'name': name,
                        'lat': float(node.lat),
                        'lng': float(node.lon),
                        'category': category
                    })
            
            # Process ways with centers
            for way in result.ways:
                name = way.tags.get('name', '')
                if name and way.center_lat:
                    landmarks.append({
                        'name': name,
                        'lat': float(way.center_lat),
                        'lng': float(way.center_lon),
                        'category': category
                    })
                    
        except Exception as e:
            print(f"Error fetching {category} landmarks: {e}")
            continue
    
    return landmarks


def get_available_categories() -> List[str]:
    """
    Get list of available business categories for competitor search.
    
    Returns:
        List of category names that can be used with get_competitor_count
    """
    return list(CATEGORY_TAG_MAPPING.keys())


# Convenience functions for common categories
def get_cafe_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count cafes within radius."""
    return get_competitor_count(lat, lng, radius, 'cafe')


def get_restaurant_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count restaurants within radius."""
    return get_competitor_count(lat, lng, radius, 'restaurant')


def get_gym_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count gyms/fitness centers within radius."""
    return get_competitor_count(lat, lng, radius, 'gym')


def get_pharmacy_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count pharmacies within radius."""
    return get_competitor_count(lat, lng, radius, 'pharmacy')
</file>

<file path="backend/services/latlong_service.py">
"""
Hotspot IQ - LatLong.ai Service Wrapper
Handles all interactions with the LatLong.ai API.

API Documentation: https://apihub.latlong.ai/Documentation

Response Format (all endpoints):
{
  "code": 1001,
  "status": "success",
  "data": [...] or {...}
}
"""

import requests
from typing import List, Dict, Any, Optional
from config import Config, COMPETITOR_MAPPING, FILTER_POI_MAPPING


class LatLongService:
    """Service wrapper for LatLong.ai API."""
    
    def __init__(self):
        self.api_key = Config.LATLONG_API_KEY
        self.base_url = Config.LATLONG_BASE_URL
        # LatLong API uses X-Authorization-Token header
        self.headers = {
            'X-Authorization-Token': self.api_key,
            'Content-Type': 'application/json'
        }
    
    def _make_request(self, method: str, endpoint: str, params: Dict = None, json_data: Dict = None) -> Dict:
        """Make HTTP request to LatLong API."""
        # Endpoints use .json suffix
        url = f"{self.base_url}/{endpoint}.json"
        
        try:
            if method == 'GET':
                response = requests.get(url, headers=self.headers, params=params, timeout=30)
            else:
                response = requests.post(url, headers=self.headers, json=json_data, timeout=30)
            
            response.raise_for_status()
            
            # Handle empty responses
            if not response.text or response.text.strip() == '':
                print(f"LatLong API Warning: Empty response from {endpoint}")
                return {'success': False, 'error': 'Empty response'}
            
            try:
                result = response.json()
            except ValueError as json_err:
                print(f"LatLong API JSON Error: {str(json_err)} - Response: {response.text[:200]}")
                return {'success': False, 'error': f'Invalid JSON response: {str(json_err)}'}
            
            # LatLong API wraps response in code/status/data structure
            if result.get('status') == 'success' and 'data' in result:
                return {'success': True, 'data': result['data']}
            else:
                return {'success': False, 'error': result.get('message', 'Unknown error')}
                
        except requests.exceptions.RequestException as e:
            print(f"LatLong API Error: {str(e)}")
            return {'success': False, 'error': str(e)}
    
    # Major areas database for Indian cities
    MAJOR_AREAS = {
        'bengaluru': [
            'Indiranagar', 'Koramangala', 'Whitefield', 'Electronic City', 'Jayanagar',
            'Malleshwaram', 'HSR Layout', 'BTM Layout', 'Marathahalli', 'Banashankari',
            'Rajajinagar', 'Basavanagudi', 'JP Nagar', 'Hebbal', 'Yelahanka',
            'Sadashivanagar', 'Bannerghatta Road', 'Sarjapur Road', 'MG Road', 
            'Brigade Road', 'Commercial Street', 'Cunningham Road', 'Lavelle Road',
            'Residency Road', 'Richmond Road', 'Vittal Mallya Road', 'Kasturba Road',
            'Shivajinagar', 'Majestic', 'KR Market', 'Chickpet', 'Avenue Road',
            'Frazer Town', 'Cox Town', 'Benson Town', 'RT Nagar', 'Sanjaynagar',
            'Vijayanagar', 'Nagarbhavi', 'Basaveshwaranagar', 'Yeshwanthpur',
            'Peenya', 'Tumkur Road', 'Mysore Road', 'Kanakapura Road', 'Hosur Road',
            'Old Airport Road', 'Outer Ring Road', 'Bellary Road', 'Hennur',
            'Kalyan Nagar', 'Kammanahalli', 'HRBR Layout', 'Ramamurthy Nagar',
            'KR Puram', 'Mahadevapura', 'Bellandur', 'Varthur', 'Brookefield',
            'ITPL', 'Domlur', 'HAL', 'Old Madras Road', 'CV Raman Nagar',
            'Ulsoor', 'MG Road', 'Trinity', 'Ashok Nagar', 'Wilson Garden',
        ],
        'bangalore': [  # Alias
            'Indiranagar', 'Koramangala', 'Whitefield', 'Electronic City', 'Jayanagar',
            'Malleshwaram', 'HSR Layout', 'BTM Layout', 'Marathahalli', 'Banashankari',
            'Rajajinagar', 'Basavanagudi', 'JP Nagar', 'Hebbal', 'Yelahanka',
        ],
        'mumbai': [
            'Bandra', 'Andheri', 'Juhu', 'Powai', 'Lower Parel', 'Worli', 'Dadar',
            'Colaba', 'Marine Drive', 'Nariman Point', 'Fort', 'Churchgate',
            'Santacruz', 'Khar', 'Malad', 'Goregaon', 'Kandivali', 'Borivali',
            'Thane', 'Navi Mumbai', 'Vashi', 'Kharghar', 'Panvel', 'Airoli',
            'BKC', 'Kurla', 'Ghatkopar', 'Mulund', 'Vikhroli', 'Chembur',
            'Matunga', 'Sion', 'Wadala', 'Parel', 'Lalbaug', 'Prabhadevi',
            'Mahim', 'Dharavi', 'Versova', 'Lokhandwala', 'Oshiwara', 'DN Nagar',
        ],
        'delhi': [
            'Connaught Place', 'Karol Bagh', 'Chandni Chowk', 'Saket', 'Hauz Khas',
            'Greater Kailash', 'Lajpat Nagar', 'Defence Colony', 'South Extension',
            'Vasant Kunj', 'Vasant Vihar', 'Dwarka', 'Janakpuri', 'Rajouri Garden',
            'Punjabi Bagh', 'Pitampura', 'Rohini', 'Model Town', 'Civil Lines',
            'Nehru Place', 'Okhla', 'Sarita Vihar', 'Jasola', 'Kalkaji',
            'Green Park', 'Safdarjung', 'Jor Bagh', 'Khan Market', 'Lodhi Colony',
            'Mayur Vihar', 'Preet Vihar', 'Laxmi Nagar', 'Vivek Vihar',
            'Paharganj', 'Daryaganj', 'ITO', 'Mandi House', 'Rajiv Chowk',
        ],
        'hyderabad': [
            'Banjara Hills', 'Jubilee Hills', 'Hitech City', 'Gachibowli', 'Madhapur',
            'Kondapur', 'Kukatpally', 'Miyapur', 'Secunderabad', 'Ameerpet',
            'Begumpet', 'Somajiguda', 'Punjagutta', 'Abids', 'Nampally',
            'Charminar', 'Koti', 'Dilsukhnagar', 'LB Nagar', 'Uppal',
            'Manikonda', 'Tolichowki', 'Mehdipatnam', 'Attapur', 'Rajendranagar',
            'Film Nagar', 'Yousufguda', 'SR Nagar', 'Sanath Nagar', 'Erragadda',
        ],
        'chennai': [
            'T Nagar', 'Anna Nagar', 'Adyar', 'Velachery', 'OMR', 'ECR',
            'Nungambakkam', 'Kodambakkam', 'Mylapore', 'Alwarpet', 'RA Puram',
            'Besant Nagar', 'Thiruvanmiyur', 'Sholinganallur', 'Porur', 'Vadapalani',
            'Ashok Nagar', 'KK Nagar', 'West Mambalam', 'Saidapet', 'Guindy',
            'Mount Road', 'Egmore', 'Kilpauk', 'Chetpet', 'Royapettah',
            'Teynampet', 'Thousand Lights', 'Triplicane', 'Marina Beach', 'George Town',
        ],
        'pune': [
            'Koregaon Park', 'Kalyani Nagar', 'Viman Nagar', 'Kharadi', 'Magarpatta',
            'Hadapsar', 'Wakad', 'Hinjewadi', 'Baner', 'Aundh', 'Pashan',
            'Shivajinagar', 'FC Road', 'JM Road', 'MG Road', 'Camp', 'Deccan',
            'Kothrud', 'Karve Nagar', 'Warje', 'Sinhagad Road', 'Bibwewadi',
            'Katraj', 'Kondhwa', 'NIBM', 'Undri', 'Mohammadwadi', 'Wanowrie',
        ],
        'kolkata': [
            'Park Street', 'Salt Lake', 'New Town', 'Rajarhat', 'EM Bypass',
            'Ballygunge', 'Alipore', 'Behala', 'Tollygunge', 'Jadavpur',
            'Gariahat', 'Rashbehari', 'Dharmatala', 'Esplanade', 'BBD Bagh',
            'Howrah', 'Sealdah', 'College Street', 'Shyambazar', 'Hatibagan',
            'Dumdum', 'Barasat', 'Barrackpore', 'Garia', 'Narendrapur',
        ],
        'ahmedabad': [
            'CG Road', 'SG Highway', 'Ashram Road', 'Navrangpura', 'Vastrapur',
            'Bodakdev', 'Satellite', 'Prahlad Nagar', 'Thaltej', 'Gurukul',
            'Paldi', 'Ellis Bridge', 'Law Garden', 'Mithakhali', 'Stadium',
            'Maninagar', 'Ghatlodia', 'Chandkheda', 'Motera', 'Sabarmati',
        ],
    }
    
    def autocomplete(self, query: str, lat: float = None, lng: float = None, limit: int = 10) -> List[Dict]:
        """
        Get location suggestions for autocomplete - prioritizes major areas.
        
        Args:
            query: Search text entered by user
            lat: Optional latitude for location biasing
            lng: Optional longitude for location biasing
            limit: Maximum number of suggestions (default: 10, max: 20)
            
        Returns:
            List of location suggestions with geoid, name
        """
        if len(query) < 2:
            return []
        
        query_lower = query.lower().strip()
        suggestions = []
        seen_areas = set()  # Track seen area names to avoid duplicates
        
        # First, check if query matches any major areas from our curated list
        for city, areas in self.MAJOR_AREAS.items():
            # Skip alias entries (like 'bangalore' which duplicates 'bengaluru')
            if city == 'bangalore':
                continue
                
            for area in areas:
                area_lower = area.lower()
                if area_lower.startswith(query_lower) or query_lower in area_lower:
                    # Determine city name for display
                    city_display = city.title()
                    if city == 'bengaluru':
                        city_display = 'Bengaluru'
                    
                    # Create unique key to avoid duplicates
                    area_key = f"{area_lower}_{city}"
                    if area_key in seen_areas:
                        continue
                    seen_areas.add(area_key)
                    
                    suggestions.append({
                        'place_id': f"major_{city}_{area.replace(' ', '_').lower()}",
                        'geoid': None,
                        'name': f"{area}, {city_display}",
                        'is_area': True,
                        'is_major': True,
                        'lat': None,
                        'lng': None
                    })
        
        # Sort by relevance (exact prefix match first)
        suggestions.sort(key=lambda x: (
            0 if x['name'].lower().startswith(query_lower) else 1,
            len(x['name'])
        ))
        
        # Limit major area suggestions
        suggestions = suggestions[:limit]
        
        # If we have enough major area matches, return them
        if len(suggestions) >= 5:
            return suggestions[:limit]
        
        # Otherwise, also fetch from API to supplement
        params = {
            'query': query,
            'limit': min(limit, 20)
        }
        
        if lat is not None and lng is not None:
            params['lat'] = lat
            params['long'] = lng
        
        result = self._make_request('GET', 'v4/autocomplete', params=params)
        
        if result.get('success'):
            data = result.get('data', [])
            
            # Keywords that indicate POI/store rather than area
            POI_KEYWORDS = [
                'station', 'stop', 'shop', 'store', 'hotel', 'restaurant', 'cafe', 
                'hospital', 'clinic', 'school', 'college', 'temple', 'church', 'mosque',
                'mall', 'market', 'bank', 'atm', 'petrol', 'pump', 'bunk', 'park',
                'playground', 'water tank', 'office', 'building', 'tower', 'complex',
                'apartment', 'residency', 'villa', 'gym', 'fitness', 'salon', 'spa',
                'cinema', 'theater', 'theatre', 'pub', 'bar', 'lounge', 'club',
                'satellite town', 'layout', 'phase', 'block', 'sector',
            ]
            
            # Get existing names to avoid duplicates
            existing_names = {s['name'].lower() for s in suggestions}
            
            if isinstance(data, list):
                for item in data:
                    name = item.get('name', '')
                    name_lower = name.lower()
                    
                    # Skip if duplicate
                    if any(name_lower.startswith(existing.split(',')[0]) for existing in existing_names):
                        continue
                    
                    # Skip POIs
                    if any(kw in name_lower for kw in POI_KEYWORDS):
                        continue
                    
                    # Check if this looks like a major area (first part is clean)
                    parts = name.split(',')
                    first_part = parts[0].strip()
                    
                    # Skip if first part has too many words (likely a specific place)
                    if len(first_part.split()) > 3:
                        continue
                    
                    suggestions.append({
                        'place_id': str(item.get('geoid', '')),
                        'geoid': item.get('geoid'),
                        'name': name,
                        'is_area': True,
                        'is_major': False,
                        'lat': None,
                        'lng': None
                    })
                    
                    if len(suggestions) >= limit:
                        break
        
        return suggestions[:limit]
    
    def geocode(self, address: str) -> Dict:
        """
        Get coordinates from an address.
        
        LatLong API: GET /v4/geocode.json
        Response: { data: { address, latitude, longitude, accuracy } }
        
        Args:
            address: Full or partial address
            
        Returns:
            Dict with latitude, longitude, and address details
        """
        params = {
            'address': address,
            'accuracy_level': 'true'
        }
        
        result = self._make_request('GET', 'v4/geocode', params=params)
        
        if not result.get('success'):
            return {'error': 'Geocoding failed'}
        
        data = result.get('data', {})
        return {
            'address': data.get('address', address),
            'lat': float(data.get('latitude', 0)),
            'lng': float(data.get('longitude', 0)),
            'accuracy': data.get('accuracy', '')
        }
    
    def reverse_geocode(self, lat: float, lng: float) -> Dict:
        """
        Get address details from coordinates.
        
        LatLong API: GET /v4/reverse_geocode.json
        Response: { data: { address, pincode, landmark } }
        
        Args:
            lat: Latitude
            lng: Longitude
            
        Returns:
            Address details including formatted address and components
        """
        params = {
            'latitude': lat,
            'longitude': lng
        }
        
        result = self._make_request('GET', 'v4/reverse_geocode', params=params)
        
        if not result.get('success'):
            return {
                'formatted_address': f'{lat}, {lng}',
                'locality': '',
                'city': '',
                'pincode': '',
                'landmark': ''
            }
        
        data = result.get('data', {})
        return {
            'formatted_address': data.get('address', f'{lat}, {lng}'),
            'locality': '',  # Not directly provided
            'city': '',  # Parse from address if needed
            'pincode': data.get('pincode', ''),
            'state': '',  # Parse from address if needed
            'landmark': data.get('landmark', '')
        }
    
    def get_poi(self, lat: float, lng: float, category: str, radius: int = 1000) -> Dict:
        """
        Get Points of Interest by category near a location.
        
        LatLong API: GET /v4/point_of_interest.json
        Response: { data: [{ category, name }] }
        
        Note: POI API returns category/name but not coordinates.
        For coordinates, use the Landmark API.
        
        Args:
            lat: Latitude
            lng: Longitude  
            category: POI category (e.g., hospital, school, hotel, Pin Code, etc.)
            radius: Search radius in meters (not directly supported, for reference)
            
        Returns:
            Dict with count and list of nearby POIs
        """
        params = {
            'latitude': lat,
            'longitude': lng,
            'category': category
        }
        
        result = self._make_request('GET', 'v4/point_of_interest', params=params)
        
        if not result.get('success'):
            return {'count': 0, 'pois': []}
        
        data = result.get('data', [])
        pois = []
        
        if isinstance(data, list):
            for poi in data:
                pois.append({
                    'name': poi.get('name', 'Unknown'),
                    'category': poi.get('category', category),
                    # POI API doesn't return coordinates
                    'lat': lat,  # Use center point as approximation
                    'lng': lng,
                    'distance': 0
                })
        
        return {
            'count': len(pois),
            'pois': pois
        }
    
    def get_landmarks(self, lat: float, lng: float) -> List[Dict]:
        """
        Get nearby landmarks with coordinates.
        
        LatLong API: GET /v4/landmarks.json
        Response: { data: [{ name, geo, latitude, longitude }] }
        
        Args:
            lat: Latitude
            lng: Longitude
            
        Returns:
            List of landmarks with name, coordinates
        """
        params = {
            'lat': lat,
            'lon': lng
        }
        
        result = self._make_request('GET', 'v4/landmarks', params=params)
        
        if not result.get('success'):
            return []
        
        data = result.get('data', [])
        landmarks = []
        
        if isinstance(data, list):
            for item in data:
                landmarks.append({
                    'name': item.get('name', 'Unknown'),
                    'geo': item.get('geo', ''),
                    'lat': float(item.get('latitude', lat)),
                    'lng': float(item.get('longitude', lng)),
                    'category': 'landmark'  # Default category
                })
        
        return landmarks
    
    def get_competitors(self, lat: float, lng: float, business_type: str, radius: int = 1000) -> Dict:
        """
        Get competitor businesses based on business type.
        Uses both POI and Landmarks API to find nearby competitors.
        
        Args:
            lat: Latitude
            lng: Longitude
            business_type: Type of business (cafe, gym, etc.)
            radius: Search radius in meters
            
        Returns:
            Dict with total count and list of competitors
        """
        categories = COMPETITOR_MAPPING.get(business_type, [])
        
        if not categories:
            return {'count': 0, 'nearby': []}
        
        all_competitors = []
        
        # Get landmarks first (they have coordinates)
        landmarks = self.get_landmarks(lat, lng)
        
        # Add landmarks that might be competitors
        for landmark in landmarks:
            name_lower = landmark.get('name', '').lower()
            # Check if landmark matches any competitor category
            for category in categories:
                if category.lower() in name_lower:
                    all_competitors.append({
                        'name': landmark.get('name'),
                        'lat': landmark.get('lat'),
                        'lng': landmark.get('lng'),
                        'category': category,
                        'distance': self._calculate_distance(lat, lng, landmark.get('lat'), landmark.get('lng'))
                    })
                    break
        
        # Also try POI API for each category
        for category in categories:
            result = self.get_poi(lat, lng, category, radius)
            for poi in result.get('pois', []):
                # Check for duplicates
                if not any(c['name'] == poi['name'] for c in all_competitors):
                    all_competitors.append(poi)
        
        return {
            'count': len(all_competitors),
            'nearby': all_competitors
        }
    
    def _calculate_distance(self, lat1: float, lng1: float, lat2: float, lng2: float) -> int:
        """Calculate approximate distance in meters between two points."""
        import math
        
        if lat2 is None or lng2 is None:
            return 0
            
        R = 6371000  # Earth's radius in meters
        phi1 = math.radians(lat1)
        phi2 = math.radians(lat2)
        delta_phi = math.radians(lat2 - lat1)
        delta_lambda = math.radians(lng2 - lng1)
        
        a = math.sin(delta_phi/2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return int(R * c)
    
    def get_landmarks_by_filters(self, lat: float, lng: float, filters: List[str], radius: int = 1000) -> Dict:
        """
        Get landmarks based on proximity filters.
        Combines Landmarks API with POI API for comprehensive results.
        
        Args:
            lat: Latitude
            lng: Longitude
            filters: List of filter keys (near_metro, near_school, etc.)
            radius: Search radius in meters
            
        Returns:
            Dict with landmark counts by category
        """
        landmarks_by_category = {}
        all_pois = []
        
        # First, get nearby landmarks with coordinates
        nearby_landmarks = self.get_landmarks(lat, lng)
        
        for filter_key in filters:
            category = FILTER_POI_MAPPING.get(filter_key)
            if category:
                category_pois = []
                
                # Check if any landmarks match this category
                for landmark in nearby_landmarks:
                    name_lower = landmark.get('name', '').lower()
                    if category.lower() in name_lower:
                        landmark_with_cat = {**landmark, 'category': category}
                        category_pois.append(landmark_with_cat)
                
                # Also try POI API
                poi_result = self.get_poi(lat, lng, category, radius)
                for poi in poi_result.get('pois', []):
                    if not any(p['name'] == poi['name'] for p in category_pois):
                        category_pois.append(poi)
                
                landmarks_by_category[category] = {
                    'count': len(category_pois),
                    'pois': category_pois
                }
                all_pois.extend(category_pois)
        
        return {
            'by_category': landmarks_by_category,
            'total_count': len(all_pois),
            'all_pois': all_pois
        }
    
    def get_isochrone(self, lat: float, lng: float, distance_km: float = 1.0) -> Dict:
        """
        Get isochrone polygon for reachability visualization.
        
        LatLong API: GET /v4/isochrone.json
        Response: { data: { geom: { type: "Feature", geometry: { coordinates, type: "Polygon" } } } }
        
        Args:
            lat: Latitude
            lng: Longitude
            distance_km: Distance in kilometers (default: 1.0)
            
        Returns:
            GeoJSON Feature with polygon geometry
        """
        params = {
            'latitude': lat,
            'longitude': lng,
            'distance_limit': distance_km
        }
        
        result = self._make_request('GET', 'v4/isochrone', params=params)
        
        if not result.get('success'):
            # Return a simple circular fallback
            return self._generate_fallback_isochrone(lat, lng, distance_km)
        
        data = result.get('data', {})
        geom = data.get('geom', {})
        
        # LatLong returns { geom: { type: "Feature", geometry: {...} } }
        if geom.get('type') == 'Feature':
            return {
                'type': 'Feature',
                'properties': {
                    'distance_km': distance_km,
                    'center': [lat, lng]
                },
                'geometry': geom.get('geometry', {
                    'type': 'Polygon',
                    'coordinates': []
                })
            }
        
        return self._generate_fallback_isochrone(lat, lng, distance_km)
    
    def _generate_fallback_isochrone(self, lat: float, lng: float, distance_km: float) -> Dict:
        """Generate a simple circular isochrone as fallback."""
        import math
        
        radius_km = distance_km
        
        # Generate circle points
        points = []
        for i in range(36):
            angle = math.radians(i * 10)
            dlat = (radius_km / 111) * math.cos(angle)
            dlng = (radius_km / (111 * math.cos(math.radians(lat)))) * math.sin(angle)
            points.append([lng + dlng, lat + dlat])
        points.append(points[0])  # Close the polygon
        
        return {
            'type': 'Feature',
            'properties': {
                'distance_km': distance_km,
                'is_fallback': True
            },
            'geometry': {
                'type': 'Polygon',
                'coordinates': [points]
            }
        }
    
    def get_digipin(self, lat: float, lng: float) -> Dict:
        """
        Get Digipin (Digital Address Code) for a location.
        
        Note: DIGIPIN API may not be available. We generate a placeholder
        based on coordinates that resembles India Post's DIGIPIN format.
        
        Args:
            lat: Latitude
            lng: Longitude
            
        Returns:
            Dict with digipin code and formatted address
        """
        # Generate a pseudo-DIGIPIN based on coordinates
        # Real DIGIPIN would come from India Post service
        # Format: XX-YYYY where XX is state code approximation, YYYY is area code
        
        # Approximate state from coordinates
        state_codes = {
            'KA': (12.0, 15.5, 74.0, 78.5),  # Karnataka
            'MH': (15.5, 22.0, 72.0, 80.5),  # Maharashtra  
            'TN': (8.0, 13.5, 76.0, 80.5),   # Tamil Nadu
            'DL': (28.0, 29.0, 76.5, 77.5),  # Delhi
            'UP': (23.5, 30.5, 77.0, 84.5),  # Uttar Pradesh
            'WB': (21.5, 27.5, 85.5, 89.5),  # West Bengal
            'BR': (24.0, 27.5, 83.0, 88.5),  # Bihar
            'GJ': (20.0, 24.5, 68.0, 74.5),  # Gujarat
            'RJ': (23.0, 30.0, 69.5, 78.0),  # Rajasthan
            'KL': (8.0, 12.8, 74.5, 77.5),   # Kerala
        }
        
        state_code = 'XX'
        for code, (lat_min, lat_max, lng_min, lng_max) in state_codes.items():
            if lat_min <= lat <= lat_max and lng_min <= lng <= lng_max:
                state_code = code
                break
        
        # Generate area code from coordinates
        area_code = abs(hash((round(lat, 4), round(lng, 4)))) % 10000
        
        return {
            'digipin': f'{state_code}-{area_code:04d}',
            'formatted_address': f'{lat:.6f}, {lng:.6f}'
        }
    
    def distance_matrix(self, origins: List[Dict], destinations: List[Dict]) -> Dict:
        """
        Calculate distance and drive time between locations.
        
        Args:
            origins: List of {lat, lng} dicts
            destinations: List of {lat, lng} dicts
            
        Returns:
            Matrix of distances and durations
        """
        json_data = {
            'origins': origins,
            'destinations': destinations,
            'mode': 'car'
        }
        
        result = self._make_request('POST', 'distance-matrix', json_data=json_data)
        
        if 'error' in result:
            return {'rows': []}
        
        return result


# Create singleton instance
latlong_service = LatLongService()
</file>

<file path="backend/utils/score_calculator.py">
"""
Hotspot IQ - Location Analysis & Recommended Spots Calculator
Finds optimal business locations based on competitor density and landmark proximity.
"""

import math
from typing import Dict, List, Tuple
from config import LANDMARK_WEIGHTS


def haversine_distance(lat1: float, lng1: float, lat2: float, lng2: float) -> float:
    """Calculate distance between two points in meters."""
    R = 6371000  # Earth's radius in meters
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lng2 - lng1)
    a = math.sin(dphi/2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda/2)**2
    return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))


def calculate_grid_scores(
    center_lat: float,
    center_lng: float,
    radius: float,
    competitors: List[Dict],
    landmarks: List[Dict],
    grid_size: int = 10
) -> List[Dict]:
    """
    Analyze the area using a grid and calculate opportunity score for each cell.
    
    Returns a list of grid cells with their scores, sorted by opportunity.
    """
    # Convert radius to lat/lng offsets
    lat_offset_per_m = 1 / 111000
    lng_offset_per_m = 1 / (111000 * math.cos(math.radians(center_lat)))
    
    grid_cells = []
    cell_size = (2 * radius) / grid_size  # Size of each cell in meters
    
    for row in range(grid_size):
        for col in range(grid_size):
            # Calculate cell center coordinates
            cell_lat = center_lat + ((row - grid_size/2 + 0.5) * cell_size * lat_offset_per_m)
            cell_lng = center_lng + ((col - grid_size/2 + 0.5) * cell_size * lng_offset_per_m)
            
            # Check if cell is within the circular radius
            dist_from_center = haversine_distance(center_lat, center_lng, cell_lat, cell_lng)
            if dist_from_center > radius:
                continue
            
            # Count competitors within proximity of this cell (300m radius)
            nearby_competitors = 0
            min_competitor_dist = float('inf')
            for comp in competitors:
                comp_dist = haversine_distance(cell_lat, cell_lng, comp.get('lat', 0), comp.get('lng', 0))
                if comp_dist < 300:
                    nearby_competitors += 1
                if comp_dist < min_competitor_dist:
                    min_competitor_dist = comp_dist
            
            # Count landmarks within proximity (500m radius) and calculate footfall score
            nearby_landmarks = []
            footfall_score = 0
            for lm in landmarks:
                lm_dist = haversine_distance(cell_lat, cell_lng, lm.get('lat', 0), lm.get('lng', 0))
                if lm_dist < 500:
                    nearby_landmarks.append(lm)
                    # Higher value for closer landmarks
                    proximity_bonus = max(0, (500 - lm_dist) / 500)
                    
                    # Weight by landmark type
                    name = lm.get('name', '').lower()
                    category = lm.get('category', '').lower()
                    
                    if any(kw in name or kw in category for kw in ['metro', 'station', 'railway']):
                        footfall_score += 25 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['mall', 'plaza', 'market']):
                        footfall_score += 20 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['hospital', 'medical', 'clinic']):
                        footfall_score += 15 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['school', 'college', 'university']):
                        footfall_score += 15 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['office', 'corporate', 'tech']):
                        footfall_score += 12 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['bank', 'atm']):
                        footfall_score += 10 * proximity_bonus
                    else:
                        footfall_score += 5 * proximity_bonus
            
            # Calculate opportunity score: high footfall + low competition = better
            # Competition penalty: more competitors nearby = lower score
            competition_penalty = nearby_competitors * 15
            
            # Distance bonus: if no competitors very close, that's good
            distance_bonus = 0
            if min_competitor_dist > 200:
                distance_bonus = min(30, (min_competitor_dist - 200) / 10)
            
            # Final opportunity score
            opportunity = max(0, footfall_score + distance_bonus - competition_penalty)
            
            grid_cells.append({
                'lat': cell_lat,
                'lng': cell_lng,
                'opportunity_score': round(opportunity, 1),
                'nearby_competitors': nearby_competitors,
                'min_competitor_distance': round(min_competitor_dist) if min_competitor_dist != float('inf') else None,
                'nearby_landmarks': len(nearby_landmarks),
                'footfall_score': round(footfall_score, 1),
                'landmark_names': [lm.get('name', '') for lm in nearby_landmarks[:5]]
            })
    
    # Sort by opportunity score (highest first)
    grid_cells.sort(key=lambda x: x['opportunity_score'], reverse=True)
    
    return grid_cells


def find_recommended_spots(
    center_lat: float,
    center_lng: float,
    radius: float,
    competitors: List[Dict],
    landmarks: List[Dict],
    max_spots: int = 5
) -> List[Dict]:
    """
    Find the best spots for setting up a business.
    
    Returns top spots with explanations.
    """
    # Calculate grid scores
    grid_scores = calculate_grid_scores(
        center_lat, center_lng, radius, 
        competitors, landmarks, 
        grid_size=12  # Higher resolution grid
    )
    
    if not grid_scores:
        return []
    
    # Select top spots that are not too close to each other
    recommended = []
    min_spacing = 300  # Minimum distance between recommended spots
    
    for cell in grid_scores:
        if len(recommended) >= max_spots:
            break
            
        # Check if this spot is far enough from already recommended spots
        too_close = False
        for existing in recommended:
            dist = haversine_distance(
                cell['lat'], cell['lng'],
                existing['lat'], existing['lng']
            )
            if dist < min_spacing:
                too_close = True
                break
        
        if too_close:
            continue
        
        # Generate reason for recommendation
        reasons = []
        
        if cell['min_competitor_distance'] and cell['min_competitor_distance'] > 300:
            reasons.append(f"Low competition - nearest competitor {cell['min_competitor_distance']}m away")
        elif cell['nearby_competitors'] == 0:
            reasons.append("No direct competitors in this zone")
        elif cell['nearby_competitors'] <= 2:
            reasons.append(f"Low competition density ({cell['nearby_competitors']} nearby)")
        
        if cell['footfall_score'] >= 30:
            reasons.append("High footfall area")
        elif cell['footfall_score'] >= 15:
            reasons.append("Good footfall potential")
        
        if cell['nearby_landmarks'] >= 3:
            reasons.append(f"Near key landmarks ({cell['nearby_landmarks']} within 500m)")
        
        if cell['landmark_names']:
            top_landmarks = cell['landmark_names'][:3]
            reasons.append(f"Near: {', '.join(top_landmarks)}")
        
        # Determine rating based on score
        if cell['opportunity_score'] >= 50:
            rating = 'Excellent'
            rating_color = 'green'
        elif cell['opportunity_score'] >= 30:
            rating = 'Good'
            rating_color = 'cyan'
        elif cell['opportunity_score'] >= 15:
            rating = 'Moderate'
            rating_color = 'yellow'
        else:
            rating = 'Fair'
            rating_color = 'orange'
        
        recommended.append({
            'lat': round(cell['lat'], 6),
            'lng': round(cell['lng'], 6),
            'score': cell['opportunity_score'],
            'rating': rating,
            'rating_color': rating_color,
            'reasons': reasons if reasons else ['Balanced location with growth potential'],
            'nearby_competitors': cell['nearby_competitors'],
            'nearby_landmarks': cell['nearby_landmarks'],
            'min_competitor_distance': cell['min_competitor_distance']
        })
    
    # Number the spots
    for i, spot in enumerate(recommended, 1):
        spot['rank'] = i
    
    return recommended


def calculate_footfall_proxy(landmarks: Dict, competitors: Dict) -> float:
    """
    Calculate footfall proxy score based on nearby landmarks.
    
    Higher footfall areas have more transit points, offices, and commercial zones.
    
    Args:
        landmarks: Dict with landmark data by category
        competitors: Dict with competitor data
        
    Returns:
        Footfall proxy score (0-100)
    """
    score = 0
    max_score = 100
    
    by_category = landmarks.get('by_category', {})
    all_pois = landmarks.get('all_pois', [])
    total_count = landmarks.get('total_count', 0)
    
    # If we have specific categories, use them for detailed scoring
    # Transit points are strong footfall indicators
    transit_score = 0
    if 'metro_station' in by_category:
        transit_score += min(by_category['metro_station'].get('count', 0) * 20, 40)
    if 'bus_stop' in by_category:
        transit_score += min(by_category['bus_stop'].get('count', 0) * 5, 15)
    
    score += transit_score
    
    # Commercial zones indicate high activity
    commercial_score = 0
    if 'mall' in by_category:
        commercial_score += min(by_category['mall'].get('count', 0) * 15, 25)
    if 'office' in by_category:
        commercial_score += min(by_category['office'].get('count', 0) * 10, 20)
    
    score += commercial_score
    
    # Educational institutions bring regular footfall
    education_score = 0
    if 'school' in by_category:
        education_score += min(by_category['school'].get('count', 0) * 5, 10)
    if 'college' in by_category:
        education_score += min(by_category['college'].get('count', 0) * 8, 15)
    
    score += education_score
    
    # Residential areas mean local customers
    if 'residential' in by_category:
        score += min(by_category['residential'].get('count', 0) * 5, 15)
    
    # If no specific categories matched, use total nearby landmarks as proxy
    # More landmarks nearby = more activity = higher footfall
    if score == 0 and total_count > 0:
        # Use POI names to detect categories
        for poi in all_pois:
            name = poi.get('name', '').lower()
            # Check for high-value landmarks in names
            if any(kw in name for kw in ['metro', 'station', 'railway', 'train']):
                score += 20
            elif any(kw in name for kw in ['mall', 'plaza', 'center', 'centre']):
                score += 15
            elif any(kw in name for kw in ['hospital', 'clinic', 'medical']):
                score += 12
            elif any(kw in name for kw in ['school', 'college', 'university', 'institute']):
                score += 10
            elif any(kw in name for kw in ['office', 'corporate', 'tech', 'park']):
                score += 10
            elif any(kw in name for kw in ['hotel', 'restaurant', 'cafe', 'food']):
                score += 8
            elif any(kw in name for kw in ['temple', 'church', 'mosque', 'gurudwara']):
                score += 5
            else:
                score += 3  # Any landmark is a sign of activity
        
        # Cap the name-based score
        score = min(score, max_score)
    
    return min(score, max_score)


def calculate_landmark_value(landmarks: Dict) -> float:
    """
    Calculate weighted landmark value score.
    
    Different landmarks have different value for businesses.
    
    Args:
        landmarks: Dict with landmark data by category
        
    Returns:
        Landmark value score (0-50)
    """
    score = 0
    max_score = 50
    
    by_category = landmarks.get('by_category', {})
    all_pois = landmarks.get('all_pois', [])
    total_count = landmarks.get('total_count', 0)
    
    for category, data in by_category.items():
        count = data.get('count', 0)
        weight = LANDMARK_WEIGHTS.get(category, 5)
        
        # Diminishing returns for multiple landmarks of same type
        category_score = 0
        for i in range(min(count, 5)):  # Cap at 5 of each type
            category_score += weight * (0.8 ** i)  # Each additional is worth less
        
        score += category_score
    
    # If score is still 0 but we have landmarks, calculate based on POI names
    if score == 0 and total_count > 0:
        for poi in all_pois[:10]:  # Cap at 10 POIs
            name = poi.get('name', '').lower()
            # Assign weights based on landmark name
            if any(kw in name for kw in ['metro', 'station', 'railway']):
                weight = 12
            elif any(kw in name for kw in ['mall', 'plaza', 'market']):
                weight = 10
            elif any(kw in name for kw in ['hospital', 'medical']):
                weight = 8
            elif any(kw in name for kw in ['school', 'college', 'university']):
                weight = 8
            elif any(kw in name for kw in ['hotel', 'restaurant']):
                weight = 6
            elif any(kw in name for kw in ['bank', 'atm']):
                weight = 5
            else:
                weight = 3
            
            score += weight * (0.8 ** all_pois.index(poi))
    
    return min(score, max_score)


def calculate_competitor_density(competitors: Dict, radius: float = 1000) -> float:
    """
    Calculate competitor density factor.
    
    More competitors = higher density = lower score contribution.
    
    Args:
        competitors: Dict with competitor data
        radius: Search radius in meters
        
    Returns:
        Competitor density factor (0+, higher is worse)
    """
    count = competitors.get('count', 0)
    
    # Normalize by area (competitors per square km)
    area_sq_km = 3.14159 * (radius / 1000) ** 2
    density = count / max(area_sq_km, 0.1)
    
    return density


def calculate_opportunity_score(
    footfall: float,
    landmark_value: float,
    competitor_density: float
) -> int:
    """
    Calculate the final Opportunity Score.
    
    Formula: (Footfall  Landmark Value) / (Competitor Density + 1)
    Normalized to 0-100 scale.
    
    Args:
        footfall: Footfall proxy score (0-100)
        landmark_value: Landmark value score (0-50)
        competitor_density: Competitor density factor
        
    Returns:
        Opportunity Score (0-100)
    """
    # Calculate raw score
    numerator = footfall * (landmark_value / 50)  # Normalize landmark to 0-1
    denominator = competitor_density + 1  # Add 1 to avoid division by zero
    
    raw_score = numerator / denominator
    
    # Normalize to 0-100
    # Assuming max raw score is around 100 (high footfall, no competition)
    normalized_score = min(raw_score, 100)
    
    return round(normalized_score)


def get_score_interpretation(score: int) -> Dict:
    """
    Get human-readable interpretation of the opportunity score.
    
    Args:
        score: Opportunity score (0-100)
        
    Returns:
        Dict with category, color, recommendation
    """
    if score >= 70:
        return {
            'category': 'Prime Location',
            'color': 'green',
            'emoji': '',
            'recommendation': 'Excellent opportunity! This location shows strong potential with good footfall and manageable competition. Move fast before others discover it.',
            'action': 'Move fast!'
        }
    elif score >= 40:
        return {
            'category': 'Moderate Potential',
            'color': 'yellow',
            'emoji': '',
            'recommendation': 'This location has potential but may require differentiation. Consider your unique value proposition and marketing strategy.',
            'action': 'Needs differentiation'
        }
    else:
        return {
            'category': 'High Risk',
            'color': 'red',
            'emoji': '',
            'recommendation': 'This location shows challenging conditions with high competition or low footfall. Consider alternative locations or a very niche strategy.',
            'action': 'Reconsider or pivot'
        }


def analyze_location(
    landmarks: Dict,
    competitors: Dict,
    business_type: str
) -> Dict:
    """
    Perform complete location analysis.
    
    Args:
        landmarks: Landmark data from LatLong service
        competitors: Competitor data from LatLong service
        business_type: Type of business being analyzed
        
    Returns:
        Complete analysis results
    """
    # Calculate component scores
    footfall = calculate_footfall_proxy(landmarks, competitors)
    landmark_value = calculate_landmark_value(landmarks)
    competitor_density = calculate_competitor_density(competitors)
    
    # Calculate final score
    opportunity_score = calculate_opportunity_score(
        footfall,
        landmark_value,
        competitor_density
    )
    
    # Get interpretation
    interpretation = get_score_interpretation(opportunity_score)
    
    return {
        'opportunity_score': opportunity_score,
        'interpretation': interpretation,
        'breakdown': {
            'footfall_proxy': round(footfall, 1),
            'landmark_value': round(landmark_value, 1),
            'competitor_density': round(competitor_density, 2),
            'competitor_count': competitors.get('count', 0)
        },
        'landmarks_summary': {
            category: data.get('count', 0)
            for category, data in landmarks.get('by_category', {}).items()
        },
        'competitors': competitors
    }
</file>

<file path="frontend/src/components/Dashboard/index.js">
export { default as ScoreCard } from './ScoreCard';
export { default as CompetitorCard } from './CompetitorCard';
export { default as LandmarksCard } from './LandmarksCard';
export { default as AnalysisPanel } from './AnalysisPanel';
export { default as MetricsGrid } from './MetricsGrid';
export { default as LoadingProgress } from './LoadingProgress';
export { default as RecommendedSpotsCard } from './RecommendedSpotsCard';
export * from './Charts';
</file>

<file path="frontend/src/components/Dashboard/LandmarksCard.jsx">
/**
 * Landmarks Card Component
 * Displays nearby landmarks grouped by category with footfall indicators
 */

import { useState } from 'react';

// Landmark category icons and weights
const CATEGORY_CONFIG = {
  metro_station: { icon: '', label: 'Metro Station', weight: 5 },
  metro: { icon: '', label: 'Metro Station', weight: 5 },
  bus_stop: { icon: '', label: 'Bus Stop', weight: 3 },
  bus: { icon: '', label: 'Bus Stop', weight: 3 },
  railway_station: { icon: '', label: 'Railway', weight: 5 },
  railway: { icon: '', label: 'Railway', weight: 5 },
  school: { icon: '', label: 'School', weight: 4 },
  college: { icon: '', label: 'College', weight: 4 },
  university: { icon: '', label: 'University', weight: 4 },
  hospital: { icon: '', label: 'Hospital', weight: 4 },
  clinic: { icon: '', label: 'Clinic', weight: 3 },
  mall: { icon: '', label: 'Mall', weight: 5 },
  office: { icon: '', label: 'Office', weight: 4 },
  residential: { icon: '', label: 'Residential', weight: 3 },
  temple: { icon: '', label: 'Temple/Church', weight: 3 },
  church: { icon: '', label: 'Church', weight: 3 },
  mosque: { icon: '', label: 'Mosque', weight: 3 },
  park: { icon: '', label: 'Park', weight: 2 },
  atm: { icon: '', label: 'ATM', weight: 2 },
  bank: { icon: '', label: 'Bank', weight: 3 },
  bar: { icon: '', label: 'Bar/Pub', weight: 3 },
  pub: { icon: '', label: 'Bar/Pub', weight: 3 },
  restaurant: { icon: '', label: 'Restaurant', weight: 3 },
  cafe: { icon: '', label: 'Cafe', weight: 3 },
  hotel: { icon: '', label: 'Hotel', weight: 4 },
  pharmacy: { icon: '', label: 'Pharmacy', weight: 3 },
  gym: { icon: '', label: 'Gym', weight: 3 },
  supermarket: { icon: '', label: 'Supermarket', weight: 3 },
  nearby: { icon: '', label: 'Nearby Places', weight: 2 },
  // Default fallback
  default: { icon: '', label: 'Other', weight: 1 },
};

export default function LandmarksCard({ landmarks = [], isLoading }) {
  const [showAllLandmarks, setShowAllLandmarks] = useState(false);
  
  // Ensure landmarks is an array
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  
  // Group landmarks by category
  const groupedLandmarks = landmarkList.reduce((acc, landmark) => {
    const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
    if (!acc[category]) {
      acc[category] = [];
    }
    acc[category].push(landmark);
    return acc;
  }, {});

  // Sort categories by weight (highest first)
  const sortedCategories = Object.entries(groupedLandmarks).sort((a, b) => {
    const configA = CATEGORY_CONFIG[a[0]] || CATEGORY_CONFIG.default;
    const configB = CATEGORY_CONFIG[b[0]] || CATEGORY_CONFIG.default;
    return configB.weight - configA.weight;
  });

  // Calculate total footfall value
  const totalFootfallValue = landmarkList.reduce((total, landmark) => {
    const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
    const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
    return total + config.weight;
  }, 0);

  const getFootfallLevel = (value) => {
    if (value >= 30) return { label: 'High', color: 'text-primary-glow' };
    if (value >= 15) return { label: 'Medium', color: 'text-accent-glow' };
    return { label: 'Low', color: 'text-warning-glow' };
  };

  return (
    <div className="glass-panel p-5">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <span className="text-lg"></span>
          Nearby Landmarks
        </h3>
        {!isLoading && (
          <span className="text-xs bg-primary-glow/20 text-primary-glow px-2 py-1 rounded-full">
            {landmarkList.length} found
          </span>
        )}
      </div>

      {isLoading ? (
        <div className="space-y-3">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="flex items-center gap-3">
              <div className="w-8 h-8 bg-slate-700 rounded-lg animate-pulse" />
              <div className="flex-1">
                <div className="h-4 bg-slate-700 rounded animate-pulse w-20 mb-1" />
                <div className="h-3 bg-slate-700/50 rounded animate-pulse w-12" />
              </div>
            </div>
          ))}
        </div>
      ) : landmarkList.length === 0 ? (
        <div className="text-center py-6">
          <span className="text-2xl mb-2 block"></span>
          <p className="text-slate-400 text-sm">No landmarks nearby</p>
          <p className="text-slate-500 text-xs mt-1">May indicate low footfall area</p>
        </div>
      ) : (
        <div className="space-y-2">
          {/* Category Summary */}
          <div className="space-y-2 max-h-48 overflow-y-auto">
            {sortedCategories.map(([category, items]) => {
              const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
              return (
                <div 
                  key={category}
                  className="flex items-center gap-3 p-2 rounded-lg hover:bg-surface-secondary transition-colors"
                >
                  {/* Category icon */}
                  <div className="w-8 h-8 bg-surface-secondary rounded-lg flex items-center justify-center text-lg">
                    {config.icon}
                  </div>
                  
                  {/* Category info */}
                  <div className="flex-1 min-w-0">
                    <p className="text-slate-200 text-sm">{config.label}</p>
                    <p className="text-slate-500 text-xs">{items.length} nearby</p>
                  </div>
                  
                  {/* Weight indicator */}
                  <div className="flex gap-0.5">
                    {[1, 2, 3, 4, 5].map((dot) => (
                      <div
                        key={dot}
                        className={`w-1.5 h-1.5 rounded-full ${
                          dot <= config.weight ? 'bg-primary-glow' : 'bg-slate-700'
                        }`}
                      />
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
          
          {/* Show All Landmarks Button */}
          {showAllLandmarks ? (
            <div className="mt-3 pt-3 border-t border-surface-border">
              <button
                onClick={() => setShowAllLandmarks(false)}
                className="text-xs text-primary-glow hover:text-primary-glow/80 mb-2"
              >
                 Hide individual landmarks
              </button>
              <div className="space-y-1 max-h-48 overflow-y-auto">
                {landmarkList.map((landmark, idx) => {
                  const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
                  const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
                  return (
                    <div key={idx} className="flex items-center gap-2 p-1.5 text-xs rounded hover:bg-surface-secondary">
                      <span>{config.icon}</span>
                      <span className="text-slate-300 truncate flex-1">{landmark.name}</span>
                      {landmark.distance && (
                        <span className="text-slate-500">{landmark.distance}m</span>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <button
              onClick={() => setShowAllLandmarks(true)}
              className="w-full text-xs text-primary-glow hover:text-primary-glow/80 mt-2 py-1"
            >
               Show all {landmarkList.length} landmarks
            </button>
          )}
        </div>
      )}
      
      {/* Footfall value indicator */}
      {!isLoading && landmarkList.length > 0 && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <div className="flex items-center justify-between text-xs">
            <span className="text-slate-500">Footfall Potential</span>
            <span className={getFootfallLevel(totalFootfallValue).color}>
              {getFootfallLevel(totalFootfallValue).label}
              <span className="text-slate-600 ml-1">({totalFootfallValue} pts)</span>
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Map/index.js">
export { default as MapView } from './MapView';
export { default as HeatmapOverlay } from './HeatmapOverlay';
</file>

<file path="frontend/src/components/Map/MapView.jsx">
/**
 * Map Container Component
 * The main map canvas using React-Leaflet
 */

import { useEffect, useRef, useState } from 'react';
import { MapContainer, TileLayer, Marker, Popup, useMap, Circle } from 'react-leaflet';
import L from 'leaflet';
import HeatmapOverlay from './HeatmapOverlay';

// Fix for default marker icons in React-Leaflet
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
});

// Custom marker icons
const createCustomIcon = (color, emoji) => {
  return L.divIcon({
    className: 'custom-marker',
    html: `
      <div style="
        width: 32px;
        height: 32px;
        background: ${color};
        border: 2px solid white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      ">
        ${emoji}
      </div>
    `,
    iconSize: [32, 32],
    iconAnchor: [16, 16],
    popupAnchor: [0, -16],
  });
};

// Numbered recommended spot icon
const createSpotIcon = (rank, color) => {
  return L.divIcon({
    className: 'custom-marker recommended-spot',
    html: `
      <div style="
        width: 36px;
        height: 36px;
        background: linear-gradient(135deg, ${color}, ${color}dd);
        border: 3px solid white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: bold;
        color: white;
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.5), 0 0 20px ${color}40;
        animation: pulse-glow 2s ease-in-out infinite;
      ">
        ${rank}
      </div>
      <style>
        @keyframes pulse-glow {
          0%, 100% { box-shadow: 0 4px 12px rgba(16, 185, 129, 0.5), 0 0 20px ${color}40; }
          50% { box-shadow: 0 4px 20px rgba(16, 185, 129, 0.8), 0 0 30px ${color}60; }
        }
      </style>
    `,
    iconSize: [36, 36],
    iconAnchor: [18, 18],
    popupAnchor: [0, -18],
  });
};

const selectedIcon = createCustomIcon('#10b981', '');
const competitorIcon = createCustomIcon('#f43f5e', '');
const landmarkIcon = createCustomIcon('#06b6d4', '');

// Component to handle map view changes
function MapController({ center, zoom }) {
  const map = useMap();
  
  useEffect(() => {
    if (center) {
      map.flyTo(center, zoom || 15, {
        duration: 1.5,
      });
    }
  }, [center, zoom, map]);
  
  return null;
}

// Component to handle click events
function MapClickHandler({ onClick }) {
  const map = useMap();
  
  useEffect(() => {
    if (!onClick) return;
    
    const handleClick = (e) => {
      onClick({
        lat: e.latlng.lat,
        lng: e.latlng.lng,
      });
    };
    
    map.on('click', handleClick);
    return () => map.off('click', handleClick);
  }, [map, onClick]);
  
  return null;
}

export default function MapView({
  selectedLocation,
  competitors = [],
  landmarks = [],
  recommendedSpots = [],
  isochrone = null,
  onMapClick,
  onSpotClick,
  center = [12.9716, 77.5946], // Default: Bangalore
  zoom = 13,
  showHeatmap = true,
}) {
  const mapRef = useRef(null);
  const [heatmapEnabled, setHeatmapEnabled] = useState(true);
  const [showSpots, setShowSpots] = useState(true);

  // Safely convert to arrays
  const competitorList = Array.isArray(competitors) ? competitors : [];
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  const spotList = Array.isArray(recommendedSpots) ? recommendedSpots : [];

  // Spot colors by rank
  const getSpotColor = (rank) => {
    const colors = {
      1: '#10b981', // Emerald
      2: '#06b6d4', // Cyan
      3: '#3b82f6', // Blue
      4: '#8b5cf6', // Purple
      5: '#6b7280', // Gray
    };
    return colors[rank] || colors[5];
  };

  // Circle area style
  const circleStyle = {
    color: '#10b981',
    weight: 2,
    opacity: 0.8,
    fillColor: '#10b981',
    fillOpacity: 0.1,
  };

  // Calculate radius for the circular area (meters)
  const areaRadius = selectedLocation?.is_major ? 2500 : 1500;

  return (
    <div className="absolute inset-0 z-0">
      <MapContainer
        ref={mapRef}
        center={center}
        zoom={zoom}
        className="w-full h-full"
        zoomControl={true}
        attributionControl={false}
      >
        {/* Dark tile layer */}
        <TileLayer
          url="https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png"
          attribution='&copy; <a href="https://carto.com/">CARTO</a>'
        />

        {/* Map controllers */}
        <MapController 
          center={selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null 
            ? [selectedLocation.lat, selectedLocation.lng] 
            : null} 
          zoom={15}
        />
        <MapClickHandler onClick={onMapClick} />

        {/* Circular area selection - covers the entire selected area */}
        {selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null && (
          <Circle
            center={[selectedLocation.lat, selectedLocation.lng]}
            radius={areaRadius}
            pathOptions={circleStyle}
          />
        )}

        {/* Competition Heatmap Overlay */}
        {selectedLocation && selectedLocation.lat != null && heatmapEnabled && showHeatmap && (
          <HeatmapOverlay
            center={{ lat: selectedLocation.lat, lng: selectedLocation.lng }}
            competitors={competitorList}
            landmarks={landmarkList}
            radius={selectedLocation.is_major ? 2500 : 1500}
            enabled={heatmapEnabled}
          />
        )}

        {/* Selected location marker */}
        {selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null && (
          <Marker 
            position={[selectedLocation.lat, selectedLocation.lng]}
            icon={selectedIcon}
          >
            <Popup>
              <div className="text-slate-900 min-w-[150px]">
                <p className="font-semibold">{selectedLocation.name || 'Selected Location'}</p>
                <p className="text-xs text-slate-500 font-mono mt-1">
                  {Number(selectedLocation.lat).toFixed(6)}, {Number(selectedLocation.lng).toFixed(6)}
                </p>
              </div>
            </Popup>
          </Marker>
        )}

        {/* Recommended Spot markers */}
        {showSpots && spotList
          .filter(s => s.lat != null && s.lng != null)
          .map((spot) => (
          <Marker
            key={`spot-${spot.rank}`}
            position={[spot.lat, spot.lng]}
            icon={createSpotIcon(spot.rank, getSpotColor(spot.rank))}
            eventHandlers={{
              click: () => onSpotClick && onSpotClick(spot)
            }}
          >
            <Popup>
              <div className="text-slate-900 min-w-[180px]">
                <div className="flex items-center gap-2 mb-1">
                  <span className="font-bold text-lg" style={{ color: getSpotColor(spot.rank) }}>#{spot.rank}</span>
                  <span className="font-semibold">Recommended Spot</span>
                </div>
                <p className="text-xs font-mono text-slate-500 mb-2">
                  {spot.lat.toFixed(6)}, {spot.lng.toFixed(6)}
                </p>
                <div className="flex items-center gap-2 mb-2">
                  <span className={`px-2 py-0.5 text-xs rounded-full font-medium ${
                    spot.rating === 'Excellent' ? 'bg-emerald-100 text-emerald-700' :
                    spot.rating === 'Good' ? 'bg-cyan-100 text-cyan-700' :
                    spot.rating === 'Moderate' ? 'bg-amber-100 text-amber-700' :
                    'bg-orange-100 text-orange-700'
                  }`}>
                    {spot.rating}
                  </span>
                  <span className="text-xs text-slate-600">Score: {Math.round(spot.score)}</span>
                </div>
                <ul className="text-xs text-slate-600 space-y-0.5">
                  {spot.reasons?.slice(0, 2).map((reason, i) => (
                    <li key={i} className="flex items-start gap-1">
                      <span className="text-emerald-500"></span>
                      <span>{reason}</span>
                    </li>
                  ))}
                </ul>
              </div>
            </Popup>
          </Marker>
        ))}

        {/* Competitor markers - only show those with coordinates */}
        {competitorList
          .filter(c => c.lat != null && c.lng != null)
          .map((competitor, index) => (
          <Marker
            key={`competitor-${index}`}
            position={[competitor.lat, competitor.lng]}
            icon={competitorIcon}
          >
            <Popup>
              <div className="text-slate-900">
                <p className="font-semibold">{competitor.name}</p>
                <p className="text-xs text-slate-500">{competitor.category}</p>
                {competitor.distance && (
                  <p className="text-xs text-rose-600 mt-1">
                    {competitor.distance}m away
                  </p>
                )}
              </div>
            </Popup>
          </Marker>
        ))}

        {/* Landmark markers - only show those with coordinates */}
        {landmarkList
          .filter(l => l.lat != null && l.lng != null)
          .map((landmark, index) => (
          <Marker
            key={`landmark-${index}`}
            position={[landmark.lat, landmark.lng]}
            icon={landmarkIcon}
          >
            <Popup>
              <div className="text-slate-900">
                <p className="font-semibold">{landmark.name}</p>
                <p className="text-xs text-slate-500">{landmark.category}</p>
              </div>
            </Popup>
          </Marker>
        ))}
      </MapContainer>
      
      {/* Heatmap Toggle & Legend */}
      {selectedLocation && competitorList.length > 0 && (
        <div className="absolute bottom-4 right-4 z-[1000]">
          {/* Toggle Buttons */}
          <div className="flex gap-2 mb-2">
            <button
              onClick={() => setHeatmapEnabled(!heatmapEnabled)}
              className={`px-3 py-2 rounded-lg text-xs font-medium transition-all ${
                heatmapEnabled 
                  ? 'bg-primary-glow text-canvas-deep' 
                  : 'bg-surface-secondary text-slate-400 hover:bg-surface-elevated'
              }`}
            >
              {heatmapEnabled ? ' Heatmap ON' : ' Heatmap OFF'}
            </button>
            {spotList.length > 0 && (
              <button
                onClick={() => setShowSpots(!showSpots)}
                className={`px-3 py-2 rounded-lg text-xs font-medium transition-all ${
                  showSpots 
                    ? 'bg-emerald-500 text-white' 
                    : 'bg-surface-secondary text-slate-400 hover:bg-surface-elevated'
                }`}
              >
                {showSpots ? ` ${spotList.length} Spots` : ' Show Spots'}
              </button>
            )}
          </div>
          
          {/* Legend */}
          {heatmapEnabled && (
            <div className="bg-canvas-base/90 backdrop-blur-sm border border-surface-border rounded-lg p-3 shadow-lg">
              <p className="text-xs font-medium text-slate-300 mb-2">Competition Density</p>
              <div className="flex items-center gap-1">
                <div className="w-4 h-4 rounded" style={{ background: 'rgb(34, 197, 94)' }} />
                <div className="w-4 h-4 rounded" style={{ background: 'rgb(134, 197, 94)' }} />
                <div className="w-4 h-4 rounded" style={{ background: 'rgb(255, 200, 0)' }} />
                <div className="w-4 h-4 rounded" style={{ background: 'rgb(255, 150, 0)' }} />
                <div className="w-4 h-4 rounded" style={{ background: 'rgb(255, 80, 50)' }} />
              </div>
              <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                <span> Opportunity</span>
                <span> High Competition</span>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Search/SearchBar.jsx">
/**
 * Search Bar Component
 * Step 3 in the user flow - Search for a location with autocomplete
 */

import { useState, useEffect, useRef, useCallback } from 'react';
import { searchLocations } from '../../services/api';

// Debounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

export default function SearchBar({ onLocationSelect, disabled }) {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  
  const inputRef = useRef(null);
  const dropdownRef = useRef(null);
  
  const debouncedQuery = useDebounce(query, 300);

  // Fetch suggestions when debounced query changes
  useEffect(() => {
    const fetchSuggestions = async () => {
      if (debouncedQuery.length < 2) {
        setSuggestions([]);
        setIsOpen(false);
        return;
      }

      setIsLoading(true);
      try {
        const results = await searchLocations(debouncedQuery);
        setSuggestions(results);
        setIsOpen(results.length > 0);
        setSelectedIndex(-1);
      } catch (error) {
        console.error('Search error:', error);
        setSuggestions([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchSuggestions();
  }, [debouncedQuery]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target) &&
        !inputRef.current.contains(event.target)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Handle keyboard navigation
  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      setIsOpen(false);
      setSelectedIndex(-1);
      return;
    }

    if (e.key === 'Enter') {
      e.preventDefault();
      // If we have a selected suggestion, use it
      if (isOpen && selectedIndex >= 0 && suggestions[selectedIndex]) {
        handleSelect(suggestions[selectedIndex]);
      } 
      // If we have suggestions but none selected, use the first one
      else if (isOpen && suggestions.length > 0) {
        handleSelect(suggestions[0]);
      }
      // If no suggestions but we have a query, create a manual location
      else if (query.trim().length >= 2) {
        // Trigger a fresh search or use the query as-is
        onLocationSelect({
          name: query.trim(),
          lat: null,
          lng: null,
          needsGeocode: true,
        });
      }
      return;
    }

    if (!isOpen) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex((prev) => 
          prev < suggestions.length - 1 ? prev + 1 : prev
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex((prev) => (prev > 0 ? prev - 1 : -1));
        break;
      default:
        break;
    }
  };

  const handleSelect = (location) => {
    setQuery(location.name);
    setIsOpen(false);
    setSuggestions([]);
    onLocationSelect(location);
  };

  const handleClear = () => {
    setQuery('');
    setSuggestions([]);
    setIsOpen(false);
    inputRef.current?.focus();
  };

  return (
    <div className="space-y-2 relative z-10">
      <label className="block text-sm font-medium text-slate-400">
        Step 3: Which area to analyze?
      </label>
      <p className="text-xs text-slate-500 -mt-1">
        Search for a locality, neighborhood, or city
      </p>

      <div className="relative">
        {/* Search Input */}
        <div className="relative">
          <span className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">
            
          </span>
          <input
            ref={inputRef}
            type="text"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyDown={handleKeyDown}
            onFocus={() => suggestions.length > 0 && setIsOpen(true)}
            disabled={disabled}
            placeholder="Search: Koramangala, Indiranagar, Bandra..."
            className={`
              w-full glass-input pl-10 pr-10
              ${isOpen ? 'border-primary-glow shadow-glow-primary' : ''}
              ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
            `}
          />
          
          {/* Loading / Clear Button */}
          <div className="absolute right-3 top-1/2 -translate-y-1/2">
            {isLoading ? (
              <svg className="w-5 h-5 text-slate-400 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
              </svg>
            ) : query ? (
              <button
                type="button"
                onClick={handleClear}
                className="text-slate-400 hover:text-slate-200 transition-colors"
              >
                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            ) : null}
          </div>
        </div>

        {/* Suggestions Dropdown */}
        {isOpen && suggestions.length > 0 && (
          <div
            ref={dropdownRef}
            className="absolute z-50 w-full mt-2 bg-canvas-base border border-surface-border rounded-lg shadow-glass overflow-hidden animate-slide-in-up"
          >
            <ul className="max-h-64 overflow-y-auto">
              {suggestions.map((suggestion, index) => (
                <li key={suggestion.place_id || index}>
                  <button
                    type="button"
                    onClick={() => handleSelect(suggestion)}
                    className={`
                      w-full flex items-start gap-3 px-4 py-3 text-left
                      hover:bg-surface-elevated transition-colors duration-150
                      ${selectedIndex === index ? 'bg-surface-secondary' : ''}
                    `}
                  >
                    {/* Show different icon for major areas vs others */}
                    <span className="mt-0.5">
                      {suggestion.is_major ? '' : suggestion.is_area ? '' : ''}
                    </span>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <p className="text-slate-200 truncate">{suggestion.name}</p>
                        {suggestion.is_major && (
                          <span className="text-[10px] bg-primary-glow/20 text-primary-glow px-1.5 py-0.5 rounded-full whitespace-nowrap">
                            Major Area
                          </span>
                        )}
                      </div>
                      {suggestion.is_area && !suggestion.is_major && (
                        <p className="text-xs text-slate-500 mt-0.5">Locality</p>
                      )}
                    </div>
                  </button>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* No results message */}
        {isOpen && query.length >= 2 && suggestions.length === 0 && !isLoading && (
          <div className="absolute z-50 w-full mt-2 bg-canvas-base border border-surface-border rounded-lg shadow-glass p-4 text-center text-slate-400 animate-fade-in">
            <p>No locations found for "{query}"</p>
            <p className="text-xs mt-1">Try a different area name or click on the map</p>
          </div>
        )}
      </div>

      {/* Hints */}
      {disabled ? (
        <p className="text-xs text-slate-500 flex items-center gap-1">
          <span className="text-warning-glow"></span>
          Select a business type first
        </p>
      ) : (
        <p className="text-xs text-slate-500">
           You can also click anywhere on the map to select a location
        </p>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom Glassmorphism Utilities */
@layer components {
  .glass-panel {
    @apply bg-surface-primary backdrop-blur-[12px] border border-surface-border rounded-2xl shadow-glass;
  }

  .glass-card {
    @apply bg-surface-secondary backdrop-blur-[12px] border border-surface-border rounded-xl shadow-glass;
  }

  .glass-input {
    @apply bg-canvas-base border border-surface-border rounded-lg px-4 py-3 text-slate-50 placeholder-slate-500 focus:outline-none focus:border-primary-glow focus:shadow-glow-primary transition-all duration-200;
  }

  .btn-primary {
    @apply bg-primary-glow text-canvas-deep font-semibold px-6 py-3 rounded-lg hover:bg-primary-bright active:scale-[0.98] transition-all duration-200 shadow-glow-primary disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none;
  }

  .btn-ghost {
    @apply bg-transparent border border-surface-border text-slate-300 font-medium px-4 py-2 rounded-lg hover:bg-surface-elevated hover:text-slate-50 transition-all duration-200;
  }

  .chip {
    @apply px-3 py-1.5 rounded-full text-sm font-medium transition-all duration-200 cursor-pointer select-none;
  }

  .chip-inactive {
    @apply bg-transparent border border-surface-border text-slate-500 hover:border-slate-500 hover:text-slate-400;
  }

  .chip-active {
    @apply bg-primary-soft border border-primary-glow text-primary-bright shadow-glow-primary;
  }

  .score-high {
    @apply bg-primary-soft border border-primary-glow text-primary-bright;
  }

  .score-medium {
    @apply bg-warning-soft border border-warning-glow text-warning-glow;
  }

  .score-low {
    @apply bg-destructive-soft border border-destructive-glow text-destructive-bright;
  }
}

/* Leaflet Map Dark Theme Overrides */
.leaflet-container {
  background: #020617;
  font-family: 'Inter', sans-serif;
}

.leaflet-control-zoom {
  border: 1px solid rgba(255, 255, 255, 0.08) !important;
  background: rgba(15, 23, 42, 0.9) !important;
  backdrop-filter: blur(12px);
}

.leaflet-control-zoom a {
  background: transparent !important;
  color: #cbd5e1 !important;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08) !important;
}

.leaflet-control-zoom a:hover {
  background: rgba(51, 65, 85, 0.6) !important;
  color: #f8fafc !important;
}

.leaflet-popup-content-wrapper {
  background: rgba(15, 23, 42, 0.95);
  color: #f8fafc;
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  backdrop-filter: blur(12px);
}

.leaflet-popup-tip {
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

/* Custom Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(15, 23, 42, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(100, 116, 139, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(100, 116, 139, 0.7);
}

/* Animations */
@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

.skeleton {
  background: linear-gradient(
    90deg,
    rgba(51, 65, 85, 0.3) 25%,
    rgba(51, 65, 85, 0.5) 50%,
    rgba(51, 65, 85, 0.3) 75%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

/* Pulse Ring Animation for Map Marker */
@keyframes pulseRing {
  0% {
    transform: scale(1);
    opacity: 0.8;
  }
  100% {
    transform: scale(2.5);
    opacity: 0;
  }
}

.marker-pulse-ring {
  animation: pulseRing 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Slide-in animation for dropdowns and panels */
@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.animate-slide-in-up {
  animation: slideInUp 0.2s ease-out;
}

.animate-slide-in-right {
  animation: slideInRight 0.3s ease-out;
}

.animate-fade-in {
  animation: fadeIn 0.2s ease-out;
}

.animate-fadeIn {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slideIn {
  animation: slideIn 0.3s ease-out forwards;
}

/* Custom marker styles */
.custom-marker {
  background: transparent !important;
  border: none !important;
}
</file>

<file path="frontend/src/services/api.js">
/**
 * Hotspot IQ - API Service Layer
 * Handles all communication with the Flask backend
 */

import axios from 'axios';

// Create axios instance with base configuration
const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:5000/api',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for logging
api.interceptors.request.use(
  (config) => {
    console.log(` API Request: ${config.method?.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    console.error('API Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    console.error('API Response Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

/**
 * Search for locations using autocomplete
 * @param {string} query - Search term
 * @returns {Promise<Array>} Location suggestions
 */
export const searchLocations = async (query) => {
  if (!query || query.length < 2) return [];
  
  try {
    const response = await api.get('/autocomplete', { params: { query, limit: 10 } });
    const suggestions = response.data.suggestions || [];
    
    // LatLong autocomplete returns { name, geoid } without coordinates
    // We need to geocode to get coordinates when user selects a location
    return suggestions.map(s => ({
      name: s.name,
      place_id: s.place_id || s.geoid?.toString() || s.name,
      geoid: s.geoid,
      // lat/lng may be null from autocomplete - will be geocoded on selection
      lat: s.lat,
      lng: s.lng
    }));
  } catch (error) {
    console.error('Search error:', error);
    throw error;
  }
};

/**
 * Geocode a location name to get coordinates
 * @param {string} address - Location name/address
 * @returns {Promise<Object>} Location with coordinates
 */
export const geocodeLocation = async (address) => {
  try {
    const response = await api.get('/geocode', { params: { address } });
    return response.data;
  } catch (error) {
    console.error('Geocode error:', error);
    throw error;
  }
};

/**
 * Analyze a location for business potential
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {string} businessType - Type of business
 * @param {Array<string>} filters - Proximity filters
 * @param {boolean} isMajor - Whether this is a major area (larger radius)
 * @returns {Promise<Object>} Analysis results
 */
export const analyzeLocation = async (lat, lng, businessType, filters = [], isMajor = false) => {
  try {
    const response = await api.post('/analyze', {
      lat,
      lng,
      business_type: businessType,
      filters,
      is_major: isMajor,
    });
    return response.data;
  } catch (error) {
    console.error('Analysis error:', error);
    throw error;
  }
};

/**
 * Get isochrone polygon for reachability
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} distanceKm - Distance in kilometers (default: 1.0)
 * @returns {Promise<Object>} GeoJSON Feature
 * 
 * Also supports legacy mode/time format which is converted on backend:
 * @param {string} mode - Travel mode (walk, bike, car) - optional
 * @param {number} timeMinutes - Travel time in minutes - optional
 */
export const getIsochrone = async (lat, lng, distanceKmOrMode = 1.0, timeMinutes = null) => {
  try {
    let payload = { lat, lng };
    
    // Support both new format (distance_km) and legacy (mode + time_minutes)
    if (typeof distanceKmOrMode === 'number' && timeMinutes === null) {
      payload.distance_km = distanceKmOrMode;
    } else if (typeof distanceKmOrMode === 'string') {
      payload.mode = distanceKmOrMode;
      payload.time_minutes = timeMinutes || 15;
    } else {
      payload.distance_km = distanceKmOrMode;
    }
    
    const response = await api.post('/isochrone', payload);
    return response.data;
  } catch (error) {
    console.error('Isochrone error:', error);
    throw error;
  }
};

/**
 * Get Digipin for a location
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @returns {Promise<Object>} Digipin data
 */
export const getDigipin = async (lat, lng) => {
  try {
    const response = await api.get('/digipin', { params: { lat, lng } });
    return response.data;
  } catch (error) {
    console.error('Digipin error:', error);
    throw error;
  }
};

/**
 * Send chat message to AI assistant
 * @param {string} message - User message
 * @param {Object} context - Location context
 * @returns {Promise<Object>} AI response
 */
export const chat = async (message, context = {}) => {
  try {
    const response = await api.post('/chat', {
      message,
      context,
    });
    return response.data;
  } catch (error) {
    console.error('Chat error:', error);
    throw error;
  }
};

/**
 * Check supply chain feasibility
 * @param {number} storeLat - Store latitude
 * @param {number} storeLng - Store longitude
 * @param {number} warehouseLat - Warehouse latitude
 * @param {number} warehouseLng - Warehouse longitude
 * @returns {Promise<Object>} Supply chain analysis
 */
export const checkSupplyChain = async (storeLat, storeLng, warehouseLat, warehouseLng) => {
  try {
    const response = await api.post('/supply-chain', {
      store_lat: storeLat,
      store_lng: storeLng,
      warehouse_lat: warehouseLat,
      warehouse_lng: warehouseLng,
    });
    return response.data;
  } catch (error) {
    console.error('Supply chain error:', error);
    throw error;
  }
};

/**
 * Health check
 * @returns {Promise<Object>} Health status
 */
export const healthCheck = async () => {
  try {
    const response = await api.get('/health');
    return response.data;
  } catch (error) {
    console.error('Health check failed:', error);
    throw error;
  }
};

export default api;
</file>

<file path="backend/routes/analysis_routes.py">
"""
Hotspot IQ - Analysis Routes
Handles location analysis, isochrone, and scoring endpoints.
"""

import re
import math
from flask import Blueprint, request, jsonify
from services.latlong_service import latlong_service
from services.places_service import fetch_competitors, fetch_landmarks
from utils.score_calculator import analyze_location, find_recommended_spots

analysis_bp = Blueprint('analysis', __name__)


# Category detection keywords for landmarks
LANDMARK_CATEGORY_KEYWORDS = {
    'metro_station': ['metro', 'subway'],
    'bus_stop': ['bus stop', 'bus stand', 'bus station'],
    'railway_station': ['railway', 'train station', 'rail'],
    'school': ['school', 'vidyalaya', 'vidya'],
    'college': ['college', 'university', 'institute', 'iit', 'nit'],
    'hospital': ['hospital', 'medical', 'clinic', 'healthcare'],
    'mall': ['mall', 'plaza', 'shopping'],
    'office': ['office', 'corporate', 'tech park', 'business'],
    'residential': ['apartment', 'residency', 'housing', 'colony'],
    'temple': ['temple', 'mandir', 'church', 'mosque', 'gurudwara', 'masjid'],
    'park': ['park', 'garden', 'ground'],
    'atm': ['atm', 'bank'],
    'bar': ['bar', 'pub', 'brewery'],
    'restaurant': ['restaurant', 'dhaba', 'food', 'kitchen', 'cafe', 'diner'],
    'hotel': ['hotel', 'lodge', 'guest house', 'inn', 'oyo', 'capital o'],
}


def detect_landmark_category(name: str) -> str:
    """Detect category from landmark name."""
    name_lower = name.lower()
    for category, keywords in LANDMARK_CATEGORY_KEYWORDS.items():
        if any(kw in name_lower for kw in keywords):
            return category
    return 'default'


def parse_landmarks_from_text(landmark_text, business_type=''):
    """
    Parse landmark info from reverse geocode response.
    Example inputs: 
        "< 0.5km from Cafe Noir, < 0.5km from Farzi Cafe"
        "~ 0.5km from SDH Danapur, ~ 0.5km from Pizza Corner"
    
    Returns:
        tuple: (all_landmarks, competitors_only)
    """
    if not landmark_text:
        return [], []
    
    all_landmarks = []
    competitors = []
    
    # Business type keywords to identify competitors
    competitor_keywords = {
        'cafe': ['cafe', 'coffee', 'tea', 'bakery', 'starbucks', 'barista', 'roasters', 'brew', 'chai'],
        'restaurant': ['restaurant', 'food', 'kitchen', 'dhaba', 'biryani', 'pizza', 'burger', 'diner', 'sweets', 'corner', 'hotel', 'eatery', 'cuisine', 'tandoor', 'grill', 'chinese', 'mughlai'],
        'gym': ['gym', 'fitness', 'yoga', 'sports', 'crossfit', 'health club', 'workout'],
        'pharmacy': ['pharmacy', 'medical', 'chemist', 'medicine', 'drugstore', 'pharma', 'medico'],
        'salon': ['salon', 'spa', 'beauty', 'hair', 'parlour', 'parlor', 'unisex', 'barber'],
        'retail': ['store', 'mart', 'shop', 'retail', 'boutique', 'emporium', 'showroom'],
        'grocery': ['grocery', 'kirana', 'supermarket', 'mart', 'provision', 'general store'],
    }
    
    # Parse each landmark mention
    parts = landmark_text.split(',')
    for part in parts:
        part = part.strip()
        # Extract distance and name - handle variations like:
        # "< 0.5km from X", "~ 0.5km from X", "> 0.5km from X", "0.5km from X"
        match = re.match(r'[<>~]?\s*([\d.]+)\s*km\s+from\s+(.+)', part, re.IGNORECASE)
        if match:
            distance_km = float(match.group(1))
            name = match.group(2).strip()
            
            # Determine category based on name
            category = 'landmark'
            keywords = competitor_keywords.get(business_type, [])
            is_competitor = any(kw in name.lower() for kw in keywords)
            
            if is_competitor:
                category = business_type
            
            landmark = {
                'name': name,
                'distance': int(distance_km * 1000),  # Convert to meters
                'category': category,
                'is_competitor': is_competitor
            }
            
            # Add to all landmarks list
            all_landmarks.append(landmark)
            
            # Also track competitors separately
            if is_competitor:
                competitors.append(landmark)
    
    return all_landmarks, competitors


@analysis_bp.route('/analyze', methods=['POST'])
def analyze():
    """
    POST /api/analyze
    
    Performs comprehensive location analysis including opportunity score.
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    lat = data.get('lat')
    lng = data.get('lng')
    business_type = data.get('business_type', 'other')
    filters = data.get('filters', [])
    is_major_area = data.get('is_major', False)
    
    # Use larger radius for major areas (2500m) vs regular locations (1000m)
    default_radius = 2500 if is_major_area else 1000
    radius = data.get('radius', default_radius)
    
    print(f" Analysis Request: lat={lat}, lng={lng}, business_type={business_type}, is_major={is_major_area}, radius={radius}m")
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng are required'}), 400
    
    if not business_type:
        return jsonify({'error': 'business_type is required'}), 400
    
    # Get reverse geocode for address info (includes landmark text)
    address_info = latlong_service.reverse_geocode(lat, lng)
    
    # Parse landmarks from reverse geocode landmark field
    parsed_landmarks, _ = parse_landmarks_from_text(
        address_info.get('landmark', ''), 
        business_type
    )
    
    # Get landmarks from multiple sample points to cover the full radius
    # Sample points: center + 4 cardinal directions + 4 diagonal directions
    sample_offsets = [
        (0, 0),  # Center
        (0.7, 0), (-0.7, 0), (0, 0.7), (0, -0.7),  # Cardinal directions at 70% radius
        (0.5, 0.5), (-0.5, 0.5), (0.5, -0.5), (-0.5, -0.5),  # Diagonals at 50% radius
    ]
    
    # Convert radius to lat/lng offsets
    lat_offset_per_m = 1 / 111000  # ~1 degree per 111km
    lng_offset_per_m = 1 / (111000 * math.cos(math.radians(lat)))
    
    nearby_landmarks = []
    landmark_names_seen = set()
    
    for lat_mult, lng_mult in sample_offsets:
        sample_lat = lat + (lat_mult * radius * lat_offset_per_m)
        sample_lng = lng + (lng_mult * radius * lng_offset_per_m)
        
        # Get landmarks at this sample point
        sample_landmarks = latlong_service.get_landmarks(sample_lat, sample_lng)
        
        for lm in sample_landmarks:
            lm_name = lm.get('name', '').lower()
            if lm_name and lm_name not in landmark_names_seen:
                landmark_names_seen.add(lm_name)
                nearby_landmarks.append(lm)
    
    # Fetch competitors using the new places_service (covers entire radius)
    print(f" Fetching competitors: category={business_type}, radius={radius}m")
    osm_competitors = fetch_competitors(lat, lng, radius, business_type)
    
    # Fetch landmarks using places_service for better area coverage
    osm_landmarks = fetch_landmarks(lat, lng, radius)
    
    # Also fetch landmarks from LatLong POI API for additional data
    latlong_poi_categories = ['hospital', 'school', 'hotel', 'bank', 'atm', 'mall', 'restaurant']
    latlong_pois = []
    for poi_cat in latlong_poi_categories:
        try:
            poi_result = latlong_service.get_poi(lat, lng, poi_cat, radius)
            for poi in poi_result.get('pois', []):
                latlong_pois.append({
                    'name': poi.get('name', ''),
                    'category': poi_cat,
                    'lat': poi.get('lat', lat),
                    'lng': poi.get('lng', lng)
                })
        except Exception as e:
            print(f" Error fetching POI {poi_cat}: {e}")
    
    print(f" Found {len(latlong_pois)} POIs from LatLong API")
    
    # Combine all landmarks - start with parsed landmarks
    all_landmarks = []
    existing_names = set()
    
    # Add parsed landmarks with detected categories
    for lm in parsed_landmarks:
        lm_name = lm.get('name', '')
        if lm_name.lower() not in existing_names:
            # Detect category from name
            lm['category'] = detect_landmark_category(lm_name)
            all_landmarks.append(lm)
            existing_names.add(lm_name.lower())
    
    # Add landmarks from Landmarks API with detected categories
    for lm in nearby_landmarks:
        lm_name = lm.get('name', '')
        if lm_name.lower() not in existing_names:
            lm['category'] = detect_landmark_category(lm_name)
            all_landmarks.append(lm)
            existing_names.add(lm_name.lower())
    
    # Add landmarks from OpenStreetMap (for better area coverage)
    for lm in osm_landmarks:
        lm_name = lm.get('name', '')
        if lm_name.lower() not in existing_names:
            # Convert places_service format to expected format
            all_landmarks.append({
                'name': lm_name,
                'lat': lm.get('lat'),
                'lng': lm.get('lng'),
                'category': lm.get('type', 'landmark')
            })
            existing_names.add(lm_name.lower())
    
    # Add landmarks from LatLong POI API
    for poi in latlong_pois:
        poi_name = poi.get('name', '')
        if poi_name.lower() not in existing_names:
            all_landmarks.append(poi)
            existing_names.add(poi_name.lower())
    
    print(f" Total landmarks combined: {len(all_landmarks)}")
    
    # Format competitors with distance calculation
    all_competitors = []
    for comp in osm_competitors:
        # Calculate approximate distance in meters
        R = 6371000  # Earth's radius in meters
        lat1, lon1 = math.radians(lat), math.radians(lng)
        lat2, lon2 = math.radians(comp.get('lat', lat)), math.radians(comp.get('lng', lng))
        dlat, dlon = lat2 - lat1, lon2 - lon1
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        distance = int(R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)))
        
        all_competitors.append({
            'name': comp.get('name', 'Unknown'),
            'category': business_type,
            'lat': comp.get('lat'),
            'lng': comp.get('lng'),
            'distance': distance,
            'is_competitor': True
        })
    
    # Sort competitors by distance
    all_competitors.sort(key=lambda x: x.get('distance', 9999))
    
    # Get Digipin
    digipin_info = latlong_service.get_digipin(lat, lng)
    
    # Build landmarks structure for analysis
    landmarks_data = {
        'by_category': {'nearby': {'count': len(all_landmarks), 'pois': all_landmarks}},
        'total_count': len(all_landmarks),
        'all_pois': all_landmarks
    }
    
    # Build competitors structure
    competitors_data = {
        'count': len(all_competitors),
        'nearby': all_competitors
    }
    
    # Perform analysis
    analysis_result = analyze_location(landmarks_data, competitors_data, business_type)
    
    # Find recommended spots for business setup
    print(f" Finding recommended spots in the area...")
    recommended_spots = find_recommended_spots(
        center_lat=lat,
        center_lng=lng,
        radius=radius,
        competitors=all_competitors,
        landmarks=all_landmarks,
        max_spots=5
    )
    print(f" Found {len(recommended_spots)} recommended spots")
    
    # Compile response - return ALL competitors for heatmap accuracy
    response = {
        'location': {
            'lat': lat,
            'lng': lng,
            'address': address_info,
            'digipin': digipin_info.get('digipin', '')
        },
        'business_type': business_type,
        'filters_applied': filters,
        'recommended_spots': recommended_spots,  # NEW: Recommended business locations
        'competitors': {
            'count': len(all_competitors),
            'nearby': all_competitors  # Return ALL competitors for heatmap
        },
        'landmarks': {
            'total': len(all_landmarks),
            'by_category': {'nearby': len(all_landmarks)},
            'list': all_landmarks  # Return all landmarks
        },
        'footfall_proxy': 'high' if analysis_result['breakdown']['footfall_proxy'] > 60 else 'medium' if analysis_result['breakdown']['footfall_proxy'] > 30 else 'low'
    }
    
    return jsonify(response)


@analysis_bp.route('/isochrone', methods=['POST'])
def get_isochrone():
    """
    POST /api/isochrone
    
    Returns GeoJSON polygon for isochrone visualization.
    
    Request body:
    {
        "lat": 12.9716,
        "lng": 77.5946,
        "distance_km": 1.0
    }
    
    Also accepts legacy format with time_minutes (converts to distance):
    {
        "lat": 12.9716,
        "lng": 77.5946,
        "mode": "bike",
        "time_minutes": 15
    }
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    lat = data.get('lat')
    lng = data.get('lng')
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng are required'}), 400
    
    # Support both new API (distance_km) and legacy (time_minutes + mode)
    distance_km = data.get('distance_km')
    
    if distance_km is None:
        # Convert from legacy time-based format
        mode = data.get('mode', 'bike')
        time_minutes = data.get('time_minutes', 15)
        
        # Validate mode and time
        speeds = {'walk': 5, 'bike': 15, 'car': 30}  # km/h
        speed = speeds.get(mode, 15)
        distance_km = (speed * time_minutes) / 60
    
    # Validate distance
    if distance_km < 0.1 or distance_km > 50:
        return jsonify({'error': 'distance_km must be between 0.1 and 50'}), 400
    
    result = latlong_service.get_isochrone(lat, lng, distance_km)
    
    return jsonify(result)


@analysis_bp.route('/poi', methods=['GET'])
def get_poi():
    """
    GET /api/poi?lat={lat}&lng={lng}&category={category}&radius={radius}
    
    Returns Points of Interest by category.
    """
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    category = request.args.get('category', '')
    radius = request.args.get('radius', 1000, type=int)
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng are required'}), 400
    
    if not category:
        return jsonify({'error': 'category is required'}), 400
    
    result = latlong_service.get_poi(lat, lng, category, radius)
    
    return jsonify(result)


@analysis_bp.route('/supply-chain', methods=['POST'])
def check_supply_chain():
    """
    POST /api/supply-chain
    
    Checks logistics feasibility between store and warehouse.
    
    Request body:
    {
        "store_lat": 12.9716,
        "store_lng": 77.5946,
        "warehouse_lat": 13.0827,
        "warehouse_lng": 77.5877
    }
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    store_lat = data.get('store_lat')
    store_lng = data.get('store_lng')
    warehouse_lat = data.get('warehouse_lat')
    warehouse_lng = data.get('warehouse_lng')
    
    if None in [store_lat, store_lng, warehouse_lat, warehouse_lng]:
        return jsonify({'error': 'All coordinates are required'}), 400
    
    # Calculate distance matrix
    result = latlong_service.distance_matrix(
        origins=[{'lat': warehouse_lat, 'lng': warehouse_lng}],
        destinations=[{'lat': store_lat, 'lng': store_lng}]
    )
    
    # Parse result (simplified - actual implementation depends on API response)
    rows = result.get('rows', [])
    if rows and rows[0].get('elements'):
        element = rows[0]['elements'][0]
        distance_km = element.get('distance', {}).get('value', 0) / 1000
        duration_mins = element.get('duration', {}).get('value', 0) / 60
    else:
        # Fallback: estimate using straight-line distance
        import math
        dlat = store_lat - warehouse_lat
        dlng = store_lng - warehouse_lng
        distance_km = math.sqrt(dlat**2 + dlng**2) * 111  # Rough km conversion
        duration_mins = distance_km * 2  # Assume 30 km/h average
    
    # Determine feasibility
    if duration_mins < 30:
        feasibility = 'excellent'
        message = 'Excellent logistics - Quick delivery possible'
        recommendation = 'This location is well-positioned for efficient supply chain operations.'
    elif duration_mins < 45:
        feasibility = 'acceptable'
        message = 'Acceptable logistics - Standard delivery times'
        recommendation = 'Delivery times are manageable but consider optimizing routes.'
    else:
        feasibility = 'warning'
        message = 'High Logistics Cost - Drive time exceeds 45 minutes'
        recommendation = 'Consider a closer warehouse or factor in higher delivery costs.'
    
    return jsonify({
        'distance_km': round(distance_km, 1),
        'drive_time_minutes': round(duration_mins),
        'feasibility': feasibility,
        'message': message,
        'recommendation': recommendation
    })
</file>

<file path="frontend/src/App.jsx">
/**
 * App.jsx - Main Application Component
 * Hotspot IQ - Location Intelligence Platform
 */

import { useState, useCallback } from 'react';

// Layout
import { Header } from './components/Layout';

// Components
import { BusinessTypeSelector, ProximityFilters } from './components/Filters';
import { SearchBar } from './components/Search';
import { MapView } from './components/Map';
import { AnalysisPanel, LoadingProgress } from './components/Dashboard';

// Hooks
import { useAnalysis } from './hooks';

// API
import { geocodeLocation } from './services/api';

export default function App() {
  // Step 1: Business Type
  const [businessType, setBusinessType] = useState(null);
  
  // Step 2: Proximity Filters
  const [selectedFilters, setSelectedFilters] = useState([]);
  
  // Step 3: Selected Location
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [isGeocoding, setIsGeocoding] = useState(false);
  
  // Analysis state
  const { 
    analysis, 
    isochrone, 
    isLoading, 
    error,
    loadingStatus,
    analyze, 
    clearAnalysis 
  } = useAnalysis();
  
  // Panel state
  const [isPanelOpen, setIsPanelOpen] = useState(false);

  // Handle location selection - geocode if needed
  const handleLocationSelect = useCallback(async (location) => {
    // If location already has coordinates, use it directly
    if (location.lat != null && location.lng != null) {
      setSelectedLocation(location);
      return;
    }
    
    // Otherwise, geocode the location name to get coordinates
    setIsGeocoding(true);
    try {
      const geocoded = await geocodeLocation(location.name);
      if (geocoded && geocoded.lat && geocoded.lng) {
        setSelectedLocation({
          name: location.name,
          lat: geocoded.lat,
          lng: geocoded.lng,
          address: geocoded.address,
          geoid: location.geoid,
          is_major: location.is_major || false,  // Preserve major area flag
          is_area: location.is_area || false,
        });
      } else {
        console.error('Geocoding returned no coordinates');
        // Show an alert or set an error state
        alert('Could not find coordinates for this location. Please try a different search.');
      }
    } catch (error) {
      console.error('Geocode error:', error);
      alert('Could not find coordinates for this location. Please try a different search.');
    } finally {
      setIsGeocoding(false);
    }
  }, []);

  // Handle map click
  const handleMapClick = useCallback((coords) => {
    setSelectedLocation({
      name: `${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}`,
      lat: coords.lat,
      lng: coords.lng,
    });
  }, []);

  // Handle analyze button click
  const handleAnalyze = useCallback(async () => {
    if (!selectedLocation || !businessType) return;
    
    // Ensure we have coordinates
    if (selectedLocation.lat == null || selectedLocation.lng == null) {
      alert('Location coordinates are missing. Please select a location from the search results.');
      return;
    }
    
    await analyze(selectedLocation, businessType, selectedFilters);
    setIsPanelOpen(true);
  }, [selectedLocation, businessType, selectedFilters, analyze]);

  // Handle viewing a recommended spot on the map
  const handleViewSpot = useCallback((spot) => {
    // This will cause the map to pan to the spot location
    // We can show a temporary marker or highlight
    console.log('View spot:', spot);
    // The spot marker is already on the map, just close the panel so user can see it
    setIsPanelOpen(false);
  }, []);

  // Check if ready to analyze - need coordinates
  const canAnalyze = businessType && selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null && !isLoading && !isGeocoding;

  return (
    <div className="h-screen flex flex-col bg-canvas-base">
      {/* Header */}
      <Header />

      {/* Main content */}
      <div className="flex-1 relative overflow-hidden">
        {/* Map Layer */}
        <MapView
          selectedLocation={selectedLocation}
          competitors={analysis?.competitors?.nearby || []}
          landmarks={analysis?.landmarks?.list || []}
          recommendedSpots={analysis?.recommended_spots || []}
          isochrone={isochrone}
          onMapClick={handleMapClick}
          onSpotClick={handleViewSpot}
        />

        {/* Control Panel - Left Side */}
        <div className="absolute left-4 top-4 bottom-4 w-80 z-10 flex flex-col gap-4 overflow-y-auto pointer-events-none">
          <div className="pointer-events-auto space-y-4">
            {/* Step 1: Business Type - Highest z-index for dropdown */}
            <div className="glass-panel p-4 relative z-30">
              <BusinessTypeSelector
                value={businessType}
                onChange={(value) => {
                  setBusinessType(value);
                  clearAnalysis();
                }}
              />
            </div>

            {/* Step 2: Proximity Filters - Lower z-index */}
            <div className="glass-panel p-4 relative z-20">
              <ProximityFilters
                value={selectedFilters}
                onChange={setSelectedFilters}
              />
            </div>

            {/* Step 3: Location Search - Lowest z-index */}
            <div className="glass-panel p-4 relative z-10">
              <SearchBar
                onLocationSelect={handleLocationSelect}
                disabled={!businessType}
              />
            </div>

            {/* Analyze Button */}
            {selectedLocation && (
              <button
                onClick={handleAnalyze}
                disabled={!canAnalyze}
                className={`
                  w-full btn-primary py-4 text-lg font-semibold
                  ${!canAnalyze ? 'opacity-50 cursor-not-allowed' : 'animate-glow-pulse'}
                `}
              >
                {isLoading ? (
                  <span className="flex items-center justify-center gap-2">
                    <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    Analyzing...
                  </span>
                ) : isGeocoding ? (
                  <span className="flex items-center justify-center gap-2">
                    <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    Finding location...
                  </span>
                ) : (
                  ' Analyze Location'
                )}
              </button>
            )}

            {/* Loading Progress Indicator */}
            {(isLoading || loadingStatus.step === 'complete') && (
              <LoadingProgress status={loadingStatus} isLoading={isLoading} />
            )}

            {/* Error message */}
            {error && (
              <div className="glass-panel p-4 border-destructive-glow/50 bg-destructive-glow/10">
                <p className="text-destructive-glow text-sm flex items-center gap-2">
                  <span></span>
                  {error}
                </p>
              </div>
            )}
          </div>
        </div>

        {/* Quick Stats - Top Right */}
        {selectedLocation && !isLoading && analysis && (
          <div className="absolute right-4 top-4 z-10">
            <button
              onClick={() => setIsPanelOpen(true)}
              className="glass-panel p-4 hover:bg-surface-elevated transition-colors cursor-pointer group"
            >
              <div className="flex items-center gap-4">
                {/* Recommended spots preview */}
                <div className="text-center">
                  <p className="text-3xl font-bold text-emerald-400">
                    {analysis.recommended_spots?.length || 0}
                  </p>
                  <p className="text-xs text-slate-500">Spots Found</p>
                </div>
                
                <div className="w-px h-12 bg-surface-border" />
                
                {/* Stats preview */}
                <div className="text-left">
                  <p className="text-sm text-slate-300">
                    <span className="text-destructive-glow font-medium">{analysis.competitors?.count || 0}</span> competitors
                  </p>
                  <p className="text-sm text-slate-300">
                    <span className="text-accent-glow font-medium">{analysis.landmarks?.total || 0}</span> landmarks
                  </p>
                </div>
                
                {/* Expand hint */}
                <div className="text-slate-500 group-hover:text-slate-300 transition-colors">
                  <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </div>
              </div>
            </button>
          </div>
        )}
      </div>

      {/* Analysis Panel */}
      <AnalysisPanel
        analysis={analysis}
        isLoading={isLoading}
        isOpen={isPanelOpen}
        onClose={() => setIsPanelOpen(false)}
        onViewSpot={handleViewSpot}
      />
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/AnalysisPanel.jsx">
/**
 * Analysis Panel Component
 * Combines all analysis cards in a slide-out panel
 */

import RecommendedSpotsCard from './RecommendedSpotsCard';
import CompetitorCard from './CompetitorCard';
import LandmarksCard from './LandmarksCard';

export default function AnalysisPanel({ 
  analysis,
  isLoading,
  isOpen,
  onClose,
  onViewSpot 
}) {
  if (!isOpen) return null;

  return (
    <>
      {/* Backdrop */}
      <div 
        className="fixed inset-0 bg-black/50 backdrop-blur-sm z-40"
        onClick={onClose}
      />
      
      {/* Panel */}
      <div className="fixed right-0 top-0 h-full w-full max-w-md bg-canvas-overlay border-l border-surface-border z-50 overflow-hidden flex flex-col animate-slide-in-right">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-surface-border bg-surface-elevated">
          <div>
            <h2 className="text-lg font-semibold text-slate-100">
              Location Analysis
            </h2>
            {analysis?.location && (
              <p className="text-sm text-slate-400 truncate max-w-[280px]">
                {analysis.location.name || analysis.address?.formatted_address || `${analysis.location.lat?.toFixed(4)}, ${analysis.location.lng?.toFixed(4)}`}
              </p>
            )}
          </div>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-surface-secondary transition-colors text-slate-400 hover:text-slate-200"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {/* Summary stats */}
          {!isLoading && analysis && (
            <div className="grid grid-cols-3 gap-2">
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-emerald-400">
                  {analysis?.recommended_spots?.length || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Optimal Spots
                </div>
              </div>
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-rose-400">
                  {analysis?.competitors?.count || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Competitors
                </div>
              </div>
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-cyan-400">
                  {analysis?.landmarks?.total || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Landmarks
                </div>
              </div>
            </div>
          )}
          
          {/* Recommended Spots - Primary focus */}
          <RecommendedSpotsCard 
            spots={analysis?.recommended_spots || []}
            isLoading={isLoading}
            onViewSpot={onViewSpot}
          />
          
          {/* Competitors */}
          <CompetitorCard 
            competitors={analysis?.competitors?.nearby || []}
            isLoading={isLoading}
          />
          
          {/* Landmarks */}
          <LandmarksCard 
            landmarks={analysis?.landmarks?.list || []}
            isLoading={isLoading}
          />
          
          {/* DIGIPIN */}
          {!isLoading && analysis?.location?.digipin && (
            <div className="glass-panel p-4">
              <h3 className="text-sm font-medium text-slate-400 mb-2 flex items-center gap-2">
                <span className="text-lg"></span>
                DIGIPIN
              </h3>
              <div className="bg-surface-secondary rounded-lg p-3">
                <p className="font-mono text-primary-glow text-lg tracking-wider text-center">
                  {analysis.location.digipin}
                </p>
              </div>
              <p className="text-xs text-slate-500 mt-2 text-center">
                India Post digital address
              </p>
            </div>
          )}
        </div>
        
        {/* Footer actions */}
        <div className="p-4 border-t border-surface-border bg-surface-elevated">
          <div className="grid grid-cols-2 gap-3">
            <button className="px-4 py-2 bg-surface-secondary text-slate-300 rounded-lg hover:bg-slate-700 transition-colors text-sm">
              Export Report
            </button>
            <button className="btn-primary text-sm">
              Ask AI Assistant
            </button>
          </div>
        </div>
      </div>
    </>
  );
}
</file>

<file path="frontend/src/components/Dashboard/CompetitorCard.jsx">
/**
 * Competitor Card Component
 * Displays nearby competitors with distance information
 */

import { useState } from 'react';

export default function CompetitorCard({ competitors = [], isLoading }) {
  const [showAll, setShowAll] = useState(false);
  
  // Ensure competitors is an array
  const competitorList = Array.isArray(competitors) ? competitors : [];
  
  // Sort by distance (closest first)
  const sortedCompetitors = [...competitorList].sort((a, b) => 
    (a.distance || 9999) - (b.distance || 9999)
  );
  
  // Show first 20 or all based on toggle
  const displayCount = showAll ? sortedCompetitors.length : Math.min(20, sortedCompetitors.length);
  const displayedCompetitors = sortedCompetitors.slice(0, displayCount);

  const getDistanceColor = (distance) => {
    if (distance <= 200) return 'text-destructive-glow';
    if (distance <= 500) return 'text-warning-glow';
    return 'text-slate-400';
  };

  const getDistanceLabel = (distance) => {
    if (distance >= 1000) {
      return `${(distance / 1000).toFixed(1)}km`;
    }
    return `${distance}m`;
  };

  return (
    <div className="glass-panel p-5">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <span className="text-lg"></span>
          Nearby Competitors
        </h3>
        {!isLoading && (
          <span className="text-xs bg-destructive-glow/20 text-destructive-glow px-2 py-1 rounded-full">
            {competitors.length} found
          </span>
        )}
      </div>

      {isLoading ? (
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="flex items-center gap-3">
              <div className="w-8 h-8 bg-slate-700 rounded-full animate-pulse" />
              <div className="flex-1">
                <div className="h-4 bg-slate-700 rounded animate-pulse w-3/4 mb-1" />
                <div className="h-3 bg-slate-700/50 rounded animate-pulse w-1/2" />
              </div>
            </div>
          ))}
        </div>
      ) : competitors.length === 0 ? (
        <div className="text-center py-6">
          <span className="text-2xl mb-2 block"></span>
          <p className="text-slate-400 text-sm">No competitors nearby!</p>
          <p className="text-slate-500 text-xs mt-1">Great opportunity zone</p>
        </div>
      ) : (
        <div className="space-y-2">
          <div className="max-h-80 overflow-y-auto space-y-2 pr-1">
            {displayedCompetitors.map((competitor, index) => (
              <div 
                key={index}
                className="flex items-start gap-3 p-2 rounded-lg hover:bg-surface-secondary transition-colors"
              >
                {/* Index badge */}
                <div className="w-6 h-6 bg-destructive-glow/20 text-destructive-glow rounded-full flex items-center justify-center text-xs font-medium flex-shrink-0">
                  {index + 1}
                </div>
                
                {/* Competitor info */}
                <div className="flex-1 min-w-0">
                  <p className="text-slate-200 text-sm truncate">{competitor.name}</p>
                  <p className="text-slate-500 text-xs truncate">{competitor.category}</p>
                </div>
                
                {/* Distance */}
                {competitor.distance !== undefined && (
                  <span className={`text-xs font-mono flex-shrink-0 ${getDistanceColor(competitor.distance)}`}>
                    {getDistanceLabel(competitor.distance)}
                  </span>
                )}
              </div>
            ))}
          </div>
          
          {/* Show more/less toggle */}
          {sortedCompetitors.length > 20 && (
            <button
              onClick={() => setShowAll(!showAll)}
              className="w-full text-center text-xs text-primary-glow hover:text-primary-glow/80 py-2 transition-colors"
            >
              {showAll 
                ? ` Show less` 
                : ` Show all ${sortedCompetitors.length} competitors`}
            </button>
          )}
        </div>
      )}
      
      {/* Competition density indicator */}
      {!isLoading && competitors.length > 0 && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <div className="flex items-center justify-between text-xs">
            <span className="text-slate-500">Competition Level</span>
            <span className={
              competitors.length >= 10 ? 'text-destructive-glow' :
              competitors.length >= 5 ? 'text-warning-glow' :
              'text-primary-glow'
            }>
              {competitors.length >= 10 ? 'High' : competitors.length >= 5 ? 'Medium' : 'Low'}
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/hooks/useAnalysis.js">
/**
 * useAnalysis Hook
 * Manages location analysis state and API calls with progressive loading
 */

import { useState, useCallback } from 'react';
import { analyzeLocation, getIsochrone, getDigipin } from '../services/api';

/**
 * Helper to normalize landmarks from API response
 * API returns: { list: [...], by_category: {...}, total: N }
 * We need: [{ name, category, lat, lng }, ...]
 */
function normalizeAllLandmarks(landmarksData) {
  if (!landmarksData) return [];
  
  // If it's already an array, return it
  if (Array.isArray(landmarksData)) return landmarksData;
  
  // Check for 'list' property first (our API structure)
  if (Array.isArray(landmarksData.list)) {
    return landmarksData.list;
  }
  
  // If it has by_category with arrays, flatten all categories into one array
  if (landmarksData.by_category && typeof landmarksData.by_category === 'object') {
    const allLandmarks = [];
    Object.entries(landmarksData.by_category).forEach(([category, items]) => {
      if (Array.isArray(items)) {
        items.forEach(item => {
          allLandmarks.push({
            ...item,
            category: category,
          });
        });
      }
    });
    if (allLandmarks.length > 0) return allLandmarks;
  }
  
  return [];
}

export default function useAnalysis() {
  const [analysis, setAnalysis] = useState(null);
  const [isochrone, setIsochrone] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Progressive loading status
  const [loadingStatus, setLoadingStatus] = useState({
    step: '',
    message: '',
    progress: 0,
    details: []
  });

  const updateStatus = (step, message, progress, detail = null) => {
    setLoadingStatus(prev => ({
      step,
      message,
      progress,
      details: detail ? [...prev.details, detail] : prev.details
    }));
  };

  const analyze = useCallback(async (location, businessType, filters) => {
    if (!location || !businessType) {
      setError('Location and business type are required');
      return;
    }

    // Validate that we have coordinates
    if (location.lat == null || location.lng == null) {
      setError('Location coordinates are missing. Please select a different location.');
      return;
    }

    setIsLoading(true);
    setError(null);
    setLoadingStatus({ step: 'init', message: 'Starting analysis...', progress: 0, details: [] });

    try {
      // Determine isochrone radius based on whether it's a major area
      const isMajorArea = location.is_major || false;
      const isochroneRadius = isMajorArea ? 2.5 : 1.5;
      
      // Step 1: Initialize
      updateStatus('location', ' Setting up location...', 10);
      await new Promise(r => setTimeout(r, 200)); // Brief delay for UI feedback

      // Step 2: Fetch isochrone (area boundary)
      updateStatus('boundary', ' Drawing area boundary...', 20);
      let isochroneData = null;
      try {
        isochroneData = await getIsochrone(location.lat, location.lng, isochroneRadius);
        updateStatus('boundary', ' Area boundary ready', 25, ' Area boundary loaded');
      } catch (err) {
        console.warn('Isochrone fetch failed:', err);
        updateStatus('boundary', ' Using circular boundary', 25, ' Using default circular area');
      }

      // Step 3: Run main analysis (competitors + landmarks)
      updateStatus('analysis', ' Searching for competitors...', 30);
      
      const analysisData = await analyzeLocation(
        location.lat, 
        location.lng, 
        businessType, 
        filters, 
        isMajorArea
      );

      // Extract counts for status
      const competitorCount = analysisData.competitors?.count || 0;
      const landmarkCount = analysisData.landmarks?.total || 0;
      
      updateStatus('competitors', ` Found ${competitorCount} competitors`, 60, 
        ` ${competitorCount} ${businessType}s found in area`);
      
      await new Promise(r => setTimeout(r, 300));
      
      updateStatus('landmarks', ` Found ${landmarkCount} landmarks`, 75,
        ` ${landmarkCount} landmarks identified`);

      // Step 4: Get DIGIPIN (optional)
      updateStatus('digipin', ' Getting location code...', 85);
      let digipin = null;
      try {
        const digipinData = await getDigipin(location.lat, location.lng);
        digipin = digipinData?.digipin;
        if (digipin) {
          updateStatus('digipin', ' DIGIPIN retrieved', 90, ` DIGIPIN: ${digipin}`);
        }
      } catch {
        // DIGIPIN is optional, ignore errors
      }

      // Step 5: Find recommended spots
      const spotsCount = analysisData.recommended_spots?.length || 0;
      updateStatus('spots', ` Found ${spotsCount} optimal locations...`, 95);
      await new Promise(r => setTimeout(r, 200));

      // Log raw response for debugging
      console.log(' Raw API Response:', JSON.stringify(analysisData, null, 2));
      
      // Normalize the API response to match frontend expectations
      const normalizedAnalysis = {
        // Recommended spots (new feature)
        recommended_spots: analysisData.recommended_spots || [],
        // Extract competitors from nested structure
        competitors: {
          count: analysisData.competitors?.count || 0,
          nearby: Array.isArray(analysisData.competitors?.nearby) 
            ? analysisData.competitors.nearby 
            : []
        },
        // Extract landmarks
        landmarks: {
          total: analysisData.landmarks?.total || 0,
          list: normalizeAllLandmarks(analysisData.landmarks),
          by_category: analysisData.landmarks?.by_category || {}
        },
        // Additional data
        footfall_proxy: analysisData.footfall_proxy || 'medium',
        location: location,
        digipin: digipin || analysisData.location?.digipin || '',
        address: analysisData.location?.address || {},
        business_type: analysisData.business_type || businessType,
      };
      
      // Log normalized data for debugging
      console.log(' Normalized Analysis:', {
        recommended_spots: normalizedAnalysis.recommended_spots,
        competitors: normalizedAnalysis.competitors,
        landmarks: normalizedAnalysis.landmarks
      });

      // Complete!
      updateStatus('complete', ' Analysis complete!', 100, 
        ` Found ${spotsCount} recommended locations`);

      setAnalysis(normalizedAnalysis);
      setIsochrone(isochroneData);
    } catch (err) {
      console.error('Analysis error:', err);
      setError(err.message || 'Failed to analyze location');
      setLoadingStatus(prev => ({
        ...prev,
        step: 'error',
        message: ` ${err.message || 'Analysis failed'}`,
        progress: 0
      }));
      setAnalysis(null);
      setIsochrone(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const clearAnalysis = useCallback(() => {
    setAnalysis(null);
    setIsochrone(null);
    setError(null);
    setLoadingStatus({ step: '', message: '', progress: 0, details: [] });
  }, []);

  return {
    analysis,
    isochrone,
    isLoading,
    error,
    loadingStatus,
    analyze,
    clearAnalysis,
  };
}
</file>

</files>
</file>

<file path="TASKS.md">
#  Hotspot IQ  Implementation Roadmap

> **Track your progress!** Check off tasks as you complete them.
> 
> **Estimated Total Time:** 24-32 hours (Hackathon Sprint)

---

##  Phase 0: Project Setup & Foundation

### Environment Setup
- [x] Create project root directory structure
  ```
  hotspot-iq/
   backend/
   frontend/
   docs/
   README.md
  ```
- [x] Initialize Git repository with `.gitignore`
- [x] Create `backend/.gitignore` (include `venv/`, `__pycache__/`, `.env`)
- [x] Create `frontend/.gitignore` (include `node_modules/`, `.env`, `dist/`)

### Backend Scaffolding
- [x] Create Python virtual environment (`python -m venv venv`)
- [x] Create `backend/requirements.txt`:
  ```
  flask==3.0.0
  flask-cors==4.0.0
  python-dotenv==1.0.0
  requests==2.31.0
  pandas==2.1.0
  openai==1.6.0
  duckduckgo-search==4.1.0
  ```
- [x] Install dependencies (`pip install -r requirements.txt`)
- [x] Create `backend/.env.example` with placeholder keys
- [x] Create `backend/.env` with actual API keys (DO NOT COMMIT!)
- [x] Create basic `backend/app.py` with Flask boilerplate
- [x] Add CORS configuration for frontend origin
- [ ] Test server starts on `http://localhost:5000`

### Frontend Scaffolding
- [x] Initialize Vite React project (`npm create vite@latest frontend -- --template react`)
- [x] Install core dependencies:
  ```bash
  npm install react-leaflet leaflet recharts axios tailwindcss postcss autoprefixer
  ```
- [x] Initialize Tailwind CSS (`npx tailwindcss init -p`)
- [x] Configure `tailwind.config.js` with content paths
- [x] Add Tailwind directives to `src/index.css`
- [x] Create `frontend/.env.example`
- [x] Create `frontend/.env` with `VITE_API_BASE_URL=http://localhost:5000/api`
- [ ] Test frontend starts on `http://localhost:5173`

### Project Structure
- [x] Create backend folder structure:
  ```
  backend/
   app.py
   config.py
   requirements.txt
   .env
   services/
      __init__.py
      latlong_service.py
      openai_service.py
      search_service.py
   routes/
      __init__.py
      location_routes.py
      analysis_routes.py
      chat_routes.py
   utils/
       __init__.py
       score_calculator.py
  ```
- [x] Create frontend folder structure:
  ```
  frontend/src/
   components/
      Map/
      Search/
      Dashboard/
      Chat/
      common/
   hooks/
   services/
   utils/
   pages/
  ```

---

##  Phase 1: Backend  Core Services

### Configuration Module
- [x] Create `backend/config.py` with environment variable loading
- [x] Implement API key validation on startup
- [x] Add configuration for API base URLs

### LatLong Service Wrapper (`services/latlong_service.py`)
- [x] Create base HTTP client with API key header
- [x] Implement `autocomplete(query: str)` method
  - [x] Call LatLong Autocomplete API
  - [x] Parse and return formatted suggestions
  - [x] Handle API errors gracefully
- [x] Implement `reverse_geocode(lat: float, lng: float)` method
  - [x] Get address details from coordinates
  - [x] Extract landmarks and POI info
- [x] Implement `get_poi(lat: float, lng: float, category: str, radius: int)` method
  - [x] Fetch POIs by category (cafe, atm, gym, etc.)
  - [x] Return count and list of nearby POIs
- [x] Implement `get_isochrone(lat: float, lng: float, mode: str, time: int)` method
  - [x] Call Isochrone API
  - [x] Return GeoJSON polygon
- [x] Implement `get_digipin(lat: float, lng: float)` method
  - [x] Fetch Digipin code
  - [x] Return formatted address
- [x] Implement `distance_matrix(origins: list, destinations: list)` method
  - [x] Calculate drive times between points
  - [x] Parse duration and distance from response
- [ ] Add request caching (optional, for demo performance)
- [ ] Write unit tests for each method

### Score Calculator (`utils/score_calculator.py`)
- [x] Define score constants and weights:
  ```python
  LANDMARK_WEIGHTS = {
      'metro_station': 15,
      'bus_stop': 5,
      'school': 10,
      'college': 12,
      'hospital': 8,
      'mall': 15,
      'office_complex': 12
  }
  ```
- [x] Implement `calculate_footfall_proxy(landmarks: dict, poi_data: dict)` function
- [x] Implement `calculate_landmark_value(landmarks: dict)` function
- [x] Implement `calculate_competitor_density(competitors: list, radius: float)` function
- [x] Implement `calculate_opportunity_score(footfall, landmark_value, competitor_density)` function
  - [x] Formula: `(footfall * landmark_value) / (competitor_density + 1)`
  - [x] Normalize to 0-100 scale
- [x] Implement `get_score_interpretation(score: int)` function
  - [x] Return category (Prime/Moderate/High Risk)
  - [x] Return recommendation text
- [ ] Write unit tests with sample data

### Location Routes (`routes/location_routes.py`)
- [x] Create Flask Blueprint for location routes
- [x] Implement `GET /api/autocomplete`
  - [x] Accept `query` parameter
  - [x] Call LatLong service
  - [x] Return JSON suggestions
- [x] Implement `GET /api/reverse-geocode`
  - [x] Accept `lat`, `lng` parameters
  - [x] Return address and landmark info
- [x] Implement `GET /api/digipin`
  - [x] Accept `lat`, `lng` parameters
  - [x] Return Digipin code

### Analysis Routes (`routes/analysis_routes.py`)
- [x] Create Flask Blueprint for analysis routes
- [x] Implement `POST /api/analyze`
  - [x] Accept JSON body: `{ lat, lng, business_type, filters }`
  - [x] Orchestrate multiple LatLong API calls:
    - [x] Get nearby competitors (same business type)
    - [x] Get nearby landmarks
    - [x] Get reverse geocode data
  - [x] Calculate opportunity score
  - [x] Return comprehensive analysis response
- [x] Implement `POST /api/isochrone`
  - [x] Accept JSON body: `{ lat, lng, mode, time_minutes }`
  - [x] Return GeoJSON polygon
- [x] Add input validation with error messages

### Integration & Testing
- [x] Register all blueprints in `app.py`
- [ ] Test all endpoints with Postman/curl
- [x] Handle and log API errors
- [x] Add request logging middleware

---

##  Phase 1: Frontend  Core UI

### API Service Layer (`services/api.js`)
- [x] Create Axios instance with base URL from env
- [x] Implement `searchLocations(query)` function
- [x] Implement `analyzeLocation(lat, lng, businessType, filters)` function
- [x] Implement `getIsochrone(lat, lng, mode, time)` function
- [x] Implement `getDigipin(lat, lng)` function
- [x] Implement `chat(message, context)` function
- [x] Add error handling wrapper

### Layout & Navigation
- [x] Create `components/Layout/Header.jsx` with logo and tagline
- [ ] Create `components/Layout/Sidebar.jsx` for filters
- [x] Create main `App.jsx` layout structure
- [x] Add responsive grid (sidebar + map + dashboard)

### Search Component (`components/Search/`)
- [x] Create `SearchBar.jsx` with autocomplete input
- [x] Implement debounced API calls (300ms delay)
- [x] Create `SearchSuggestions.jsx` dropdown list
- [x] Handle suggestion selection  update map
- [x] Add loading spinner during search
- [x] Style with Tailwind (rounded, shadow, etc.)

### Step 1: Business Type Selector (FIRST in user flow)
- [x] Create `components/Filters/BusinessTypeSelector.jsx`
- [x] Add dropdown with business types (with icons):
  - [x]  Cafe / Coffee Shop
  - [x]  Restaurant / Fast Food
  - [x]  Retail Store
  - [x]  Gym / Fitness Center
  - [x]  Pharmacy / Medical Store
  - [x]  Salon / Spa
  - [x]  Electronics Store
  - [x]  Clothing / Fashion
  - [x]  Bookstore / Stationery
  - [x]  Other (custom input field appears)
- [x] Store selected business type in global state
- [x] Map business type to competitor POI categories:
  ```javascript
  const COMPETITOR_MAPPING = {
    'cafe': ['cafe', 'coffee_shop', 'bakery'],
    'restaurant': ['restaurant', 'fast_food', 'food_court'],
    'gym': ['gym', 'fitness_center', 'sports_club'],
    // ... etc
  };
  ```
- [x] Disable "Analyze" button until business type is selected
- [x] Show validation message if user tries to skip

### Step 2: Proximity Preference Filters (SECOND in user flow)
- [x] Create `components/Filters/ProximityFilters.jsx`
- [x] Create `components/Filters/FilterChip.jsx` (individual chip component)
- [x] Add checkbox filter options with icons:
  - [x]  Near Metro Station
  - [x]  Near Bus Stop
  - [x]  Near School
  - [x]  Near College/University
  - [x]  Near Hospital
  - [x]  Near Mall/Shopping Complex
  - [x]  Near Office/IT Park
  - [x]  Near Residential Area
  - [x]  Near Temple/Religious Place
  - [x]  Near Park/Recreation
  - [x]  Near ATM/Bank
  - [x]  Near Bar/Pub
- [x] Implement multi-select toggle functionality
- [x] Visual feedback: selected chips glow green, unselected are muted
- [x] Store selected filters array in global state
- [x] Add "Clear All" and "Select Popular" quick actions
- [x] Map filter names to POI categories for API calls:
  ```javascript
  const FILTER_POI_MAPPING = {
    'near_metro': 'metro_station',
    'near_school': 'school',
    'near_college': 'college',
    // ... etc
  };
  ```

### Map Component (`components/Map/`)
- [x] Create `MapContainer.jsx` with React-Leaflet
- [x] Set default center to Bangalore (12.9716, 77.5946)
- [x] Add OpenStreetMap tile layer
- [x] Create `LocationMarker.jsx` for selected location
- [x] Create `CompetitorMarkers.jsx` for nearby competitors
- [x] Create `LandmarkMarkers.jsx` with different icons
- [ ] Create `HeatmapLayer.jsx` for opportunity visualization
- [x] Implement click-to-select location
- [x] Add zoom controls and fullscreen button

### Dashboard Component (`components/Dashboard/`)
- [x] Create `ScoreCard.jsx`  large opportunity score display
  - [x] Color coded: green/yellow/red
  - [x] Score interpretation text
- [x] Create `CompetitorCard.jsx`  competitor count & list
- [x] Create `LandmarksCard.jsx`  nearby landmarks breakdown
- [x] Create `MetricsGrid.jsx`  footfall, density stats
- [x] Style cards with shadows and hover effects

### Charts (`components/Dashboard/Charts/`)
- [x] Create `CompetitorChart.jsx`  bar chart of competitor types
- [x] Create `LandmarkRadar.jsx`  radar chart of landmark categories
- [x] Create `ScoreGauge.jsx`  circular gauge for score
- [x] Use Recharts with consistent color theme

### State Management
- [x] Create `hooks/useLocation.js`  manage selected location
- [x] Create `hooks/useAnalysis.js`  manage analysis data
- [x] Create `hooks/useFilters.js`  manage filter selections
- [x] Wire up state flow: Search  Map  Analysis  Dashboard

### Integration Testing
- [ ] Test search  select  analyze flow
- [ ] Verify map updates correctly
- [ ] Verify dashboard shows correct data
- [ ] Test error states (API down, no results)
- [ ] Test loading states

---

##  Phase 2: Advanced Features

### Isochrone Visualization
- [ ] Create `components/Map/IsochroneLayer.jsx`
- [ ] Add mode selector (walk/bike/car)
- [ ] Add time selector (5/10/15/30 mins)
- [ ] Fetch isochrone on selection change
- [ ] Render GeoJSON polygon on map
- [ ] Style polygon with semi-transparent fill
- [ ] Add legend for isochrone

### OpenAI Service (`services/openai_service.py`)
- [ ] Create OpenAI client initialization
- [ ] Design system prompt for location advisor:
  ```
  You are Hotspot IQ, an expert location intelligence advisor for 
  businesses in India. Analyze the provided data about a location 
  and give practical, actionable advice.
  ```
- [ ] Implement `generate_advice(user_question, location_data)` function
- [ ] Format location data as context for GPT
- [ ] Handle rate limits and errors
- [ ] Add response streaming (optional)

### Chat Routes (`routes/chat_routes.py`)
- [ ] Create Flask Blueprint for chat
- [ ] Implement `POST /api/chat`
  - [ ] Accept JSON: `{ message, context: { lat, lng } }`
  - [ ] Fetch location data from LatLong
  - [ ] Build prompt with context
  - [ ] Call OpenAI service
  - [ ] Return AI response

### Chat Widget (`components/Chat/`)
- [ ] Create `ChatWidget.jsx`  floating button + panel
- [ ] Create `ChatMessage.jsx`  message bubble component
- [ ] Create `ChatInput.jsx`  input with send button
- [ ] Implement message history state
- [ ] Add typing indicator during AI response
- [ ] Style as floating widget (bottom-right)
- [ ] Add minimize/maximize toggle
- [ ] Add suggested questions:
  - [ ] "Is this good for a [business_type]?"
  - [ ] "What's the competition like?"
  - [ ] "What landmarks are nearby?"

### Digipin Integration
- [ ] Add Digipin fetch to analysis flow
- [ ] Create `components/Dashboard/DigipinCard.jsx`
- [ ] Display Digipin code prominently
- [ ] Add "Copy to Clipboard" button
- [ ] Add "Share Location" button (generate shareable link)

### UI Polish
- [ ] Add loading skeletons for all cards
- [ ] Add error boundaries
- [ ] Add empty states with helpful messages
- [ ] Implement toast notifications
- [ ] Add keyboard shortcuts (Escape to close, Enter to search)

---

##  Phase 3: Moonshot Features

### DuckDuckGo Search Service (`services/search_service.py`)
- [ ] Install and configure `duckduckgo-search`
- [ ] Implement `search_infrastructure_news(location: str)` function
- [ ] Search queries:
  - [ ] "Infrastructure projects in {location}"
  - [ ] "New metro {location}"
  - [ ] "Real estate development {location}"
  - [ ] "Commercial construction {location}"
- [ ] Parse and deduplicate results
- [ ] Extract relevant snippets

### Growth Radar Feature
- [ ] Create `routes/growth_routes.py`
- [ ] Implement `POST /api/growth-radar`
  - [ ] Accept location name
  - [ ] Call search service
  - [ ] Analyze sentiment (positive/negative impact)
  - [ ] Return structured developments list
- [ ] Create `components/Dashboard/GrowthRadar.jsx`
  - [ ] List upcoming developments
  - [ ] Show impact indicator (bullish/bearish)
  - [ ] Link to source articles

### Supply Chain Validator
- [ ] Implement `POST /api/supply-chain` endpoint
  - [ ] Accept store and warehouse coordinates
  - [ ] Call LatLong Distance Matrix API
  - [ ] Calculate drive time
  - [ ] Apply logic:
    - [ ] < 30 mins:  Excellent
    - [ ] 30-45 mins:  Acceptable
    - [ ] > 45 mins:  High Logistics Cost
  - [ ] Return feasibility assessment
- [ ] Create `components/SupplyChain/WarehouseInput.jsx`
  - [ ] Search for warehouse location
  - [ ] Display on map with route line
- [ ] Create `components/SupplyChain/FeasibilityCard.jsx`
  - [ ] Show drive time and distance
  - [ ] Color-coded status
  - [ ] Recommendation text

### Advanced Map Features
- [ ] Add draw polygon tool for custom areas
- [ ] Add multiple location comparison
- [ ] Add "Find best location" auto-suggestion
- [ ] Add street view integration (if available)

---

##  Phase 4: Demo & Polish (Hackathon Prep)

### Demo Data & Fallbacks
- [ ] Create mock data for demo locations (Indiranagar, Koramangala, HSR)
- [ ] Add fallback data if APIs fail
- [ ] Pre-cache common searches

### Performance Optimization
- [ ] Add API response caching (Redis or in-memory)
- [ ] Implement request debouncing
- [ ] Lazy load map components
- [ ] Optimize bundle size

### UI/UX Polish
- [ ] Add onboarding tour for first-time users
- [ ] Add tooltips explaining each metric
- [ ] Ensure mobile responsiveness
- [ ] Add dark mode toggle (optional)
- [ ] Add print/export report feature

### Documentation & Presentation
- [ ] Record demo video (2-3 minutes)
- [ ] Create presentation slides
- [ ] Prepare live demo script
- [ ] Document known limitations
- [ ] Prepare FAQ for judges

### Final Testing
- [ ] End-to-end testing of all flows
- [ ] Test with real API keys
- [ ] Test error scenarios
- [ ] Test on multiple browsers
- [ ] Performance testing

---

##  Progress Tracker

| Phase | Tasks | Completed | Status |
|-------|-------|-----------|--------|
| Phase 0 | 18 | 16 |  Almost Done |
| Phase 1 Backend | 28 | 26 |  Almost Done |
| Phase 1 Frontend | 35 | 35 |  Complete |
| Phase 2 | 25 | 0 |  Not Started |
| Phase 3 | 18 | 0 |  Not Started |
| Phase 4 | 16 | 0 |  Not Started |
| **Total** | **140** | **77** | **55%** |

---

##  Quick Start Commands

```bash
# Backend
cd backend
python -m venv venv
.\venv\Scripts\activate  # Windows
pip install -r requirements.txt
python app.py

# Frontend
cd frontend
npm install
npm run dev
```

---

##  Troubleshooting

| Issue | Solution |
|-------|----------|
| CORS errors | Check Flask-CORS config, verify frontend URL |
| API key errors | Verify `.env` file exists and keys are valid |
| Map not loading | Check Leaflet CSS import in index.html |
| Blank dashboard | Check browser console for API errors |

---

**Good luck with the hackathon! **
</file>

<file path="backend/.env.example">
# Hotspot IQ Backend Environment Variables
# Copy this file to .env and fill in your actual API keys

FLASK_ENV=development
FLASK_DEBUG=True
FLASK_PORT=5000

# LatLong.ai API Key (https://latlong.ai)
LATLONG_API_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJUb2tlbklEIjoiMzNmMjY3MTgtMjRiOC00NTFlLWJlMGYtOGZmMzA1ZDI3ZDk5IiwiQ2xpZW50SUQiOiI2YTA3ZDNkMC01MTNkLTRjMTMtYjRjMi04NTdiY2YzNDJiNWIiLCJCdW5pdElEIjozMCwiQXBwTmFtZSI6InBlcyBoYWNrYXRob24gbWFwcy1yZWltYWdpbmVkIiwiQXBwSUQiOjE4Mzk1LCJUaW1lU3RhbXAiOiIyMDI1LTExLTI4IDE3OjEyOjUyIiwiZXhwIjoxNzY0NTIyNzcyfQ.q5AqBLmiB3KlPMt58O5N767uBJ6qNxGmt6X2aYWtrbI

# OpenAI API Key (https://platform.openai.com)
OPENAI_API_KEY=your_openai_api_key_here

# Frontend URL for CORS
FRONTEND_URL=http://localhost:5173
</file>

<file path="backend/app.py">
"""
Hotspot IQ - Flask Application
Main entry point for the backend API server.
"""

from flask import Flask, jsonify
from flask_cors import CORS
from config import Config
from routes import location_bp, analysis_bp, chat_bp


def create_app():
    """Create and configure the Flask application."""
    
    app = Flask(__name__)
    
    # Configure CORS - allow multiple Vite dev server ports
    CORS(app, origins=[
        Config.FRONTEND_URL, 
        "http://localhost:5173", 
        "http://localhost:5174",
        "http://localhost:5175",
        "http://localhost:5176",
        "http://127.0.0.1:5173",
        "http://127.0.0.1:5174",
        "http://127.0.0.1:5175",
        "http://127.0.0.1:5176"
    ])
    
    # Register blueprints
    app.register_blueprint(location_bp, url_prefix='/api')
    app.register_blueprint(analysis_bp, url_prefix='/api')
    app.register_blueprint(chat_bp, url_prefix='/api')
    
    # Health check endpoint
    @app.route('/api/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'service': 'Hotspot IQ API',
            'version': '1.0.0'
        })
    
    # Root endpoint
    @app.route('/', methods=['GET'])
    def root():
        return jsonify({
            'name': 'Hotspot IQ API',
            'description': 'Hyper-Local Location Intelligence for Smarter Business Expansion',
            'version': '1.0.0',
            'endpoints': {
                'health': '/api/health',
                'autocomplete': '/api/autocomplete?query={search_term}',
                'analyze': 'POST /api/analyze',
                'isochrone': 'POST /api/isochrone',
                'digipin': '/api/digipin?lat={lat}&lng={lng}',
                'chat': 'POST /api/chat',
                'supply_chain': 'POST /api/supply-chain'
            }
        })
    
    # Error handlers
    @app.errorhandler(404)
    def not_found(e):
        return jsonify({'error': 'Endpoint not found'}), 404
    
    @app.errorhandler(500)
    def server_error(e):
        return jsonify({'error': 'Internal server error'}), 500
    
    return app


# Create app instance
app = create_app()


if __name__ == '__main__':
    print("\n Hotspot IQ Backend Server")
    print("=" * 40)
    
    # Validate configuration
    Config.validate()
    
    print(f" Starting server on http://localhost:{Config.FLASK_PORT}")
    print(f" CORS enabled for: {Config.FRONTEND_URL}")
    print("=" * 40 + "\n")
    
    app.run(
        host='0.0.0.0',
        port=Config.FLASK_PORT,
        debug=Config.FLASK_DEBUG
    )
</file>

<file path="backend/config.py">
"""
Hotspot IQ - Configuration Module
Loads environment variables and validates API keys on startup.
"""

import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()


class Config:
    """Application configuration class."""
    
    # Flask Settings
    FLASK_ENV = os.getenv('FLASK_ENV', 'development')
    FLASK_DEBUG = os.getenv('FLASK_DEBUG', 'True').lower() == 'true'
    FLASK_PORT = int(os.getenv('FLASK_PORT', 5000))
    
    # API Keys
    LATLONG_API_KEY = os.getenv('LATLONG_API_KEY', '')
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY', '')
    HUGGINGFACE_API_KEY = os.getenv('HUGGINGFACE_API_KEY', '')
    HUGGINGFACE_MODEL = os.getenv('HUGGINGFACE_MODEL', 'meta-llama/Meta-Llama-3-8B-Instruct')
    
    # LatLong API Configurationgs
    FRONTEND_URL = os.getenv('FRONTEND_URL', 'http://localhost:5173')
    
    # LatLong.ai API Base URL (API Hub)
    LATLONG_BASE_URL = 'https://apihub.latlong.ai'
    
    # Default location (Bangalore)
    DEFAULT_LAT = 12.9716
    DEFAULT_LNG = 77.5946
    DEFAULT_RADIUS = 1000  # meters
    
    @classmethod
    def validate(cls):
        """Validate that required API keys are present."""
        errors = []
        
        if not cls.LATLONG_API_KEY or cls.LATLONG_API_KEY == 'your_latlong_api_key_here':
            errors.append('LATLONG_API_KEY is not configured')
        
        if not cls.OPENAI_API_KEY or cls.OPENAI_API_KEY == 'your_openai_api_key_here':
            errors.append('OPENAI_API_KEY is not configured (optional for Phase 1)')
        
        if errors:
            print("  Configuration Warnings:")
            for error in errors:
                print(f"   - {error}")
            print("   Some features may not work without valid API keys.\n")
        else:
            print(" All API keys configured successfully!\n")
        
        return len(errors) == 0


# Business Type to Competitor POI Category Mapping
COMPETITOR_MAPPING = {
    'cafe': ['cafe', 'coffee_shop', 'bakery', 'tea_house'],
    'restaurant': ['restaurant', 'fast_food', 'food_court', 'dhaba'],
    'retail': ['supermarket', 'convenience_store', 'grocery', 'retail'],
    'gym': ['gym', 'fitness_center', 'yoga_studio', 'sports_club'],
    'pharmacy': ['pharmacy', 'medical_store', 'clinic'],
    'salon': ['salon', 'spa', 'beauty_parlor', 'barbershop'],
    'electronics': ['electronics_store', 'mobile_shop', 'computer_store'],
    'clothing': ['clothing_store', 'boutique', 'fashion_store'],
    'bookstore': ['bookstore', 'stationery_shop', 'library'],
    'other': []
}

# Proximity Filter to POI Category Mapping
FILTER_POI_MAPPING = {
    'near_metro': 'metro_station',
    'near_bus': 'bus_stop',
    'near_school': 'school',
    'near_college': 'college',
    'near_hospital': 'hospital',
    'near_mall': 'mall',
    'near_office': 'office',
    'near_residential': 'residential',
    'near_temple': 'temple',
    'near_park': 'park',
    'near_atm': 'atm',
    'near_bar': 'bar'
}

# Landmark weights for score calculation
LANDMARK_WEIGHTS = {
    'metro_station': 15,
    'bus_stop': 5,
    'school': 10,
    'college': 12,
    'hospital': 8,
    'mall': 15,
    'office': 12,
    'residential': 8,
    'temple': 6,
    'park': 5,
    'atm': 4,
    'bar': 7
}
</file>

<file path="backend/routes/chat_routes.py">
"""
Hotspot IQ - Chat Routes
Handles AI-powered chat endpoints.
"""

from flask import Blueprint, request, jsonify
from services.latlong_service import latlong_service
from utils.score_calculator import analyze_location
from config import Config
from services.chat_agent import answer_question

chat_bp = Blueprint('chat', __name__)



def _retriever(lat_r, lng_r, business_type_r=None):
    """Retriever to fetch live analysis if the agent needs it."""
    bt = business_type_r or 'other'
    competitors = latlong_service.get_competitors(lat_r, lng_r, bt)
    filters = ['near_metro', 'near_bus', 'near_school', 'near_college', 
               'near_hospital', 'near_mall', 'near_office']
    landmarks = latlong_service.get_landmarks_by_filters(lat_r, lng_r, filters)
    address_info = latlong_service.reverse_geocode(lat_r, lng_r)
    analysis_result = analyze_location(landmarks, competitors, bt)
    return {
        'lat': lat_r,
        'lng': lng_r,
        'address': address_info,
        'business_type': bt,
        'opportunity_score': analysis_result.get('opportunity_score'),
        'interpretation': analysis_result.get('interpretation', {}),
        'footfall_proxy': 'high' if analysis_result.get('breakdown', {}).get('footfall_proxy', 0) > 60 else 'medium' if analysis_result.get('breakdown', {}).get('footfall_proxy', 0) > 30 else 'low',
        'competitors': analysis_result.get('competitors', {}),
        'landmarks': {'by_category': analysis_result.get('landmarks_summary', {})}
    }


def _generate_template_response(message: str, analysis_data: dict) -> str:
    """Generate a template response when AI is not available."""
    if not analysis_data:
        return "Please select a location on the map first so I can analyze it for you."

    score = analysis_data.get('opportunity_score', 0)
    category = analysis_data.get('interpretation', {}).get('category', 'Unknown')
    competitors = analysis_data.get('competitors', {}).get('count', 0)
    footfall = analysis_data.get('footfall_proxy', 'unknown')
    business_type = analysis_data.get('business_type', 'business')

    message_lower = message.lower()

    if 'good' in message_lower or 'suitable' in message_lower:
        if score >= 70:
            return f"Based on the data, this location shows strong potential for a {business_type}. Opportunity Score: {score}/100. There are {competitors} competitors nearby and footfall appears to be {footfall}."
        elif score >= 40:
            return f"This location has moderate potential for a {business_type} (score {score}/100). Competition: {competitors}. Footfall: {footfall}."
        else:
            return f"This location shows challenges for a {business_type} (score {score}/100). Competition: {competitors}. Footfall: {footfall}. Consider other locations."

    if 'competition' in message_lower or 'competitor' in message_lower:
        return f"There are {competitors} competitors (similar {business_type}s) nearby. {'This is a competitive area - differentiation will be key.' if competitors > 5 else 'Competition is manageable.'}"

    if 'landmark' in message_lower or 'nearby' in message_lower:
        landmarks = analysis_data.get('landmarks', {}).get('by_category', {})
        if landmarks:
            landmark_text = ', '.join([f"{count} {cat.replace('_', ' ')}s" for cat, count in landmarks.items() if count > 0])
            return f"Nearby landmarks include: {landmark_text}. These contribute to footfall and accessibility."
        return "I don't have detailed landmark data for this location yet."

    return f"This location has an Opportunity Score of {score}/100 ({category}). There are {competitors} competitors nearby and {footfall} footfall. What would you like me to analyze further?"


@chat_bp.route('/chat', methods=['POST'])
def chat():
    """POST /api/chat - AI-powered location advice chat."""
    data = request.get_json()
    if not data:
        return jsonify({'error': 'Request body is required'}), 400

    message = data.get('message', '')
    context = data.get('context', {}) or {}
    if not message:
        return jsonify({'error': 'message is required'}), 400

    lat = context.get('lat')
    lng = context.get('lng')
    business_type = context.get('business_type', 'other')
    analysis_data = context.get('analysis_data')



    # If OpenAI not configured, return template response (fill analysis if missing)
    if not Config.OPENAI_API_KEY or Config.OPENAI_API_KEY == 'your_openai_api_key_here':
        if lat and lng and not analysis_data:
            analysis_data = _retriever(lat, lng, business_type)
        response_text = _generate_template_response(message, analysis_data)
        return jsonify({'response': response_text, 'data_sources': ['poi', 'landmarks', 'competitors'], 'ai_powered': False})

    # Otherwise delegate to the chat agent (RAG + OpenAI)
    try:
        agent_ctx = {'lat': lat, 'lng': lng, 'business_type': business_type, 'analysis_data': analysis_data, 'retriever': _retriever}
        result = answer_question(message, agent_ctx)
        return jsonify(result)
    except Exception as e:
        print(f"Chat agent error: {e}")
        if lat and lng and not analysis_data:
            analysis_data = _retriever(lat, lng, business_type)
        response_text = _generate_template_response(message, analysis_data)
        return jsonify({'response': response_text, 'data_sources': ['poi', 'landmarks', 'competitors'], 'ai_powered': False, 'error': str(e)})
"""
Hotspot IQ - Chat Routes
Handles AI-powered chat endpoints.
"""

from flask import Blueprint, request, jsonify
from services.latlong_service import latlong_service
from utils.score_calculator import analyze_location
from config import Config

chat_bp = Blueprint('chat', __name__)


def generate_context_prompt(location_data: dict, user_question: str) -> str:
    """Generate a context-rich prompt for the AI."""
    
    context = f"""You are Hotspot IQ, an expert location intelligence advisor for businesses in India.
    
LOCATION DATA:
- Coordinates: {location_data.get('lat')}, {location_data.get('lng')}
- Address: {location_data.get('address', {}).get('formatted_address', 'N/A')}
- Business Type: {location_data.get('business_type', 'Not specified')}

ANALYSIS RESULTS:
- Opportunity Score: {location_data.get('opportunity_score', 'N/A')}/100
- Score Category: {location_data.get('interpretation', {}).get('category', 'N/A')}
- Footfall Level: {location_data.get('footfall_proxy', 'N/A')}
- Competitor Count: {location_data.get('competitors', {}).get('count', 0)} nearby

RECOMMENDED SPOTS (Top 5):
{_format_recommended_spots(location_data.get('recommended_spots', []))}

LANDMARKS NEARBY:
{_format_landmarks(location_data.get('landmarks', {}).get('by_category', {}))}

USER QUESTION: {user_question}

Please provide a helpful, actionable response based on this data. Be specific and use the numbers provided.
If the user asks about specific spots, refer to the "RECOMMENDED SPOTS" section.
Keep your response concise (2-3 paragraphs max) and practical for a business owner."""
    
    return context


def _format_recommended_spots(spots: list) -> str:
    """Format recommended spots list into readable string."""
    if not spots:
        return "No specific recommended spots identified."
    
    lines = []
    for i, spot in enumerate(spots[:5], 1):
        lines.append(f"Spot #{i}: Score {spot.get('total_score', 'N/A')}/100 - {spot.get('rating_label', 'N/A')} (Lat: {spot.get('lat')}, Lng: {spot.get('lng')})")
    
    return '\n'.join(lines)


def _format_landmarks(landmarks: dict) -> str:
    """Format landmarks dict into readable string."""
    if not landmarks:
        return "No landmark data available"
    
    lines = []
    for category, count in landmarks.items():
        readable_name = category.replace('_', ' ').title()
        lines.append(f"- {readable_name}: {count}")
    
    return '\n'.join(lines) if lines else "No landmarks detected"


@chat_bp.route('/chat', methods=['POST'])
def chat():
    """
    POST /api/chat
    
    AI-powered location advice chat.
    
    Request body:
    {
        "message": "Is this location good for a gym?",
        "context": {
            "lat": 12.9716,
            "lng": 77.5946,
            "business_type": "gym",
            "analysis_data": {...}  // Optional, pre-fetched analysis
        }
    }
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    message = data.get('message', '')
    context = data.get('context', {})
    
    if not message:
        return jsonify({'error': 'message is required'}), 400
    
    lat = context.get('lat')
    lng = context.get('lng')
    business_type = context.get('business_type', 'other')
    
    # If we have coordinates but no analysis data, fetch it
    analysis_data = context.get('analysis_data')
    
    if lat and lng and not analysis_data:
        # Fetch fresh analysis data
        competitors = latlong_service.get_competitors(lat, lng, business_type)
        filters = ['near_metro', 'near_bus', 'near_school', 'near_college', 
                   'near_hospital', 'near_mall', 'near_office']
        landmarks = latlong_service.get_landmarks_by_filters(lat, lng, filters)
        address_info = latlong_service.reverse_geocode(lat, lng)
        
        analysis_result = analyze_location(landmarks, competitors, business_type)
        
        analysis_data = {
            'lat': lat,
            'lng': lng,
            'address': address_info,
            'business_type': business_type,
            'opportunity_score': analysis_result['opportunity_score'],
            'interpretation': analysis_result['interpretation'],
            'footfall_proxy': 'high' if analysis_result['breakdown']['footfall_proxy'] > 60 else 'medium' if analysis_result['breakdown']['footfall_proxy'] > 30 else 'low',
            'competitors': analysis_result['competitors'],
            'landmarks': {
                'by_category': analysis_result['landmarks_summary']
            }
        }
    
    # Check if Hugging Face is configured
    if not Config.HUGGINGFACE_API_KEY:
        # Return a template response without AI
        response_text = _generate_template_response(message, analysis_data)
        return jsonify({
            'response': response_text,
            'data_sources': ['poi', 'landmarks', 'competitors'],
            'ai_powered': False
        })
    
    # Generate AI response using Hugging Face
    try:
        from huggingface_hub import InferenceClient
        client = InferenceClient(
            model=Config.HUGGINGFACE_MODEL,
            token=Config.HUGGINGFACE_API_KEY
        )
        
        prompt = generate_context_prompt(analysis_data or {}, message)
        
        # Format prompt for instruction-tuned models (e.g., Mistral)
        formatted_prompt = f"<s>[INST] {prompt} [/INST]"
        
        response_text = ""
        for token in client.text_generation(formatted_prompt, max_new_tokens=500, stream=True):
            response_text += token
        
        return jsonify({
            'response': response_text,
            'data_sources': ['poi', 'landmarks', 'competitors'],
            'ai_powered': True
        })
        
    except Exception as e:
        # OpenAI call failed; attempt to use the local chat agent (RAG) fallback.
        if lat and lng and not analysis_data:
            analysis_data = _retriever(lat, lng, business_type)

        try:
            agent_ctx = {'lat': lat, 'lng': lng, 'business_type': business_type, 'analysis_data': analysis_data, 'retriever': _retriever}
            result = answer_question(message, agent_ctx)
            return jsonify(result)
        except Exception as inner_e:
            print(f"Chat agent error: {inner_e}")
            response_text = _generate_template_response(message, analysis_data)
            return jsonify({
                'response': response_text,
                'data_sources': ['poi', 'landmarks', 'competitors'],
                'ai_powered': False,
                'error': str(inner_e)
            })
</file>

<file path="backend/services/competitor_service.py">
"""
Hotspot IQ - Competitor Service
Uses OpenStreetMap Overpass API via overpy to count competitors near a location.
"""

import overpy
from typing import Dict, List, Optional


# Map business categories to OpenStreetMap tags
CATEGORY_TAG_MAPPING: Dict[str, List[Dict[str, str]]] = {
    # Food & Beverage - expanded for better coverage
    'cafe': [
        {'amenity': 'cafe'},
        {'shop': 'coffee'},
        {'cuisine': 'coffee_shop'},
        {'amenity': 'fast_food'},  # Many cafes are tagged as fast_food
    ],
    'coffee': [{'amenity': 'cafe'}, {'shop': 'coffee'}],
    'restaurant': [
        {'amenity': 'restaurant'},
        {'amenity': 'fast_food'},
        {'amenity': 'food_court'},
    ],
    'fast_food': [{'amenity': 'fast_food'}],
    'bar': [{'amenity': 'bar'}, {'amenity': 'pub'}],
    'pub': [{'amenity': 'pub'}, {'amenity': 'bar'}],
    'bakery': [{'shop': 'bakery'}, {'shop': 'pastry'}],
    'ice_cream': [{'amenity': 'ice_cream'}, {'shop': 'ice_cream'}, {'shop': 'frozen_yogurt'}],
    
    # Health & Fitness
    'gym': [{'leisure': 'fitness_centre'}, {'amenity': 'gym'}],
    'pharmacy': [{'amenity': 'pharmacy'}],
    'hospital': [{'amenity': 'hospital'}],
    'clinic': [{'amenity': 'clinic'}],
    'dentist': [{'amenity': 'dentist'}],
    
    # Retail
    'supermarket': [{'shop': 'supermarket'}],
    'grocery': [{'shop': 'grocery'}, {'shop': 'convenience'}],
    'convenience': [{'shop': 'convenience'}],
    'clothing': [{'shop': 'clothes'}],
    'electronics': [{'shop': 'electronics'}],
    'mall': [{'shop': 'mall'}],
    'retail': [{'shop': 'retail'}],
    
    # Services
    'salon': [{'shop': 'hairdresser'}, {'shop': 'beauty'}],
    'spa': [{'leisure': 'spa'}, {'shop': 'massage'}],
    'laundry': [{'shop': 'laundry'}],
    'bank': [{'amenity': 'bank'}],
    'atm': [{'amenity': 'atm'}],
    
    # Education
    'school': [{'amenity': 'school'}],
    'college': [{'amenity': 'college'}],
    'university': [{'amenity': 'university'}],
    'tuition': [{'amenity': 'tutoring'}],
    
    # Entertainment
    'cinema': [{'amenity': 'cinema'}],
    'theatre': [{'amenity': 'theatre'}],
    'nightclub': [{'amenity': 'nightclub'}],
    
    # Accommodation
    'hotel': [{'tourism': 'hotel'}],
    'hostel': [{'tourism': 'hostel'}],
    'guest_house': [{'tourism': 'guest_house'}],
}


def _build_overpass_query(lat: float, lng: float, radius: int, tags: List[Dict[str, str]]) -> str:
    """
    Build an Overpass QL query to find nodes, ways, and relations
    matching the given tags within the specified radius.
    
    Args:
        lat: Latitude of center point
        lng: Longitude of center point
        radius: Search radius in meters
        tags: List of OSM tag dictionaries to search for
        
    Returns:
        Overpass QL query string
    """
    query_parts = []
    
    for tag_dict in tags:
        for key, value in tag_dict.items():
            # Query for nodes, ways, and relations with this tag
            tag_filter = f'["{key}"="{value}"]'
            around_filter = f'(around:{radius},{lat},{lng})'
            
            query_parts.append(f'node{tag_filter}{around_filter};')
            query_parts.append(f'way{tag_filter}{around_filter};')
            query_parts.append(f'relation{tag_filter}{around_filter};')
    
    # Combine all queries with union
    query = f"""
    [out:json][timeout:25];
    (
        {chr(10).join(query_parts)}
    );
    out count;
    """
    
    return query


def _build_detailed_query(lat: float, lng: float, radius: int, tags: List[Dict[str, str]]) -> str:
    """
    Build an Overpass QL query that returns actual elements (not just count).
    Used when we need names and locations of competitors.
    
    Args:
        lat: Latitude of center point
        lng: Longitude of center point
        radius: Search radius in meters
        tags: List of OSM tag dictionaries to search for
        
    Returns:
        Overpass QL query string
    """
    query_parts = []
    
    for tag_dict in tags:
        for key, value in tag_dict.items():
            tag_filter = f'["{key}"="{value}"]'
            around_filter = f'(around:{radius},{lat},{lng})'
            
            query_parts.append(f'node{tag_filter}{around_filter};')
            query_parts.append(f'way{tag_filter}{around_filter};')
            query_parts.append(f'relation{tag_filter}{around_filter};')
    
    query = f"""
    [out:json][timeout:25];
    (
        {chr(10).join(query_parts)}
    );
    out body center;
    """
    
    return query


def get_competitor_count(lat: float, lng: float, radius: int, category: str) -> int:
    """
    Count the number of competitors of a given category within a radius.
    
    Uses OpenStreetMap Overpass API to query for POIs matching the category.
    
    Args:
        lat: Latitude of the center point
        lng: Longitude of the center point
        radius: Search radius in meters (e.g., 500 for 500m)
        category: Business category (e.g., "cafe", "restaurant", "gym")
        
    Returns:
        Number of competitors found, or -1 if the query failed
        
    Example:
        count = get_competitor_count(12.9716, 77.5946, 500, "cafe")
    """
    # Get OSM tags for the category
    tags = CATEGORY_TAG_MAPPING.get(category.lower())
    
    if not tags:
        print(f"Warning: Unknown category '{category}', using generic amenity search")
        tags = [{'amenity': category.lower()}]
    
    # Build the query
    query = _build_detailed_query(lat, lng, radius, tags)
    
    try:
        # Create Overpass API instance
        api = overpy.Overpass()
        
        # Execute query with timeout
        result = api.query(query)
        
        # Count all results (nodes + ways + relations)
        count = len(result.nodes) + len(result.ways) + len(result.relations)
        
        return count
        
    except overpy.exception.OverpassTooManyRequests:
        print(f"Overpass API rate limited, returning -1")
        return -1
        
    except overpy.exception.OverpassGatewayTimeout:
        print(f"Overpass API timeout, returning -1")
        return -1
        
    except overpy.exception.OverpassBadRequest as e:
        print(f"Overpass API bad request: {e}")
        return -1
        
    except Exception as e:
        print(f"Overpass API error: {e}")
        return -1


def get_competitors_detailed(lat: float, lng: float, radius: int, category: str) -> List[Dict]:
    """
    Get detailed information about competitors within a radius.
    
    Returns names, locations, and other metadata about each competitor.
    
    Args:
        lat: Latitude of the center point
        lng: Longitude of the center point
        radius: Search radius in meters
        category: Business category (e.g., "cafe", "restaurant")
        
    Returns:
        List of competitor dictionaries with name, lat, lng, and tags
        Returns empty list if query fails
        
    Example:
        competitors = get_competitors_detailed(12.9716, 77.5946, 500, "cafe")
    """
    tags = CATEGORY_TAG_MAPPING.get(category.lower())
    
    if not tags:
        tags = [{'amenity': category.lower()}]
    
    query = _build_detailed_query(lat, lng, radius, tags)
    
    try:
        api = overpy.Overpass()
        result = api.query(query)
        
        competitors = []
        
        # Process nodes
        for node in result.nodes:
            competitor = {
                'id': f'node_{node.id}',
                'name': node.tags.get('name', 'Unknown'),
                'lat': float(node.lat),
                'lng': float(node.lon),
                'type': 'node',
                'tags': dict(node.tags),
                'category': category
            }
            competitors.append(competitor)
        
        # Process ways (use center point)
        for way in result.ways:
            # Ways have center_lat and center_lon when queried with 'out center'
            competitor = {
                'id': f'way_{way.id}',
                'name': way.tags.get('name', 'Unknown'),
                'lat': float(way.center_lat) if way.center_lat else lat,
                'lng': float(way.center_lon) if way.center_lon else lng,
                'type': 'way',
                'tags': dict(way.tags),
                'category': category
            }
            competitors.append(competitor)
        
        # Process relations (use center point)
        for relation in result.relations:
            competitor = {
                'id': f'relation_{relation.id}',
                'name': relation.tags.get('name', 'Unknown'),
                'lat': float(relation.center_lat) if hasattr(relation, 'center_lat') and relation.center_lat else lat,
                'lng': float(relation.center_lon) if hasattr(relation, 'center_lon') and relation.center_lon else lng,
                'type': 'relation',
                'tags': dict(relation.tags),
                'category': category
            }
            competitors.append(competitor)
        
        return competitors
        
    except Exception as e:
        print(f"Overpass API error getting detailed competitors: {e}")
        return []


# Landmark categories for OSM query
LANDMARK_TAG_MAPPING: Dict[str, List[Dict[str, str]]] = {
    'metro': [{'railway': 'station'}, {'station': 'subway'}],
    'bus_stop': [{'highway': 'bus_stop'}, {'amenity': 'bus_station'}],
    'school': [{'amenity': 'school'}],
    'college': [{'amenity': 'college'}, {'amenity': 'university'}],
    'hospital': [{'amenity': 'hospital'}],
    'mall': [{'shop': 'mall'}],
    'park': [{'leisure': 'park'}],
    'bank': [{'amenity': 'bank'}],
    'atm': [{'amenity': 'atm'}],
    'temple': [{'amenity': 'place_of_worship'}],
}


def get_landmarks_from_osm(lat: float, lng: float, radius: int) -> List[Dict]:
    """
    Get landmarks from OpenStreetMap within a radius.
    Fetches multiple landmark types for better area coverage.
    
    Args:
        lat: Latitude of center
        lng: Longitude of center
        radius: Search radius in meters
        
    Returns:
        List of landmarks with name, lat, lng, category
    """
    landmarks = []
    
    # Fetch each landmark type
    for category, tags in LANDMARK_TAG_MAPPING.items():
        query = _build_detailed_query(lat, lng, radius, tags)
        
        try:
            api = overpy.Overpass()
            result = api.query(query)
            
            # Process nodes
            for node in result.nodes:
                name = node.tags.get('name', '')
                if name:
                    landmarks.append({
                        'name': name,
                        'lat': float(node.lat),
                        'lng': float(node.lon),
                        'category': category
                    })
            
            # Process ways with centers
            for way in result.ways:
                name = way.tags.get('name', '')
                if name and way.center_lat:
                    landmarks.append({
                        'name': name,
                        'lat': float(way.center_lat),
                        'lng': float(way.center_lon),
                        'category': category
                    })
                    
        except Exception as e:
            print(f"Error fetching {category} landmarks: {e}")
            continue
    
    return landmarks


def get_available_categories() -> List[str]:
    """
    Get list of available business categories for competitor search.
    
    Returns:
        List of category names that can be used with get_competitor_count
    """
    return list(CATEGORY_TAG_MAPPING.keys())


# Convenience functions for common categories
def get_cafe_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count cafes within radius."""
    return get_competitor_count(lat, lng, radius, 'cafe')


def get_restaurant_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count restaurants within radius."""
    return get_competitor_count(lat, lng, radius, 'restaurant')


def get_gym_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count gyms/fitness centers within radius."""
    return get_competitor_count(lat, lng, radius, 'gym')


def get_pharmacy_count(lat: float, lng: float, radius: int = 500) -> int:
    """Count pharmacies within radius."""
    return get_competitor_count(lat, lng, radius, 'pharmacy')
</file>

<file path="backend/services/latlong_service.py">
"""
Hotspot IQ - LatLong.ai Service Wrapper
Handles all interactions with the LatLong.ai API.

API Documentation: https://apihub.latlong.ai/Documentation

Response Format (all endpoints):
{
  "code": 1001,
  "status": "success",
  "data": [...] or {...}
}
"""

import requests
from typing import List, Dict, Any, Optional
from config import Config, COMPETITOR_MAPPING, FILTER_POI_MAPPING


class LatLongService:
    """Service wrapper for LatLong.ai API."""
    
    def __init__(self):
        self.api_key = Config.LATLONG_API_KEY
        self.base_url = Config.LATLONG_BASE_URL
        # LatLong API uses X-Authorization-Token header
        self.headers = {
            'X-Authorization-Token': self.api_key,
            'Content-Type': 'application/json'
        }
    
    def _make_request(self, method: str, endpoint: str, params: Dict = None, json_data: Dict = None) -> Dict:
        """Make HTTP request to LatLong API."""
        # Endpoints use .json suffix
        url = f"{self.base_url}/{endpoint}.json"
        
        try:
            if method == 'GET':
                response = requests.get(url, headers=self.headers, params=params, timeout=30)
            else:
                response = requests.post(url, headers=self.headers, json=json_data, timeout=30)
            
            response.raise_for_status()
            
            # Handle empty responses
            if not response.text or response.text.strip() == '':
                print(f"LatLong API Warning: Empty response from {endpoint}")
                return {'success': False, 'error': 'Empty response'}
            
            try:
                result = response.json()
            except ValueError as json_err:
                print(f"LatLong API JSON Error: {str(json_err)} - Response: {response.text[:200]}")
                return {'success': False, 'error': f'Invalid JSON response: {str(json_err)}'}
            
            # LatLong API wraps response in code/status/data structure
            if result.get('status') == 'success' and 'data' in result:
                return {'success': True, 'data': result['data']}
            else:
                return {'success': False, 'error': result.get('message', 'Unknown error')}
                
        except requests.exceptions.RequestException as e:
            print(f"LatLong API Error: {str(e)}")
            return {'success': False, 'error': str(e)}
    
    # Major areas database for Indian cities
    MAJOR_AREAS = {
        'bengaluru': [
            'Indiranagar', 'Koramangala', 'Whitefield', 'Electronic City', 'Jayanagar',
            'Malleshwaram', 'HSR Layout', 'BTM Layout', 'Marathahalli', 'Banashankari',
            'Rajajinagar', 'Basavanagudi', 'JP Nagar', 'Hebbal', 'Yelahanka',
            'Sadashivanagar', 'Bannerghatta Road', 'Sarjapur Road', 'MG Road', 
            'Brigade Road', 'Commercial Street', 'Cunningham Road', 'Lavelle Road',
            'Residency Road', 'Richmond Road', 'Vittal Mallya Road', 'Kasturba Road',
            'Shivajinagar', 'Majestic', 'KR Market', 'Chickpet', 'Avenue Road',
            'Frazer Town', 'Cox Town', 'Benson Town', 'RT Nagar', 'Sanjaynagar',
            'Vijayanagar', 'Nagarbhavi', 'Basaveshwaranagar', 'Yeshwanthpur',
            'Peenya', 'Tumkur Road', 'Mysore Road', 'Kanakapura Road', 'Hosur Road',
            'Old Airport Road', 'Outer Ring Road', 'Bellary Road', 'Hennur',
            'Kalyan Nagar', 'Kammanahalli', 'HRBR Layout', 'Ramamurthy Nagar',
            'KR Puram', 'Mahadevapura', 'Bellandur', 'Varthur', 'Brookefield',
            'ITPL', 'Domlur', 'HAL', 'Old Madras Road', 'CV Raman Nagar',
            'Ulsoor', 'MG Road', 'Trinity', 'Ashok Nagar', 'Wilson Garden',
        ],
        'bangalore': [  # Alias
            'Indiranagar', 'Koramangala', 'Whitefield', 'Electronic City', 'Jayanagar',
            'Malleshwaram', 'HSR Layout', 'BTM Layout', 'Marathahalli', 'Banashankari',
            'Rajajinagar', 'Basavanagudi', 'JP Nagar', 'Hebbal', 'Yelahanka',
        ],
        'mumbai': [
            'Bandra', 'Andheri', 'Juhu', 'Powai', 'Lower Parel', 'Worli', 'Dadar',
            'Colaba', 'Marine Drive', 'Nariman Point', 'Fort', 'Churchgate',
            'Santacruz', 'Khar', 'Malad', 'Goregaon', 'Kandivali', 'Borivali',
            'Thane', 'Navi Mumbai', 'Vashi', 'Kharghar', 'Panvel', 'Airoli',
            'BKC', 'Kurla', 'Ghatkopar', 'Mulund', 'Vikhroli', 'Chembur',
            'Matunga', 'Sion', 'Wadala', 'Parel', 'Lalbaug', 'Prabhadevi',
            'Mahim', 'Dharavi', 'Versova', 'Lokhandwala', 'Oshiwara', 'DN Nagar',
        ],
        'delhi': [
            'Connaught Place', 'Karol Bagh', 'Chandni Chowk', 'Saket', 'Hauz Khas',
            'Greater Kailash', 'Lajpat Nagar', 'Defence Colony', 'South Extension',
            'Vasant Kunj', 'Vasant Vihar', 'Dwarka', 'Janakpuri', 'Rajouri Garden',
            'Punjabi Bagh', 'Pitampura', 'Rohini', 'Model Town', 'Civil Lines',
            'Nehru Place', 'Okhla', 'Sarita Vihar', 'Jasola', 'Kalkaji',
            'Green Park', 'Safdarjung', 'Jor Bagh', 'Khan Market', 'Lodhi Colony',
            'Mayur Vihar', 'Preet Vihar', 'Laxmi Nagar', 'Vivek Vihar',
            'Paharganj', 'Daryaganj', 'ITO', 'Mandi House', 'Rajiv Chowk',
        ],
        'hyderabad': [
            'Banjara Hills', 'Jubilee Hills', 'Hitech City', 'Gachibowli', 'Madhapur',
            'Kondapur', 'Kukatpally', 'Miyapur', 'Secunderabad', 'Ameerpet',
            'Begumpet', 'Somajiguda', 'Punjagutta', 'Abids', 'Nampally',
            'Charminar', 'Koti', 'Dilsukhnagar', 'LB Nagar', 'Uppal',
            'Manikonda', 'Tolichowki', 'Mehdipatnam', 'Attapur', 'Rajendranagar',
            'Film Nagar', 'Yousufguda', 'SR Nagar', 'Sanath Nagar', 'Erragadda',
        ],
        'chennai': [
            'T Nagar', 'Anna Nagar', 'Adyar', 'Velachery', 'OMR', 'ECR',
            'Nungambakkam', 'Kodambakkam', 'Mylapore', 'Alwarpet', 'RA Puram',
            'Besant Nagar', 'Thiruvanmiyur', 'Sholinganallur', 'Porur', 'Vadapalani',
            'Ashok Nagar', 'KK Nagar', 'West Mambalam', 'Saidapet', 'Guindy',
            'Mount Road', 'Egmore', 'Kilpauk', 'Chetpet', 'Royapettah',
            'Teynampet', 'Thousand Lights', 'Triplicane', 'Marina Beach', 'George Town',
        ],
        'pune': [
            'Koregaon Park', 'Kalyani Nagar', 'Viman Nagar', 'Kharadi', 'Magarpatta',
            'Hadapsar', 'Wakad', 'Hinjewadi', 'Baner', 'Aundh', 'Pashan',
            'Shivajinagar', 'FC Road', 'JM Road', 'MG Road', 'Camp', 'Deccan',
            'Kothrud', 'Karve Nagar', 'Warje', 'Sinhagad Road', 'Bibwewadi',
            'Katraj', 'Kondhwa', 'NIBM', 'Undri', 'Mohammadwadi', 'Wanowrie',
        ],
        'kolkata': [
            'Park Street', 'Salt Lake', 'New Town', 'Rajarhat', 'EM Bypass',
            'Ballygunge', 'Alipore', 'Behala', 'Tollygunge', 'Jadavpur',
            'Gariahat', 'Rashbehari', 'Dharmatala', 'Esplanade', 'BBD Bagh',
            'Howrah', 'Sealdah', 'College Street', 'Shyambazar', 'Hatibagan',
            'Dumdum', 'Barasat', 'Barrackpore', 'Garia', 'Narendrapur',
        ],
        'ahmedabad': [
            'CG Road', 'SG Highway', 'Ashram Road', 'Navrangpura', 'Vastrapur',
            'Bodakdev', 'Satellite', 'Prahlad Nagar', 'Thaltej', 'Gurukul',
            'Paldi', 'Ellis Bridge', 'Law Garden', 'Mithakhali', 'Stadium',
            'Maninagar', 'Ghatlodia', 'Chandkheda', 'Motera', 'Sabarmati',
        ],
    }
    
    def autocomplete(self, query: str, lat: float = None, lng: float = None, limit: int = 10) -> List[Dict]:
        """
        Get location suggestions for autocomplete - prioritizes major areas.
        
        Args:
            query: Search text entered by user
            lat: Optional latitude for location biasing
            lng: Optional longitude for location biasing
            limit: Maximum number of suggestions (default: 10, max: 20)
            
        Returns:
            List of location suggestions with geoid, name
        """
        if len(query) < 2:
            return []
        
        query_lower = query.lower().strip()
        suggestions = []
        seen_areas = set()  # Track seen area names to avoid duplicates
        
        # First, check if query matches any major areas from our curated list
        for city, areas in self.MAJOR_AREAS.items():
            # Skip alias entries (like 'bangalore' which duplicates 'bengaluru')
            if city == 'bangalore':
                continue
                
            for area in areas:
                area_lower = area.lower()
                if area_lower.startswith(query_lower) or query_lower in area_lower:
                    # Determine city name for display
                    city_display = city.title()
                    if city == 'bengaluru':
                        city_display = 'Bengaluru'
                    
                    # Create unique key to avoid duplicates
                    area_key = f"{area_lower}_{city}"
                    if area_key in seen_areas:
                        continue
                    seen_areas.add(area_key)
                    
                    suggestions.append({
                        'place_id': f"major_{city}_{area.replace(' ', '_').lower()}",
                        'geoid': None,
                        'name': f"{area}, {city_display}",
                        'is_area': True,
                        'is_major': True,
                        'lat': None,
                        'lng': None
                    })
        
        # Sort by relevance (exact prefix match first)
        suggestions.sort(key=lambda x: (
            0 if x['name'].lower().startswith(query_lower) else 1,
            len(x['name'])
        ))
        
        # Limit major area suggestions
        suggestions = suggestions[:limit]
        
        # If we have enough major area matches, return them
        if len(suggestions) >= 5:
            return suggestions[:limit]
        
        # Otherwise, also fetch from API to supplement
        params = {
            'query': query,
            'limit': min(limit, 20)
        }
        
        if lat is not None and lng is not None:
            params['lat'] = lat
            params['long'] = lng
        
        result = self._make_request('GET', 'v4/autocomplete', params=params)
        
        if result.get('success'):
            data = result.get('data', [])
            
            # Keywords that indicate POI/store rather than area
            POI_KEYWORDS = [
                'station', 'stop', 'shop', 'store', 'hotel', 'restaurant', 'cafe', 
                'hospital', 'clinic', 'school', 'college', 'temple', 'church', 'mosque',
                'mall', 'market', 'bank', 'atm', 'petrol', 'pump', 'bunk', 'park',
                'playground', 'water tank', 'office', 'building', 'tower', 'complex',
                'apartment', 'residency', 'villa', 'gym', 'fitness', 'salon', 'spa',
                'cinema', 'theater', 'theatre', 'pub', 'bar', 'lounge', 'club',
                'satellite town', 'layout', 'phase', 'block', 'sector',
            ]
            
            # Get existing names to avoid duplicates
            existing_names = {s['name'].lower() for s in suggestions}
            
            if isinstance(data, list):
                for item in data:
                    name = item.get('name', '')
                    name_lower = name.lower()
                    
                    # Skip if duplicate
                    if any(name_lower.startswith(existing.split(',')[0]) for existing in existing_names):
                        continue
                    
                    # Skip POIs
                    if any(kw in name_lower for kw in POI_KEYWORDS):
                        continue
                    
                    # Check if this looks like a major area (first part is clean)
                    parts = name.split(',')
                    first_part = parts[0].strip()
                    
                    # Skip if first part has too many words (likely a specific place)
                    if len(first_part.split()) > 3:
                        continue
                    
                    suggestions.append({
                        'place_id': str(item.get('geoid', '')),
                        'geoid': item.get('geoid'),
                        'name': name,
                        'is_area': True,
                        'is_major': False,
                        'lat': None,
                        'lng': None
                    })
                    
                    if len(suggestions) >= limit:
                        break
        
        return suggestions[:limit]
    
    def geocode(self, address: str) -> Dict:
        """
        Get coordinates from an address.
        
        LatLong API: GET /v4/geocode.json
        Response: { data: { address, latitude, longitude, accuracy } }
        
        Args:
            address: Full or partial address
            
        Returns:
            Dict with latitude, longitude, and address details
        """
        params = {
            'address': address,
            'accuracy_level': 'true'
        }
        
        result = self._make_request('GET', 'v4/geocode', params=params)
        
        if not result.get('success'):
            return {'error': 'Geocoding failed'}
        
        data = result.get('data', {})
        return {
            'address': data.get('address', address),
            'lat': float(data.get('latitude', 0)),
            'lng': float(data.get('longitude', 0)),
            'accuracy': data.get('accuracy', '')
        }
    
    def reverse_geocode(self, lat: float, lng: float) -> Dict:
        """
        Get address details from coordinates.
        
        LatLong API: GET /v4/reverse_geocode.json
        Response: { data: { address, pincode, landmark } }
        
        Args:
            lat: Latitude
            lng: Longitude
            
        Returns:
            Address details including formatted address, area_name, and components
        """
        params = {
            'latitude': lat,
            'longitude': lng
        }
        
        result = self._make_request('GET', 'v4/reverse_geocode', params=params)
        
        if not result.get('success'):
            return {
                'formatted_address': f'{lat}, {lng}',
                'area_name': f'{lat:.4f}, {lng:.4f}',
                'locality': '',
                'city': '',
                'pincode': '',
                'landmark': ''
            }
        
        data = result.get('data', {})
        full_address = data.get('address', f'{lat}, {lng}')
        
        # Extract area name from the address
        # Typical format: "Door No, Street, Area, City, State, Pincode"
        area_name = self._extract_area_name(full_address)
        
        return {
            'formatted_address': full_address,
            'area_name': area_name,
            'locality': '',  # Not directly provided
            'city': '',  # Parse from address if needed
            'pincode': data.get('pincode', ''),
            'state': '',  # Parse from address if needed
            'landmark': data.get('landmark', '')
        }
    
    def _is_valid_locality_name(self, name: str) -> bool:
        """
        Check if a name looks like a valid locality/area name (not a road, landmark, or POI).
        
        Args:
            name: The name to check
            
        Returns:
            True if it looks like a valid locality name
        """
        if not name or len(name) < 3:
            return False
        
        name_lower = name.lower()
        
        # Skip names that look like roads/streets
        road_keywords = ['road', 'street', 'main', 'cross', 'lane', 'highway', 'hwy', 
                        'marg', 'path', 'avenue', 'ave', 'drive', 'way',
                        '1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th']
        if any(kw in name_lower for kw in road_keywords):
            return False
        
        # Skip names that look like POIs/landmarks (start with "Near")
        if name_lower.startswith('near '):
            return False
        
        # Skip names with technical codes (like H207, SV-3B, etc.)
        if any(c.isdigit() for c in name[:3]):  # Starts with digits/codes
            return False
        
        # Skip very short names that are likely codes
        if len(name) < 4 and any(c.isdigit() for c in name):
            return False
        
        # Skip pipeline, industrial terms
        industrial_keywords = ['pipeline', 'gail', 'ongc', 'ntpc', 'industrial', 'factory']
        if any(kw in name_lower for kw in industrial_keywords):
            return False
        
        return True
    
    def _get_nominatim_area(self, lat: float, lng: float, zoom: int = 14) -> Dict:
        """
        Get area/locality name using Nominatim (OpenStreetMap) reverse geocoding.
        
        Nominatim zoom levels for India:
        - zoom=10: city (Bengaluru)
        - zoom=13: suburb/village (Vidyaranyapura)
        - zoom=14: neighbourhood (more specific)
        
        Args:
            lat: Latitude
            lng: Longitude
            zoom: Zoom level (10=city, 13=suburb, 14=neighbourhood)
            
        Returns:
            Dict with structured address components from OSM
        """
        try:
            url = "https://nominatim.openstreetmap.org/reverse"
            params = {
                'lat': lat,
                'lon': lng,
                'format': 'jsonv2',
                'addressdetails': 1,
                'zoom': zoom,
                'accept-language': 'en'
            }
            headers = {
                'User-Agent': 'HotspotIQ/1.0 (contact@hotspotiq.com)'  # Required by Nominatim
            }
            
            response = requests.get(url, params=params, headers=headers, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            address = data.get('address', {})
            
            # Priority order for area name in Indian context:
            # suburb > neighbourhood > city_district > county > city > town > village
            area_name = (
                address.get('suburb') or  # e.g., "Vidyaranyapura"
                address.get('neighbourhood') or  # e.g., "Sahakara Nagar"
                address.get('city_district') or  # e.g., "Bengaluru North"
                address.get('village') or
                address.get('town') or
                address.get('hamlet') or
                ''
            )
            
            city = (
                address.get('city') or 
                address.get('state_district') or  # e.g., "Bengaluru Urban"
                address.get('county') or
                ''
            )
            
            state = address.get('state', '')
            
            return {
                'area_name': area_name,
                'city': city,
                'state': state,
                'suburb': address.get('suburb', ''),
                'neighbourhood': address.get('neighbourhood', ''),
                'city_district': address.get('city_district', ''),
                'display_name': data.get('display_name', ''),
                'raw_address': address
            }
            
        except requests.exceptions.RequestException as e:
            print(f"Nominatim API Error: {str(e)}")
            return {}
        except Exception as e:
            print(f"Error in Nominatim lookup: {str(e)}")
            return {}
    
    def reverse_geocode_area(self, center_lat: float, center_lng: float, radius: int) -> Dict:
        """
        Get area name for a location using Nominatim (OpenStreetMap).
        
        Uses OSM's structured address data which provides clean suburb/neighbourhood names.
        Makes a single fast API call to get the area name.
        
        Args:
            center_lat: Center latitude
            center_lng: Center longitude
            radius: Radius in meters (used for context, not for multi-sampling)
            
        Returns:
            Address details with area_name for the location
        """
        try:
            # Single Nominatim call for the center point
            # This is fast and doesn't hit rate limits
            nominatim_result = self._get_nominatim_area(center_lat, center_lng, zoom=14)
            
            if nominatim_result and nominatim_result.get('area_name'):
                suburb = nominatim_result.get('suburb', '')
                neighbourhood = nominatim_result.get('neighbourhood', '')
                city_district = nominatim_result.get('city_district', '')
                city = nominatim_result.get('city', '')
                state = nominatim_result.get('state', '')
                
                # Priority: suburb > neighbourhood > city_district
                primary_area = suburb or neighbourhood or city_district or ''
                
                # Build the display name
                if primary_area and city:
                    # Clean up city name (remove "Urban" suffix)
                    display_city = city.replace(' Urban', '').replace(' Rural', '')
                    area_name = f"{primary_area}, {display_city}"
                elif primary_area:
                    area_name = primary_area
                elif city:
                    area_name = city
                else:
                    area_name = nominatim_result.get('area_name', '')
                
                return {
                    'formatted_address': nominatim_result.get('display_name', ''),
                    'area_name': area_name,
                    'locality': primary_area,
                    'city': city,
                    'state': state,
                    'pincode': '',
                    'landmark': '',
                    'areas_in_radius': [primary_area] if primary_area else []
                }
        
        except Exception as e:
            print(f"Nominatim reverse geocode error: {e}")
        
        # Fallback to LatLong API if Nominatim fails
        print("Nominatim failed, falling back to LatLong API")
        return self.reverse_geocode(center_lat, center_lng)
    
    def _extract_area_name(self, full_address: str) -> str:
        """
        Extract the major area/locality name from a full address.
        
        Strategy:
        1. Split address by comma
        2. Skip door numbers, road/street names, building names
        3. Find the main locality/area name
        4. Optionally include city name
        
        Args:
            full_address: Full address string
            
        Returns:
            Area name suitable for display (e.g., "Vidyaranyapura, Bengaluru")
        """
        if not full_address:
            return ''
        
        parts = [p.strip() for p in full_address.split(',')]
        
        # Keywords that indicate a road/street (not the main area)
        road_keywords = ['road', 'street', 'main', 'cross', 'lane', 'avenue', 'ave', 
                        'marg', 'path', 'way', 'drive', 'highway', 'hwy', 'nagar road',
                        '1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th',
                        '11th', '12th', '13th', '14th', '15th', 'first', 'second', 'third']
        
        # Keywords that indicate state/country (skip these)
        state_keywords = ['karnataka', 'maharashtra', 'tamil nadu', 'delhi', 'telangana', 
                         'andhra pradesh', 'kerala', 'gujarat', 'rajasthan', 'west bengal',
                         'uttar pradesh', 'madhya pradesh', 'bihar', 'punjab', 'haryana',
                         'india', 'odisha', 'orissa', 'assam', 'goa']
        
        # Keywords to skip (buildings, floors, etc.)
        skip_keywords = ['floor', 'block', 'wing', 'tower', 'flat', 'house', 'no.', 'no ', 
                        'building', 'complex', 'apartment', 'apt', 'plot', 'door', 'site']
        
        # Major city names (these come after locality)
        city_keywords = ['bengaluru', 'bangalore', 'mumbai', 'delhi', 'chennai', 'hyderabad',
                        'kolkata', 'pune', 'ahmedabad', 'jaipur', 'lucknow', 'kanpur',
                        'nagpur', 'indore', 'thane', 'bhopal', 'visakhapatnam', 'patna',
                        'vadodara', 'ghaziabad', 'ludhiana', 'agra', 'nashik', 'faridabad',
                        'meerut', 'rajkot', 'varanasi', 'srinagar', 'aurangabad', 'dhanbad',
                        'amritsar', 'navi mumbai', 'allahabad', 'ranchi', 'howrah', 'coimbatore',
                        'jabalpur', 'gwalior', 'vijayawada', 'jodhpur', 'madurai', 'raipur',
                        'kota', 'chandigarh', 'guwahati', 'solapur', 'mysore', 'mysuru']
        
        area_name = None
        city_name = None
        
        for part in parts:
            part_lower = part.lower().strip()
            
            # Skip empty or very short parts
            if not part or len(part) < 3:
                continue
            
            # Skip parts that are just numbers (door numbers, pincodes)
            if part.replace(' ', '').replace('-', '').isdigit():
                continue
            
            # Skip 6-digit pincodes
            clean_part = part.replace(' ', '')
            if len(clean_part) == 6 and clean_part.isdigit():
                continue
            
            # Skip parts starting with numbers (door numbers like "123" or "6th")
            first_word = part.split()[0] if part.split() else ''
            if first_word.replace('-', '').replace('/', '').isdigit():
                continue
            
            # Skip building/floor keywords
            if any(kw in part_lower for kw in skip_keywords):
                continue
            
            # Skip state/country names
            if any(state in part_lower for state in state_keywords):
                continue
            
            # Check if this is a city name
            if any(city in part_lower for city in city_keywords):
                city_name = part
                continue
            
            # Skip road/street names - we want the locality, not the road
            if any(kw in part_lower for kw in road_keywords):
                continue
            
            # This should be the area/locality name
            if area_name is None:
                area_name = part
        
        # Build the result
        if area_name:
            if city_name:
                return f"{area_name}, {city_name}"
            return area_name
        
        # Fallback: if no area found, try to get something meaningful
        for part in parts:
            part_lower = part.lower().strip()
            if part and len(part) > 3:
                if not any(state in part_lower for state in state_keywords):
                    if not part.replace(' ', '').replace('-', '').isdigit():
                        return part
        
        return full_address.split(',')[0] if full_address else ''
    
    def get_poi(self, lat: float, lng: float, category: str, radius: int = 1000) -> Dict:
        """
        Get Points of Interest by category near a location.
        
        LatLong API: GET /v4/point_of_interest.json
        Response: { data: [{ category, name }] }
        
        Note: POI API returns category/name but not coordinates.
        For coordinates, use the Landmark API.
        
        Args:
            lat: Latitude
            lng: Longitude  
            category: POI category (e.g., hospital, school, hotel, Pin Code, etc.)
            radius: Search radius in meters (not directly supported, for reference)
            
        Returns:
            Dict with count and list of nearby POIs
        """
        params = {
            'latitude': lat,
            'longitude': lng,
            'category': category
        }
        
        result = self._make_request('GET', 'v4/point_of_interest', params=params)
        
        if not result.get('success'):
            return {'count': 0, 'pois': []}
        
        data = result.get('data', [])
        pois = []
        
        if isinstance(data, list):
            for poi in data:
                pois.append({
                    'name': poi.get('name', 'Unknown'),
                    'category': poi.get('category', category),
                    # POI API doesn't return coordinates
                    'lat': lat,  # Use center point as approximation
                    'lng': lng,
                    'distance': 0
                })
        
        return {
            'count': len(pois),
            'pois': pois
        }
    
    def get_landmarks(self, lat: float, lng: float) -> List[Dict]:
        """
        Get nearby landmarks with coordinates.
        
        LatLong API: GET /v4/landmarks.json
        Response: { data: [{ name, geo, latitude, longitude }] }
        
        Args:
            lat: Latitude
            lng: Longitude
            
        Returns:
            List of landmarks with name, coordinates
        """
        params = {
            'lat': lat,
            'lon': lng
        }
        
        result = self._make_request('GET', 'v4/landmarks', params=params)
        
        if not result.get('success'):
            return []
        
        data = result.get('data', [])
        landmarks = []
        
        if isinstance(data, list):
            for item in data:
                landmarks.append({
                    'name': item.get('name', 'Unknown'),
                    'geo': item.get('geo', ''),
                    'lat': float(item.get('latitude', lat)),
                    'lng': float(item.get('longitude', lng)),
                    'category': 'landmark'  # Default category
                })
        
        return landmarks
    
    def get_competitors(self, lat: float, lng: float, business_type: str, radius: int = 1000) -> Dict:
        """
        Get competitor businesses based on business type.
        Uses both POI and Landmarks API to find nearby competitors.
        
        Args:
            lat: Latitude
            lng: Longitude
            business_type: Type of business (cafe, gym, etc.)
            radius: Search radius in meters
            
        Returns:
            Dict with total count and list of competitors
        """
        categories = COMPETITOR_MAPPING.get(business_type, [])
        
        if not categories:
            return {'count': 0, 'nearby': []}
        
        all_competitors = []
        
        # Get landmarks first (they have coordinates)
        landmarks = self.get_landmarks(lat, lng)
        
        # Add landmarks that might be competitors
        for landmark in landmarks:
            name_lower = landmark.get('name', '').lower()
            # Check if landmark matches any competitor category
            for category in categories:
                if category.lower() in name_lower:
                    all_competitors.append({
                        'name': landmark.get('name'),
                        'lat': landmark.get('lat'),
                        'lng': landmark.get('lng'),
                        'category': category,
                        'distance': self._calculate_distance(lat, lng, landmark.get('lat'), landmark.get('lng'))
                    })
                    break
        
        # Also try POI API for each category
        for category in categories:
            result = self.get_poi(lat, lng, category, radius)
            for poi in result.get('pois', []):
                # Check for duplicates
                if not any(c['name'] == poi['name'] for c in all_competitors):
                    all_competitors.append(poi)
        
        return {
            'count': len(all_competitors),
            'nearby': all_competitors
        }
    
    def _calculate_distance(self, lat1: float, lng1: float, lat2: float, lng2: float) -> int:
        """Calculate approximate distance in meters between two points."""
        import math
        
        if lat2 is None or lng2 is None:
            return 0
            
        R = 6371000  # Earth's radius in meters
        phi1 = math.radians(lat1)
        phi2 = math.radians(lat2)
        delta_phi = math.radians(lat2 - lat1)
        delta_lambda = math.radians(lng2 - lng1)
        
        a = math.sin(delta_phi/2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return int(R * c)
    
    def get_landmarks_by_filters(self, lat: float, lng: float, filters: List[str], radius: int = 1000) -> Dict:
        """
        Get landmarks based on proximity filters.
        Combines Landmarks API with POI API for comprehensive results.
        
        Args:
            lat: Latitude
            lng: Longitude
            filters: List of filter keys (near_metro, near_school, etc.)
            radius: Search radius in meters
            
        Returns:
            Dict with landmark counts by category
        """
        landmarks_by_category = {}
        all_pois = []
        
        # First, get nearby landmarks with coordinates
        nearby_landmarks = self.get_landmarks(lat, lng)
        
        for filter_key in filters:
            category = FILTER_POI_MAPPING.get(filter_key)
            if category:
                category_pois = []
                
                # Check if any landmarks match this category
                for landmark in nearby_landmarks:
                    name_lower = landmark.get('name', '').lower()
                    if category.lower() in name_lower:
                        landmark_with_cat = {**landmark, 'category': category}
                        category_pois.append(landmark_with_cat)
                
                # Also try POI API
                poi_result = self.get_poi(lat, lng, category, radius)
                for poi in poi_result.get('pois', []):
                    if not any(p['name'] == poi['name'] for p in category_pois):
                        category_pois.append(poi)
                
                landmarks_by_category[category] = {
                    'count': len(category_pois),
                    'pois': category_pois
                }
                all_pois.extend(category_pois)
        
        return {
            'by_category': landmarks_by_category,
            'total_count': len(all_pois),
            'all_pois': all_pois
        }
    
    def get_isochrone(self, lat: float, lng: float, distance_km: float = 1.0) -> Dict:
        """
        Get isochrone polygon for reachability visualization.
        
        LatLong API: GET /v4/isochrone.json
        Response: { data: { geom: { type: "Feature", geometry: { coordinates, type: "Polygon" } } } }
        
        Args:
            lat: Latitude
            lng: Longitude
            distance_km: Distance in kilometers (default: 1.0)
            
        Returns:
            GeoJSON Feature with polygon geometry
        """
        params = {
            'latitude': lat,
            'longitude': lng,
            'distance_limit': distance_km
        }
        
        result = self._make_request('GET', 'v4/isochrone', params=params)
        
        if not result.get('success'):
            # Return a simple circular fallback
            return self._generate_fallback_isochrone(lat, lng, distance_km)
        
        data = result.get('data', {})
        geom = data.get('geom', {})
        
        # LatLong returns { geom: { type: "Feature", geometry: {...} } }
        if geom.get('type') == 'Feature':
            return {
                'type': 'Feature',
                'properties': {
                    'distance_km': distance_km,
                    'center': [lat, lng]
                },
                'geometry': geom.get('geometry', {
                    'type': 'Polygon',
                    'coordinates': []
                })
            }
        
        return self._generate_fallback_isochrone(lat, lng, distance_km)
    
    def _generate_fallback_isochrone(self, lat: float, lng: float, distance_km: float) -> Dict:
        """Generate a simple circular isochrone as fallback."""
        import math
        
        radius_km = distance_km
        
        # Generate circle points
        points = []
        for i in range(36):
            angle = math.radians(i * 10)
            dlat = (radius_km / 111) * math.cos(angle)
            dlng = (radius_km / (111 * math.cos(math.radians(lat)))) * math.sin(angle)
            points.append([lng + dlng, lat + dlat])
        points.append(points[0])  # Close the polygon
        
        return {
            'type': 'Feature',
            'properties': {
                'distance_km': distance_km,
                'is_fallback': True
            },
            'geometry': {
                'type': 'Polygon',
                'coordinates': [points]
            }
        }
    
    def get_digipin(self, lat: float, lng: float) -> Dict:
        """
        Get Digipin (Digital Address Code) for a location.
        
        Note: DIGIPIN API may not be available. We generate a placeholder
        based on coordinates that resembles India Post's DIGIPIN format.
        
        Args:
            lat: Latitude
            lng: Longitude
            
        Returns:
            Dict with digipin code and formatted address
        """
        # Generate a pseudo-DIGIPIN based on coordinates
        # Real DIGIPIN would come from India Post service
        # Format: XX-YYYY where XX is state code approximation, YYYY is area code
        
        # Approximate state from coordinates
        state_codes = {
            'KA': (12.0, 15.5, 74.0, 78.5),  # Karnataka
            'MH': (15.5, 22.0, 72.0, 80.5),  # Maharashtra  
            'TN': (8.0, 13.5, 76.0, 80.5),   # Tamil Nadu
            'DL': (28.0, 29.0, 76.5, 77.5),  # Delhi
            'UP': (23.5, 30.5, 77.0, 84.5),  # Uttar Pradesh
            'WB': (21.5, 27.5, 85.5, 89.5),  # West Bengal
            'BR': (24.0, 27.5, 83.0, 88.5),  # Bihar
            'GJ': (20.0, 24.5, 68.0, 74.5),  # Gujarat
            'RJ': (23.0, 30.0, 69.5, 78.0),  # Rajasthan
            'KL': (8.0, 12.8, 74.5, 77.5),   # Kerala
        }
        
        state_code = 'XX'
        for code, (lat_min, lat_max, lng_min, lng_max) in state_codes.items():
            if lat_min <= lat <= lat_max and lng_min <= lng <= lng_max:
                state_code = code
                break
        
        # Generate area code from coordinates
        area_code = abs(hash((round(lat, 4), round(lng, 4)))) % 10000
        
        return {
            'digipin': f'{state_code}-{area_code:04d}',
            'formatted_address': f'{lat:.6f}, {lng:.6f}'
        }
    
    def distance_matrix(self, origins: List[Dict], destinations: List[Dict]) -> Dict:
        """
        Calculate distance and drive time between locations.
        
        Args:
            origins: List of {lat, lng} dicts
            destinations: List of {lat, lng} dicts
            
        Returns:
            Matrix of distances and durations
        """
        json_data = {
            'origins': origins,
            'destinations': destinations,
            'mode': 'car'
        }
        
        result = self._make_request('POST', 'distance-matrix', json_data=json_data)
        
        if 'error' in result:
            return {'rows': []}
        
        return result


# Create singleton instance
latlong_service = LatLongService()
</file>

<file path="backend/services/places_service.py">
"""
Hotspot IQ - Places Service
Fetches nearby businesses using OpenStreetMap Overpass API.
Provides clean, reliable competitor data for heatmap generation.
"""

import overpy
import time
from typing import List, Dict, Optional


# Category mapping: user keywords -> OpenStreetMap tags
CATEGORY_MAPPING: Dict[str, Dict[str, str]] = {
    "cafe": {"amenity": "cafe"},
    "restaurant": {"amenity": "restaurant"},
    "hotel": {"tourism": "hotel"},
    "pharmacy": {"amenity": "pharmacy"},
    "hospital": {"amenity": "hospital"},
    "gym": {"leisure": "fitness_centre"},
    # Extended categories for better coverage
    "fast_food": {"amenity": "fast_food"},
    "bar": {"amenity": "bar"},
    "bakery": {"shop": "bakery"},
    "supermarket": {"shop": "supermarket"},
    "bank": {"amenity": "bank"},
    "atm": {"amenity": "atm"},
    "school": {"amenity": "school"},
    "college": {"amenity": "college"},
    "clinic": {"amenity": "clinic"},
    "salon": {"shop": "hairdresser"},
    "beauty": {"shop": "beauty"},
}

# Alternative Overpass API endpoints (in case main one is rate limited)
OVERPASS_ENDPOINTS = [
    "https://overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter", 
    "https://maps.mail.ru/osm/tools/overpass/api/interpreter",
]


def _build_query(lat: float, lng: float, radius: int, tag_key: str, tag_value: str) -> str:
    """
    Build an Overpass QL query for nodes, ways, and relations.
    
    Args:
        lat: Latitude of center point
        lng: Longitude of center point
        radius: Search radius in meters
        tag_key: OSM tag key (e.g., "amenity")
        tag_value: OSM tag value (e.g., "cafe")
        
    Returns:
        Overpass QL query string
    """
    query = f"""
    [out:json][timeout:10];
    (
        node["{tag_key}"="{tag_value}"](around:{radius},{lat},{lng});
        way["{tag_key}"="{tag_value}"](around:{radius},{lat},{lng});
        relation["{tag_key}"="{tag_value}"](around:{radius},{lat},{lng});
    );
    out center;
    """
    return query


def fetch_nearby_places(
    lat: float, 
    lng: float, 
    radius: int = 1000, 
    category: str = "cafe",
    max_retries: int = 3
) -> List[Dict]:
    """
    Fetch nearby places of a specific category using OpenStreetMap Overpass API.
    Includes retry logic with multiple API endpoints to handle rate limiting.
    
    Args:
        lat: Latitude of the center point
        lng: Longitude of the center point
        radius: Search radius in meters (default: 1000m)
        category: Business category keyword (default: "cafe")
        max_retries: Maximum retry attempts (default: 3)
        
    Returns:
        List of places with name, lat, lng, and type.
        Only returns places that have a name.
        
    Example:
        places = fetch_nearby_places(12.9716, 77.5946, 2500, "cafe")
        # Returns: [{"name": "Starbucks", "lat": 12.97, "lng": 77.59, "type": "cafe"}, ...]
    """
    # Get OSM tag for the category
    tag_info = CATEGORY_MAPPING.get(category.lower())
    
    if not tag_info:
        print(f" Unknown category '{category}', defaulting to amenity search")
        tag_key = "amenity"
        tag_value = category.lower()
    else:
        tag_key = list(tag_info.keys())[0]
        tag_value = list(tag_info.values())[0]
    
    # Build the query
    query = _build_query(lat, lng, radius, tag_key, tag_value)
    
    # Try each endpoint with retries
    last_error = None
    for endpoint_idx, endpoint in enumerate(OVERPASS_ENDPOINTS):
        for attempt in range(max_retries):
            try:
                # Create Overpass API instance with specific endpoint
                api = overpy.Overpass(url=endpoint)
                
                # Add delay between retries to avoid rate limiting
                if attempt > 0:
                    delay = 0.5  # Reduced delay
                    print(f" Waiting {delay}s before retry {attempt + 1}...")
                    time.sleep(delay)
                
                result = api.query(query)
                
                places = []
                
                # Process nodes (points)
                for node in result.nodes:
                    name = node.tags.get("name")
                    if name:  # Only include places with names
                        places.append({
                            "name": name,
                            "lat": float(node.lat),
                            "lng": float(node.lon),
                            "type": category
                        })
                
                # Process ways (buildings/areas) - use center coordinates
                for way in result.ways:
                    name = way.tags.get("name")
                    if name and way.center_lat and way.center_lon:
                        places.append({
                            "name": name,
                            "lat": float(way.center_lat),
                            "lng": float(way.center_lon),
                            "type": category
                        })
                
                # Process relations - use center if available
                for relation in result.relations:
                    name = relation.tags.get("name")
                    if name:
                        rel_lat = getattr(relation, 'center_lat', None)
                        rel_lng = getattr(relation, 'center_lon', None)
                        if rel_lat and rel_lng:
                            places.append({
                                "name": name,
                                "lat": float(rel_lat),
                                "lng": float(rel_lng),
                                "type": category
                            })
                
                print(f" Found {len(places)} {category}(s) within {radius}m radius")
                return places
                
            except overpy.exception.OverpassTooManyRequests:
                last_error = "Rate limited"
                print(f" Rate limited on endpoint {endpoint_idx + 1}, attempt {attempt + 1}")
                continue
                
            except overpy.exception.OverpassGatewayTimeout:
                last_error = "Timeout"
                print(f" Timeout on endpoint {endpoint_idx + 1}, attempt {attempt + 1}")
                continue
                
            except Exception as e:
                last_error = str(e)
                print(f" Error on endpoint {endpoint_idx + 1}: {e}")
                break  # Move to next endpoint on other errors
    
    print(f" All Overpass API attempts failed: {last_error}")
    return []


def fetch_competitors(
    lat: float, 
    lng: float, 
    radius: int, 
    business_type: str
) -> List[Dict]:
    """
    Fetch competitors for a specific business type.
    This is an alias for fetch_nearby_places with business-focused naming.
    
    For cafes, also searches for coffee shops and fast food places.
    For restaurants, also searches for fast food.
    
    Args:
        lat: Latitude
        lng: Longitude
        radius: Search radius in meters
        business_type: Type of business (cafe, restaurant, gym, etc.)
        
    Returns:
        List of competitor places with name, lat, lng, type
    """
    competitors = []
    seen_names = set()  # Avoid duplicates
    
    # Primary category
    primary_places = fetch_nearby_places(lat, lng, radius, business_type)
    for place in primary_places:
        name_key = place["name"].lower()
        if name_key not in seen_names:
            seen_names.add(name_key)
            competitors.append(place)
    
    # Extended search for related categories
    related_categories = {
        "cafe": ["fast_food", "bakery"],
        "restaurant": ["fast_food"],
        "gym": [],
        "pharmacy": ["clinic"],
        "hotel": [],
        "hospital": ["clinic"],
        "salon": ["beauty"],
    }
    
    extra_categories = related_categories.get(business_type.lower(), [])
    for extra_cat in extra_categories:
        extra_places = fetch_nearby_places(lat, lng, radius, extra_cat)
        for place in extra_places:
            name_key = place["name"].lower()
            if name_key not in seen_names:
                seen_names.add(name_key)
                # Mark with original business type for consistency
                place["type"] = business_type
                competitors.append(place)
    
    print(f" Total competitors found: {len(competitors)}")
    return competitors


def fetch_landmarks(lat: float, lng: float, radius: int) -> List[Dict]:
    """
    Fetch various landmark types for area analysis.
    
    Args:
        lat: Latitude
        lng: Longitude
        radius: Search radius in meters
        
    Returns:
        List of landmarks with name, lat, lng, type
    """
    landmark_categories = ["school", "college", "hospital", "bank", "atm"]
    
    landmarks = []
    seen_names = set()
    
    for category in landmark_categories:
        places = fetch_nearby_places(lat, lng, radius, category)
        for place in places:
            name_key = place["name"].lower()
            if name_key not in seen_names:
                seen_names.add(name_key)
                landmarks.append(place)
    
    print(f" Total landmarks found: {len(landmarks)}")
    return landmarks


# Convenience functions for common use cases
def get_cafes(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all cafes within radius."""
    return fetch_competitors(lat, lng, radius, "cafe")


def get_restaurants(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all restaurants within radius."""
    return fetch_competitors(lat, lng, radius, "restaurant")


def get_gyms(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all gyms within radius."""
    return fetch_competitors(lat, lng, radius, "gym")


def get_pharmacies(lat: float, lng: float, radius: int = 2500) -> List[Dict]:
    """Get all pharmacies within radius."""
    return fetch_competitors(lat, lng, radius, "pharmacy")
</file>

<file path="backend/services/validation_service.py">
"""
Hotspot IQ - Location Validation Service
Validates if a location is suitable for business analysis.

UPDATED: Now validates the ENTIRE RADIUS AREA, not just the center point.
This allows analysis even when the center is in water, as long as there's
usable land within the selected radius.

Performs four levels of validation:
1. Water Body Check - Detect if location is in ocean/lake/river
2. Roadway Access Check - Using LatLong Snap to Roads API + Overpass fallback
3. Ghost Town Check - Using Overpass API for amenities
4. Road Quality Check - For heavy logistics businesses
"""

import math
import requests
import overpy
import time
from typing import Dict, Tuple, Optional, List
from config import Config


# Business types requiring heavy logistics (need major roads)
HEAVY_LOGISTICS_BUSINESSES = [
    'car_showroom', 'car showroom', 'warehouse', 'factory', 'manufacturing',
    'logistics', 'distribution', 'trucking', 'heavy_equipment', 'industrial',
    'furniture_store', 'furniture store', 'building_materials', 'construction'
]

# OSM highway types considered insufficient for heavy logistics
INSUFFICIENT_ROAD_TYPES = [
    'footway', 'pedestrian', 'path', 'cycleway', 'bridleway', 
    'steps', 'service', 'track', 'corridor'
]

# Overpass API endpoints for fallback
OVERPASS_ENDPOINTS = [
    "https://overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter",
    "https://maps.mail.ru/osm/tools/overpass/api/interpreter",
]


class ValidationError(Exception):
    """Custom exception for location validation failures."""
    def __init__(self, message: str, error_type: str = "validation_error"):
        self.message = message
        self.error_type = error_type
        super().__init__(self.message)


def _generate_sample_points(lat: float, lng: float, radius: int) -> List[Tuple[float, float]]:
    """
    Generate sample points within the radius for area-based validation.
    Returns points at center, cardinal directions, and diagonals at various distances.
    
    Args:
        lat: Center latitude
        lng: Center longitude
        radius: Radius in meters
        
    Returns:
        List of (lat, lng) tuples representing sample points
    """
    # Convert radius to lat/lng offsets
    lat_offset_per_m = 1 / 111000  # ~1 degree per 111km
    lng_offset_per_m = 1 / (111000 * math.cos(math.radians(lat)))
    
    # Sample offsets as fractions of radius (lat_mult, lng_mult)
    # More points near edges to find land if center is in water
    offsets = [
        (0, 0),  # Center
        # Cardinal directions at 30%, 60%, 90% of radius
        (0.3, 0), (-0.3, 0), (0, 0.3), (0, -0.3),
        (0.6, 0), (-0.6, 0), (0, 0.6), (0, -0.6),
        (0.9, 0), (-0.9, 0), (0, 0.9), (0, -0.9),
        # Diagonals at 40%, 70% of radius
        (0.28, 0.28), (-0.28, 0.28), (0.28, -0.28), (-0.28, -0.28),
        (0.5, 0.5), (-0.5, 0.5), (0.5, -0.5), (-0.5, -0.5),
    ]
    
    points = []
    for lat_mult, lng_mult in offsets:
        sample_lat = lat + (lat_mult * radius * lat_offset_per_m)
        sample_lng = lng + (lng_mult * radius * lng_offset_per_m)
        points.append((sample_lat, sample_lng))
    
    return points


def _calculate_distance(lat1: float, lng1: float, lat2: float, lng2: float) -> float:
    """Calculate distance between two points in meters using Haversine formula."""
    R = 6371000  # Earth's radius in meters
    
    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    delta_lat = math.radians(lat2 - lat1)
    delta_lng = math.radians(lng2 - lng1)
    
    a = (math.sin(delta_lat / 2) ** 2 + 
         math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lng / 2) ** 2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    
    return R * c


def _is_point_in_water(lat: float, lng: float) -> Tuple[bool, Optional[str]]:
    """
    Check if a single point is in water.
    
    Args:
        lat: Latitude
        lng: Longitude
        
    Returns:
        Tuple of (is_in_water: bool, water_type: Optional[str])
    """
    try:
        query = f"""
        [out:json][timeout:10];
        (
            way["natural"="water"](around:50,{lat},{lng});
            relation["natural"="water"](around:50,{lat},{lng});
            way["natural"="coastline"](around:500,{lat},{lng});
            way["water"](around:50,{lat},{lng});
            relation["water"](around:50,{lat},{lng});
            way["waterway"~"river|stream|canal"](around:50,{lat},{lng});
            way["place"~"sea|ocean"](around:200,{lat},{lng});
            relation["place"~"sea|ocean"](around:200,{lat},{lng});
        );
        out body;
        """
        
        for endpoint in OVERPASS_ENDPOINTS[:2]:  # Use fewer endpoints for speed
            try:
                api = overpy.Overpass(url=endpoint)
                result = api.query(query)
                
                water_features = len(result.ways) + len(result.relations)
                
                if water_features > 0:
                    water_type = "water body"
                    for way in result.ways:
                        tags = way.tags
                        if tags.get('natural') == 'coastline' or tags.get('place') in ['sea', 'ocean']:
                            water_type = "ocean or sea"
                            break
                        elif tags.get('natural') == 'water':
                            water_type = tags.get('water', 'lake or reservoir')
                            break
                        elif tags.get('waterway'):
                            water_type = tags.get('waterway', 'river or stream')
                            break
                    return True, water_type
                
                return False, None
                
            except Exception:
                continue
        
        return False, None  # Assume not water if check fails
        
    except Exception:
        return False, None


def _is_point_on_land(lat: float, lng: float) -> bool:
    """
    Check if a point has land features (roads, buildings, amenities).
    
    Args:
        lat: Latitude
        lng: Longitude
        
    Returns:
        True if land features found nearby
    """
    try:
        query = f"""
        [out:json][timeout:10];
        (
            way["highway"](around:200,{lat},{lng});
            way["building"](around:200,{lat},{lng});
            node["amenity"](around:300,{lat},{lng});
        );
        out count;
        """
        
        for endpoint in OVERPASS_ENDPOINTS[:2]:
            try:
                api = overpy.Overpass(url=endpoint)
                result = api.query(query)
                
                total = len(result.nodes) + len(result.ways)
                return total > 0
                
            except Exception:
                continue
        
        return False
        
    except Exception:
        return False


def _find_best_land_point(center_lat: float, center_lng: float, radius: int) -> Optional[Tuple[float, float]]:
    """
    Find the best land point within the radius.
    Searches for areas with roads/buildings/amenities.
    
    Args:
        center_lat: Center latitude
        center_lng: Center longitude
        radius: Radius in meters
        
    Returns:
        Tuple of (lat, lng) of best land point, or None if no land found
    """
    print(f"    Searching for best land location within {radius}m radius...")
    
    sample_points = _generate_sample_points(center_lat, center_lng, radius)
    
    # Track which points are on land
    land_points = []
    
    for point_lat, point_lng in sample_points:
        is_water, _ = _is_point_in_water(point_lat, point_lng)
        
        if not is_water:
            # Check if there's land infrastructure
            if _is_point_on_land(point_lat, point_lng):
                distance_from_center = _calculate_distance(center_lat, center_lng, point_lat, point_lng)
                land_points.append((point_lat, point_lng, distance_from_center))
                print(f"    Found land at ({point_lat:.5f}, {point_lng:.5f}), {distance_from_center:.0f}m from center")
    
    if land_points:
        # Sort by distance from center (prefer closer points)
        land_points.sort(key=lambda x: x[2])
        best = land_points[0]
        print(f"    Best land point: ({best[0]:.5f}, {best[1]:.5f}), {best[2]:.0f}m from center")
        return (best[0], best[1])
    
    return None


def check_water_body_area(center_lat: float, center_lng: float, radius: int = 1000) -> Dict:
    """
    Check if the center point is in water. Only searches for alternative land
    if the center is actually in a water body.
    
    This is a WATER-ONLY check - it does NOT validate infrastructure.
    Infrastructure validation is handled by other checks (roadway, ghost town, etc.)
    
    Args:
        center_lat: Center latitude of the search area
        center_lng: Center longitude of the search area
        radius: Search radius in meters
        
    Returns:
        Dict with 'valid', 'is_water', 'water_type', 'message', 'best_land_point'
        
    Raises:
        ValidationError: If center is in water AND no land found in radius
    """
    print(f" Checking if center point is in water ({center_lat}, {center_lng})...")
    
    # Only check if the point is in water - NOT for infrastructure
    center_is_water, water_type = _is_point_in_water(center_lat, center_lng)
    
    if not center_is_water:
        # Center is NOT in water - that's all we need to know here
        # Other validation steps will check for roads, amenities, etc.
        print(f"    Center point is on land (not in water)")
        return {
            'valid': True,
            'is_water': False,
            'water_type': None,
            'message': 'Center point is on land',
            'best_land_point': {'lat': center_lat, 'lng': center_lng}
        }
    
    # Center IS in water - now search for nearby land within the radius
    print(f"    Center point is in {water_type}, searching for nearby land...")
    
    best_point = _find_best_land_point(center_lat, center_lng, radius)
    
    if best_point:
        print(f"    Found land within radius at ({best_point[0]:.5f}, {best_point[1]:.5f})")
        return {
            'valid': True,
            'is_water': False,
            'water_type': None,
            'message': f'Found usable land within the selected area',
            'best_land_point': {'lat': best_point[0], 'lng': best_point[1]}
        }
    
    # No land found in entire radius - the area is all water
    print(f"    No land found in the entire {radius}m radius")
    raise ValidationError(
        f"No land found within the selected {radius/1000:.1f}km radius. The entire area appears to be water.",
        "water_body"
    )


def check_water_body(lat: float, lng: float) -> Dict:
    """
    Step 0: Check if the location is in a water body (ocean, sea, lake, river).
    This is the FIRST check - critical for preventing ocean/lake locations.
    
    NOTE: This function checks a single point. For area-based validation,
    use check_water_body_area() instead.
    
    Args:
        lat: Latitude of the location
        lng: Longitude of the location
        
    Returns:
        Dict with 'valid', 'is_water', 'water_type', 'message'
        
    Raises:
        ValidationError: If location is in water
    """
    print(f" Checking if location ({lat}, {lng}) is in water body...")
    
    try:
        # Query to check if point is within any water body
        # Using a small radius to detect if we're IN water
        query = f"""
        [out:json][timeout:20];
        (
            // Natural water features
            way["natural"="water"](around:100,{lat},{lng});
            relation["natural"="water"](around:100,{lat},{lng});
            way["natural"="coastline"](around:1000,{lat},{lng});
            // Named water bodies
            way["water"](around:100,{lat},{lng});
            relation["water"](around:100,{lat},{lng});
            // Waterways
            way["waterway"~"river|stream|canal"](around:100,{lat},{lng});
            // Sea/Ocean
            way["place"~"sea|ocean"](around:500,{lat},{lng});
            relation["place"~"sea|ocean"](around:500,{lat},{lng});
        );
        out body;
        """
        
        for endpoint in OVERPASS_ENDPOINTS:
            try:
                api = overpy.Overpass(url=endpoint)
                result = api.query(query)
                
                water_features = len(result.ways) + len(result.relations)
                print(f"    Found {water_features} water features nearby")
                
                if water_features > 0:
                    # Determine water type
                    water_type = "water body"
                    for way in result.ways:
                        tags = way.tags
                        if tags.get('natural') == 'coastline':
                            water_type = "ocean or sea"
                            break
                        elif tags.get('place') in ['sea', 'ocean']:
                            water_type = "ocean or sea"
                            break
                        elif tags.get('natural') == 'water':
                            water_type = tags.get('water', 'lake or reservoir')
                            break
                        elif tags.get('waterway'):
                            water_type = tags.get('waterway', 'river or stream')
                            break
                    
                    for rel in result.relations:
                        tags = rel.tags
                        if tags.get('natural') == 'water':
                            water_type = tags.get('water', 'lake or reservoir')
                            break
                        elif tags.get('place') in ['sea', 'ocean']:
                            water_type = "ocean or sea"
                            break
                    
                    print(f"    Location appears to be in {water_type}")
                    raise ValidationError(
                        f"Location is in {water_type}. No business can be established here.",
                        "water_body"
                    )
                
                print(f"    No water body detected at location")
                return {
                    'valid': True,
                    'is_water': False,
                    'water_type': None,
                    'message': 'Location is not in water'
                }
                
            except overpy.exception.OverpassTooManyRequests:
                print(f"    Rate limited on {endpoint}, trying next...")
                time.sleep(0.5)
                continue
            except overpy.exception.OverpassGatewayTimeout:
                print(f"    Timeout on {endpoint}, trying next...")
                continue
            except ValidationError:
                raise
            except Exception as e:
                print(f"    Error checking water on {endpoint}: {e}")
                continue
        
        # If water check API fails, fall back to checking for ANY land features
        print("    Water check inconclusive, checking for land features...")
        return _verify_land_exists(lat, lng)
        
    except ValidationError:
        raise
    except Exception as e:
        print(f"    Water body check error: {e}")
        return _verify_land_exists(lat, lng)


def _verify_land_exists(lat: float, lng: float) -> Dict:
    """
    Verify that land/infrastructure exists at or near the location.
    If no land features found within reasonable radius, reject the location.
    """
    print(f"    Verifying land features exist near location...")
    
    try:
        # Check for ANY land-based infrastructure within 2km
        query = f"""
        [out:json][timeout:15];
        (
            // Roads are the strongest indicator of land
            way["highway"](around:2000,{lat},{lng});
            // Buildings
            way["building"](around:2000,{lat},{lng});
            // Land use
            way["landuse"](around:1000,{lat},{lng});
            // Any amenity
            node["amenity"](around:2000,{lat},{lng});
            // Places
            node["place"](around:2000,{lat},{lng});
        );
        out count;
        """
        
        for endpoint in OVERPASS_ENDPOINTS:
            try:
                api = overpy.Overpass(url=endpoint)
                result = api.query(query)
                
                total_features = len(result.nodes) + len(result.ways)
                print(f"    Found {total_features} land features within 2km")
                
                if total_features == 0:
                    raise ValidationError(
                        "No such possible business places present in the area. Location appears to be in water or completely uninhabited.",
                        "no_land_features"
                    )
                
                return {
                    'valid': True,
                    'is_water': False,
                    'water_type': None,
                    'message': f'Found {total_features} land features nearby'
                }
                
            except overpy.exception.OverpassTooManyRequests:
                time.sleep(0.5)
                continue
            except ValidationError:
                raise
            except Exception as e:
                print(f"    Error on {endpoint}: {e}")
                continue
        
        # If ALL checks fail, be STRICT and reject
        raise ValidationError(
            "Unable to verify this is a valid land location. Please select a location in an accessible area.",
            "verification_failed"
        )
        
    except ValidationError:
        raise
    except Exception as e:
        raise ValidationError(
            "Unable to verify this is a valid land location. Please select a location in an accessible area.",
            "verification_failed"
        )


def check_roadway_access(lat: float, lng: float, max_distance: float = 100.0) -> Dict:
    """
    Step A: Check if location is accessible by road using LatLong Snap to Roads API.
    
    Args:
        lat: Latitude of the location
        lng: Longitude of the location
        max_distance: Maximum allowed distance from road in meters (default: 100m)
        
    Returns:
        Dict with 'valid', 'snapped_lat', 'snapped_lng', 'distance', 'message'
        
    Raises:
        ValidationError: If location is too far from any road
    """
    print(f" Checking roadway access...")
    
    try:
        # LatLong Snap to Roads API
        url = f"{Config.LATLONG_BASE_URL}/v4/snap.json"
        headers = {
            'X-Authorization-Token': Config.LATLONG_API_KEY,
            'Content-Type': 'application/json'
        }
        
        # Format coordinates as required by the API
        params = {
            'coordinates': f"[{lat},{lng}]"
        }
        
        response = requests.get(url, headers=headers, params=params, timeout=15)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get('status') == 'success' and 'data' in data:
                snapped_data = data['data']
                snapped_coords = snapped_data.get('snapped_coordinates', [])
                
                if snapped_coords and len(snapped_coords) > 0:
                    # Get the first snapped coordinate
                    snapped_point = snapped_coords[0]
                    snapped_lat = snapped_point[0]
                    snapped_lng = snapped_point[1]
                    
                    # Calculate distance from original to snapped point
                    distance = _calculate_distance(lat, lng, snapped_lat, snapped_lng)
                    
                    print(f"    Snap result: ({lat}, {lng}) -> ({snapped_lat}, {snapped_lng}), Distance: {distance:.1f}m")
                    
                    if distance > max_distance:
                        raise ValidationError(
                            f"Location is not accessible by road. Nearest road is {distance:.0f}m away.",
                            "roadway_access"
                        )
                    
                    print(f"    Road access confirmed (within {distance:.0f}m)")
                    return {
                        'valid': True,
                        'snapped_lat': snapped_lat,
                        'snapped_lng': snapped_lng,
                        'distance': distance,
                        'message': f"Location is {distance:.0f}m from nearest road"
                    }
        
        # If API fails or returns no data, fall back to Overpass check
        print("    Snap to Roads API failed, using Overpass fallback...")
        return _fallback_road_check(lat, lng, max_distance)
        
    except ValidationError:
        raise
    except Exception as e:
        print(f"    Roadway check error: {e}, using fallback...")
        return _fallback_road_check(lat, lng, max_distance)


def _fallback_road_check(lat: float, lng: float, max_distance: float = 100.0) -> Dict:
    """Fallback road check using Overpass API."""
    try:
        # Check for roads within max_distance
        query = f"""
        [out:json][timeout:10];
        (
            way["highway"](around:{max_distance},{lat},{lng});
        );
        out body;
        """
        
        for endpoint in OVERPASS_ENDPOINTS:
            try:
                api = overpy.Overpass(url=endpoint)
                result = api.query(query)
                
                road_count = len(result.ways)
                print(f"    Found {road_count} roads within {max_distance}m")
                
                if road_count == 0:
                    # Try a larger radius to give better error message
                    query_extended = f"""
                    [out:json][timeout:10];
                    (
                        way["highway"](around:1000,{lat},{lng});
                    );
                    out body;
                    """
                    result_extended = api.query(query_extended)
                    
                    if len(result_extended.ways) == 0:
                        raise ValidationError(
                            "Location is not accessible by road. No roads found within 1km.",
                            "roadway_access"
                        )
                    else:
                        raise ValidationError(
                            f"Location is not accessible by road. Nearest road is more than {max_distance:.0f}m away.",
                            "roadway_access"
                        )
                
                print(f"    Road access verified via Overpass")
                return {
                    'valid': True,
                    'snapped_lat': lat,
                    'snapped_lng': lng,
                    'distance': 0,
                    'message': "Road access verified"
                }
                
            except overpy.exception.OverpassTooManyRequests:
                time.sleep(0.5)
                continue
            except ValidationError:
                raise
            except Exception as e:
                print(f"    Error on {endpoint}: {e}")
                continue
        
        # If all Overpass endpoints fail, be strict
        raise ValidationError(
            "Unable to verify road access. Please select a location near a road.",
            "verification_failed"
        )
        
    except ValidationError:
        raise
    except Exception as e:
        raise ValidationError(
            "Unable to verify road access. Please try a different location.",
            "verification_failed"
        )


def check_area_viability(lat: float, lng: float, radius: int = 2000, min_amenities: int = 5) -> Dict:
    """
    Step B: Ghost Town Check - Verify area has sufficient development/amenities.
    
    Args:
        lat: Latitude of the location
        lng: Longitude of the location
        radius: Search radius in meters (default: 2000m / 2km)
        min_amenities: Minimum number of amenities required (default: 5)
        
    Returns:
        Dict with 'valid', 'amenity_count', 'message'
        
    Raises:
        ValidationError: If area has no/insufficient amenities
    """
    print(f" Checking area viability (min {min_amenities} amenities in {radius}m)...")
    
    try:
        # Query for various amenities that indicate developed area
        # Use 'out body;' to get actual elements we can count
        query = f"""
        [out:json][timeout:20];
        (
            // Commercial establishments
            node["shop"](around:{radius},{lat},{lng});
            way["shop"](around:{radius},{lat},{lng});
            node["amenity"](around:{radius},{lat},{lng});
            way["amenity"](around:{radius},{lat},{lng});
            // Offices/commercial buildings
            node["office"](around:{radius},{lat},{lng});
            way["office"](around:{radius},{lat},{lng});
            way["building"](around:{radius},{lat},{lng});
            // Residential (indicates population)
            node["building"](around:{radius},{lat},{lng});
        );
        out body;
        """
        
        for endpoint in OVERPASS_ENDPOINTS:
            try:
                api = overpy.Overpass(url=endpoint)
                result = api.query(query)
                
                # Count all elements
                total_count = len(result.nodes) + len(result.ways) + len(result.relations)
                
                print(f"    Found {total_count} amenities/buildings within {radius}m")
                
                if total_count < min_amenities:
                    raise ValidationError(
                        "No such possible business places present in the area.",
                        "ghost_town"
                    )
                
                print(f"    Area has sufficient development ({total_count} features)")
                return {
                    'valid': True,
                    'amenity_count': total_count,
                    'message': f"Found {total_count} amenities/buildings in the area"
                }
                
            except overpy.exception.OverpassTooManyRequests:
                print(f"    Rate limited on {endpoint}, trying next...")
                time.sleep(0.5)
                continue
            except overpy.exception.OverpassGatewayTimeout:
                print(f"    Timeout on {endpoint}, trying next...")
                continue
            except ValidationError:
                raise
            except Exception as e:
                print(f"    Error on {endpoint}: {e}")
                continue
        
        # If all endpoints fail, be strict
        raise ValidationError(
            "Unable to verify area viability. Please try again or select a different location.",
            "api_error"
        )
        
    except ValidationError:
        raise
    except Exception as e:
        print(f"    Area viability check error: {e}")
        raise ValidationError(
            "Unable to verify area viability. Please try again.",
            "api_error"
        )


def check_road_quality(lat: float, lng: float, business_type: str, radius: int = 50) -> Dict:
    """
    Step C: Road Quality Check - For heavy logistics businesses.
    
    Args:
        lat: Latitude of the location
        lng: Longitude of the location
        business_type: Type of business being analyzed
        radius: Search radius for road check in meters (default: 50m)
        
    Returns:
        Dict with 'valid', 'road_type', 'message'
        
    Raises:
        ValidationError: If road infrastructure is insufficient for business type
    """
    # Only check for heavy logistics businesses
    business_lower = business_type.lower().replace('-', '_').replace(' ', '_')
    
    is_heavy_logistics = any(
        heavy in business_lower 
        for heavy in HEAVY_LOGISTICS_BUSINESSES
    )
    
    if not is_heavy_logistics:
        print(f" Road quality check not required for {business_type}")
        return {
            'valid': True,
            'road_type': 'any',
            'message': 'Road quality check not required for this business type'
        }
    
    print(f" Checking road quality for heavy logistics business...")
    
    try:
        query = f"""
        [out:json][timeout:10];
        way["highway"](around:{radius},{lat},{lng});
        out body;
        """
        
        for endpoint in OVERPASS_ENDPOINTS:
            try:
                api = overpy.Overpass(url=endpoint)
                result = api.query(query)
                
                if not result.ways:
                    raise ValidationError(
                        "Road infrastructure is insufficient for this business type. No roads found nearby.",
                        "road_quality"
                    )
                
                # Check road types
                road_types = []
                for way in result.ways:
                    highway_type = way.tags.get('highway', 'unknown')
                    road_types.append(highway_type)
                
                # Check if ALL nearby roads are insufficient
                has_suitable_road = any(
                    rt not in INSUFFICIENT_ROAD_TYPES 
                    for rt in road_types
                )
                
                print(f"    Road types found: {set(road_types)}")
                
                if not has_suitable_road:
                    raise ValidationError(
                        f"Road infrastructure (Alleyway/Footpath) is insufficient for this business type. Found: {', '.join(set(road_types))}",
                        "road_quality"
                    )
                
                print(f"    Road quality is sufficient")
                return {
                    'valid': True,
                    'road_type': road_types[0] if road_types else 'unknown',
                    'message': f"Road infrastructure is suitable: {road_types[0]}"
                }
                
            except overpy.exception.OverpassTooManyRequests:
                time.sleep(0.5)
                continue
            except ValidationError:
                raise
            except Exception as e:
                print(f"    Error on {endpoint}: {e}")
                continue
        
        # If all endpoints fail for heavy logistics, be strict
        raise ValidationError(
            "Unable to verify road quality for heavy logistics business.",
            "verification_failed"
        )
        
    except ValidationError:
        raise
    except Exception as e:
        print(f"    Road quality check error: {e}")
        raise ValidationError(
            "Unable to verify road quality. Please try a different location.",
            "verification_failed"
        )


def validate_location(lat: float, lng: float, business_type: str) -> Dict:
    """
    Master validation function - validates location for business analysis.
    DEPRECATED: Use validate_area() for area-based validation.
    
    Performs four validation checks in order:
    0. Water Body Check (NEW - detect ocean/lake/river)
    1. Roadway Access Check (LatLong API + Overpass fallback)
    2. Ghost Town Check (Overpass API)
    3. Road Quality Check (for heavy logistics businesses)
    
    Args:
        lat: Latitude of the location
        lng: Longitude of the location  
        business_type: Type of business being analyzed
        
    Returns:
        Dict with validation results
        
    Raises:
        ValidationError: If any validation check fails
    """
    print(f"\n{'='*60}")
    print(f" LOCATION VALIDATION")
    print(f"   Coordinates: ({lat}, {lng})")
    print(f"   Business Type: {business_type}")
    print(f"{'='*60}")
    
    validation_result = {
        'valid': True,
        'snapped_location': {'lat': lat, 'lng': lng},
        'checks': {},
        'message': 'Location validated successfully'
    }
    
    # Step 0: Water Body Check (FIRST - most critical for oceans)
    print("\n Step 0: Checking for water bodies...")
    try:
        water_result = check_water_body(lat, lng)
        validation_result['checks']['water_body'] = water_result
    except ValidationError as e:
        print(f"    FAILED: {e.message}")
        raise
    
    # Step A: Roadway Access Check
    print("\n Step A: Checking roadway access...")
    try:
        roadway_result = check_roadway_access(lat, lng)
        validation_result['checks']['roadway_access'] = roadway_result
        
        # Update to snapped coordinates if available
        if roadway_result.get('snapped_lat') and roadway_result.get('snapped_lng'):
            validation_result['snapped_location'] = {
                'lat': roadway_result['snapped_lat'],
                'lng': roadway_result['snapped_lng']
            }
    except ValidationError as e:
        print(f"    FAILED: {e.message}")
        raise
    
    # Step B: Ghost Town Check
    print("\n Step B: Checking area viability...")
    try:
        viability_result = check_area_viability(lat, lng)
        validation_result['checks']['area_viability'] = viability_result
    except ValidationError as e:
        print(f"    FAILED: {e.message}")
        raise
    
    # Step C: Road Quality Check (for heavy logistics)
    print("\n Step C: Checking road quality...")
    try:
        quality_result = check_road_quality(lat, lng, business_type)
        validation_result['checks']['road_quality'] = quality_result
    except ValidationError as e:
        print(f"    FAILED: {e.message}")
        raise
    
    print(f"\n{'='*60}")
    print(" ALL VALIDATION CHECKS PASSED!")
    print(f"{'='*60}\n")
    
    return validation_result


def validate_area(center_lat: float, center_lng: float, radius: int, business_type: str) -> Dict:
    """
    Area-based validation - validates the entire radius area, not just the center.
    This is the NEW recommended validation function.
    
    If the center is in water or lacks infrastructure, this function will
    search for the best usable land point within the radius and use that
    for subsequent validation.
    
    Args:
        center_lat: Center latitude of the selected area
        center_lng: Center longitude of the selected area
        radius: Search radius in meters
        business_type: Type of business being analyzed
        
    Returns:
        Dict with validation results including 'analysis_point' for the best location
        
    Raises:
        ValidationError: If no valid location found within the radius
    """
    print(f"\n{'='*60}")
    print(f" AREA-BASED VALIDATION")
    print(f"   Center: ({center_lat}, {center_lng})")
    print(f"   Radius: {radius}m")
    print(f"   Business Type: {business_type}")
    print(f"{'='*60}")
    
    validation_result = {
        'valid': True,
        'center': {'lat': center_lat, 'lng': center_lng},
        'radius': radius,
        'analysis_point': {'lat': center_lat, 'lng': center_lng},
        'snapped_location': {'lat': center_lat, 'lng': center_lng},
        'checks': {},
        'message': 'Area validated successfully'
    }
    
    # Use center point directly for analysis - no water body check needed
    # The roadway and viability checks will handle edge cases
    analysis_lat = center_lat
    analysis_lng = center_lng
    
    print(f"    Using analysis point: ({analysis_lat:.5f}, {analysis_lng:.5f})")
    
    # Step A: Roadway Access Check - check within the entire radius
    print("\n Step A: Checking roadway access within radius...")
    try:
        roadway_result = check_roadway_access(analysis_lat, analysis_lng, max_distance=float(radius))
        validation_result['checks']['roadway_access'] = roadway_result
        
        # Update to snapped coordinates if available
        if roadway_result.get('snapped_lat') and roadway_result.get('snapped_lng'):
            validation_result['snapped_location'] = {
                'lat': roadway_result['snapped_lat'],
                'lng': roadway_result['snapped_lng']
            }
    except ValidationError as e:
        print(f"    FAILED: {e.message}")
        raise
    
    # Step B: Ghost Town Check - check the entire radius from center
    print("\n Step B: Checking area viability...")
    try:
        # Use center and full radius for viability check
        viability_result = check_area_viability(center_lat, center_lng, radius)
        validation_result['checks']['area_viability'] = viability_result
    except ValidationError as e:
        print(f"    FAILED: {e.message}")
        raise
    
    # Step C: Road Quality Check (for heavy logistics) at analysis point
    print("\n Step C: Checking road quality...")
    try:
        quality_result = check_road_quality(analysis_lat, analysis_lng, business_type)
        validation_result['checks']['road_quality'] = quality_result
    except ValidationError as e:
        print(f"    FAILED: {e.message}")
        raise
    
    print(f"\n{'='*60}")
    print(" AREA VALIDATION PASSED!")
    print(f"   Analysis point: ({validation_result['analysis_point']['lat']:.5f}, {validation_result['analysis_point']['lng']:.5f})")
    print(f"{'='*60}\n")
    
    return validation_result


def validate_and_fetch_data(lat: float, lng: float, business_type: str, radius: int = None) -> Tuple[bool, Dict]:
    """
    Master function to validate location and return validation status.
    
    This is the main entry point for location validation before analysis.
    If radius is provided, uses area-based validation. Otherwise falls back to point validation.
    
    Args:
        lat: Latitude of the location (center if radius provided)
        lng: Longitude of the location (center if radius provided)
        business_type: Type of business being analyzed
        radius: Optional search radius in meters for area-based validation
        
    Returns:
        Tuple of (is_valid: bool, result: Dict)
    """
    try:
        if radius and radius > 0:
            # Use area-based validation
            result = validate_area(lat, lng, radius, business_type)
        else:
            # Fall back to point-based validation
            result = validate_location(lat, lng, business_type)
        return True, result
    except ValidationError as e:
        print(f"\n VALIDATION FAILED: {e.message}")
        print(f"   Error Type: {e.error_type}")
        return False, {
            'valid': False,
            'error': e.message,
            'error_type': e.error_type,
            'message': e.message
        }
    except Exception as e:
        print(f"\n UNEXPECTED ERROR: {str(e)}")
        return False, {
            'valid': False,
            'error': str(e),
            'error_type': 'unknown_error',
            'message': f'Validation failed: {str(e)}'
        }
</file>

<file path="backend/utils/score_calculator.py">
"""
Hotspot IQ - Location Analysis & Recommended Spots Calculator
Finds optimal business locations based on competitor density and landmark proximity.
"""

import math
import requests
from typing import Dict, List, Tuple, Optional
from config import LANDMARK_WEIGHTS

# Overpass API endpoints
OVERPASS_ENDPOINTS = [
    "https://overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter"
]


def _is_near_road(lat: float, lng: float, max_distance: float = 300) -> Tuple[bool, Optional[float]]:
    """
    Check if a point is near a road using Overpass API.
    
    Args:
        lat: Latitude
        lng: Longitude
        max_distance: Maximum distance to road in meters
        
    Returns:
        Tuple of (is_near_road, approximate_distance)
    """
    try:
        # Query for roads - use 'out body' to get actual results
        query = f"""
        [out:json][timeout:5];
        (
            way["highway"~"primary|secondary|tertiary|residential|unclassified|service"](around:{max_distance},{lat},{lng});
        );
        out body;
        """
        
        for endpoint in OVERPASS_ENDPOINTS[:1]:  # Just use first endpoint for speed
            try:
                response = requests.post(endpoint, data={'data': query}, timeout=5)
                if response.status_code == 200:
                    data = response.json()
                    elements = data.get('elements', [])
                    road_count = len(elements)
                    if road_count > 0:
                        return True, max_distance / 2  # Approximate distance
                    return False, None
            except Exception as e:
                continue
        # If API fails, assume NOT near road (conservative)
        return False, None
    except:
        return False, None


def haversine_distance(lat1: float, lng1: float, lat2: float, lng2: float) -> float:
    """Calculate distance between two points in meters."""
    R = 6371000  # Earth's radius in meters
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lng2 - lng1)
    a = math.sin(dphi/2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda/2)**2
    return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))


def calculate_grid_scores(
    center_lat: float,
    center_lng: float,
    radius: float,
    competitors: List[Dict],
    landmarks: List[Dict],
    grid_size: int = 10
) -> List[Dict]:
    """
    Analyze the area using a grid and calculate opportunity score for each cell.
    
    Returns a list of grid cells with their scores, sorted by opportunity.
    """
    # Convert radius to lat/lng offsets
    lat_offset_per_m = 1 / 111000
    lng_offset_per_m = 1 / (111000 * math.cos(math.radians(center_lat)))
    
    grid_cells = []
    cell_size = (2 * radius) / grid_size  # Size of each cell in meters
    
    for row in range(grid_size):
        for col in range(grid_size):
            # Calculate cell center coordinates
            cell_lat = center_lat + ((row - grid_size/2 + 0.5) * cell_size * lat_offset_per_m)
            cell_lng = center_lng + ((col - grid_size/2 + 0.5) * cell_size * lng_offset_per_m)
            
            # Check if cell is within the circular radius
            dist_from_center = haversine_distance(center_lat, center_lng, cell_lat, cell_lng)
            if dist_from_center > radius:
                continue
            
            # Count competitors within proximity of this cell (300m radius)
            nearby_competitors = 0
            min_competitor_dist = float('inf')
            for comp in competitors:
                comp_dist = haversine_distance(cell_lat, cell_lng, comp.get('lat', 0), comp.get('lng', 0))
                if comp_dist < 300:
                    nearby_competitors += 1
                if comp_dist < min_competitor_dist:
                    min_competitor_dist = comp_dist
            
            # Count landmarks within proximity (500m radius) and calculate footfall score
            nearby_landmarks = []
            footfall_score = 0
            for lm in landmarks:
                lm_dist = haversine_distance(cell_lat, cell_lng, lm.get('lat', 0), lm.get('lng', 0))
                if lm_dist < 500:
                    nearby_landmarks.append(lm)
                    # Higher value for closer landmarks
                    proximity_bonus = max(0, (500 - lm_dist) / 500)
                    
                    # Weight by landmark type
                    name = lm.get('name', '').lower()
                    category = lm.get('category', '').lower()
                    
                    if any(kw in name or kw in category for kw in ['metro', 'station', 'railway']):
                        footfall_score += 25 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['mall', 'plaza', 'market']):
                        footfall_score += 20 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['hospital', 'medical', 'clinic']):
                        footfall_score += 15 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['school', 'college', 'university']):
                        footfall_score += 15 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['office', 'corporate', 'tech']):
                        footfall_score += 12 * proximity_bonus
                    elif any(kw in name or kw in category for kw in ['bank', 'atm']):
                        footfall_score += 10 * proximity_bonus
                    else:
                        footfall_score += 5 * proximity_bonus
            
            # Calculate opportunity score: high footfall + low competition = better
            # Competition penalty: more competitors nearby = lower score
            competition_penalty = nearby_competitors * 15
            
            # Distance bonus: if no competitors very close, that's good
            distance_bonus = 0
            if min_competitor_dist > 200:
                distance_bonus = min(30, (min_competitor_dist - 200) / 10)
            
            # Final opportunity score
            opportunity = max(0, footfall_score + distance_bonus - competition_penalty)
            
            grid_cells.append({
                'lat': cell_lat,
                'lng': cell_lng,
                'opportunity_score': round(opportunity, 1),
                'nearby_competitors': nearby_competitors,
                'min_competitor_distance': round(min_competitor_dist) if min_competitor_dist != float('inf') else None,
                'nearby_landmarks': len(nearby_landmarks),
                'footfall_score': round(footfall_score, 1),
                'landmark_names': [lm.get('name', '') for lm in nearby_landmarks[:5]]
            })
    
    # Sort by opportunity score (highest first)
    grid_cells.sort(key=lambda x: x['opportunity_score'], reverse=True)
    
    return grid_cells


def find_recommended_spots(
    center_lat: float,
    center_lng: float,
    radius: float,
    competitors: List[Dict],
    landmarks: List[Dict],
    max_spots: int = 5,
    road_proximity: float = 300  # Maximum distance from road in meters
) -> List[Dict]:
    """
    Find the best spots for setting up a business.
    Only recommends spots that are near roadways (within road_proximity meters).
    
    Returns top spots with explanations.
    """
    # Calculate grid scores
    grid_scores = calculate_grid_scores(
        center_lat, center_lng, radius, 
        competitors, landmarks, 
        grid_size=12  # Higher resolution grid
    )
    
    if not grid_scores:
        return []
    
    # Select top spots that are not too close to each other AND near roads
    recommended = []
    min_spacing = 300  # Minimum distance between recommended spots
    checked_for_roads = 0
    skipped_no_road = 0
    max_road_checks = 50  # Limit API calls (increased to find more valid spots)
    
    print(f"    Filtering spots near roadways (within {road_proximity}m)...")
    
    for cell in grid_scores:
        if len(recommended) >= max_spots:
            break
        
        if checked_for_roads >= max_road_checks:
            print(f"    Reached max road checks ({max_road_checks}), checked {checked_for_roads}, skipped {skipped_no_road} (no road)")
            break  # Stop completely if we hit max checks
            
        # Check if this spot is far enough from already recommended spots
        too_close = False
        for existing in recommended:
            dist = haversine_distance(
                cell['lat'], cell['lng'],
                existing['lat'], existing['lng']
            )
            if dist < min_spacing:
                too_close = True
                break
        
        if too_close:
            continue
        
        # Check if spot is near a road - ALWAYS check, no fallback
        near_road, _ = _is_near_road(cell['lat'], cell['lng'], road_proximity)
        checked_for_roads += 1
        
        if not near_road:
            # Skip spots not near roads
            skipped_no_road += 1
            print(f"       Skipped ({cell['lat']:.5f}, {cell['lng']:.5f}) - no road within {road_proximity}m")
            continue
        
        print(f"       Found spot near road: ({cell['lat']:.5f}, {cell['lng']:.5f})")
        
        # Generate reason for recommendation
        reasons = []
        
        if cell['min_competitor_distance'] and cell['min_competitor_distance'] > 300:
            reasons.append(f"Low competition - nearest competitor {cell['min_competitor_distance']}m away")
        elif cell['nearby_competitors'] == 0:
            reasons.append("No direct competitors in this zone")
        elif cell['nearby_competitors'] <= 2:
            reasons.append(f"Low competition density ({cell['nearby_competitors']} nearby)")
        
        if cell['footfall_score'] >= 30:
            reasons.append("High footfall area")
        elif cell['footfall_score'] >= 15:
            reasons.append("Good footfall potential")
        
        if cell['nearby_landmarks'] >= 3:
            reasons.append(f"Near key landmarks ({cell['nearby_landmarks']} within 500m)")
        
        if cell['landmark_names']:
            top_landmarks = cell['landmark_names'][:3]
            reasons.append(f"Near: {', '.join(top_landmarks)}")
        
        # Add road accessibility note
        reasons.append("Good road accessibility")
        
        # Determine rating based on score
        if cell['opportunity_score'] >= 50:
            rating = 'Excellent'
            rating_color = 'green'
        elif cell['opportunity_score'] >= 30:
            rating = 'Good'
            rating_color = 'cyan'
        elif cell['opportunity_score'] >= 15:
            rating = 'Moderate'
            rating_color = 'yellow'
        else:
            rating = 'Fair'
            rating_color = 'orange'
        
        recommended.append({
            'lat': round(cell['lat'], 6),
            'lng': round(cell['lng'], 6),
            'score': cell['opportunity_score'],
            'rating': rating,
            'rating_color': rating_color,
            'reasons': reasons if reasons else ['Balanced location with growth potential'],
            'nearby_competitors': cell['nearby_competitors'],
            'nearby_landmarks': cell['nearby_landmarks'],
            'min_competitor_distance': cell['min_competitor_distance']
        })
    
    # Number the spots
    for i, spot in enumerate(recommended, 1):
        spot['rank'] = i
    
    return recommended


def calculate_footfall_proxy(landmarks: Dict, competitors: Dict) -> float:
    """
    Calculate footfall proxy score based on nearby landmarks.
    
    Higher footfall areas have more transit points, offices, and commercial zones.
    
    Args:
        landmarks: Dict with landmark data by category
        competitors: Dict with competitor data
        
    Returns:
        Footfall proxy score (0-100)
    """
    score = 0
    max_score = 100
    
    by_category = landmarks.get('by_category', {})
    all_pois = landmarks.get('all_pois', [])
    total_count = landmarks.get('total_count', 0)
    
    # If we have specific categories, use them for detailed scoring
    # Transit points are strong footfall indicators
    transit_score = 0
    if 'metro_station' in by_category:
        transit_score += min(by_category['metro_station'].get('count', 0) * 20, 40)
    if 'bus_stop' in by_category:
        transit_score += min(by_category['bus_stop'].get('count', 0) * 5, 15)
    
    score += transit_score
    
    # Commercial zones indicate high activity
    commercial_score = 0
    if 'mall' in by_category:
        commercial_score += min(by_category['mall'].get('count', 0) * 15, 25)
    if 'office' in by_category:
        commercial_score += min(by_category['office'].get('count', 0) * 10, 20)
    
    score += commercial_score
    
    # Educational institutions bring regular footfall
    education_score = 0
    if 'school' in by_category:
        education_score += min(by_category['school'].get('count', 0) * 5, 10)
    if 'college' in by_category:
        education_score += min(by_category['college'].get('count', 0) * 8, 15)
    
    score += education_score
    
    # Residential areas mean local customers
    if 'residential' in by_category:
        score += min(by_category['residential'].get('count', 0) * 5, 15)
    
    # If no specific categories matched, use total nearby landmarks as proxy
    # More landmarks nearby = more activity = higher footfall
    if score == 0 and total_count > 0:
        # Use POI names to detect categories
        for poi in all_pois:
            name = poi.get('name', '').lower()
            # Check for high-value landmarks in names
            if any(kw in name for kw in ['metro', 'station', 'railway', 'train']):
                score += 20
            elif any(kw in name for kw in ['mall', 'plaza', 'center', 'centre']):
                score += 15
            elif any(kw in name for kw in ['hospital', 'clinic', 'medical']):
                score += 12
            elif any(kw in name for kw in ['school', 'college', 'university', 'institute']):
                score += 10
            elif any(kw in name for kw in ['office', 'corporate', 'tech', 'park']):
                score += 10
            elif any(kw in name for kw in ['hotel', 'restaurant', 'cafe', 'food']):
                score += 8
            elif any(kw in name for kw in ['temple', 'church', 'mosque', 'gurudwara']):
                score += 5
            else:
                score += 3  # Any landmark is a sign of activity
        
        # Cap the name-based score
        score = min(score, max_score)
    
    return min(score, max_score)


def calculate_landmark_value(landmarks: Dict) -> float:
    """
    Calculate weighted landmark value score.
    
    Different landmarks have different value for businesses.
    
    Args:
        landmarks: Dict with landmark data by category
        
    Returns:
        Landmark value score (0-50)
    """
    score = 0
    max_score = 50
    
    by_category = landmarks.get('by_category', {})
    all_pois = landmarks.get('all_pois', [])
    total_count = landmarks.get('total_count', 0)
    
    for category, data in by_category.items():
        count = data.get('count', 0)
        weight = LANDMARK_WEIGHTS.get(category, 5)
        
        # Diminishing returns for multiple landmarks of same type
        category_score = 0
        for i in range(min(count, 5)):  # Cap at 5 of each type
            category_score += weight * (0.8 ** i)  # Each additional is worth less
        
        score += category_score
    
    # If score is still 0 but we have landmarks, calculate based on POI names
    if score == 0 and total_count > 0:
        for poi in all_pois[:10]:  # Cap at 10 POIs
            name = poi.get('name', '').lower()
            # Assign weights based on landmark name
            if any(kw in name for kw in ['metro', 'station', 'railway']):
                weight = 12
            elif any(kw in name for kw in ['mall', 'plaza', 'market']):
                weight = 10
            elif any(kw in name for kw in ['hospital', 'medical']):
                weight = 8
            elif any(kw in name for kw in ['school', 'college', 'university']):
                weight = 8
            elif any(kw in name for kw in ['hotel', 'restaurant']):
                weight = 6
            elif any(kw in name for kw in ['bank', 'atm']):
                weight = 5
            else:
                weight = 3
            
            score += weight * (0.8 ** all_pois.index(poi))
    
    return min(score, max_score)


def calculate_competitor_density(competitors: Dict, radius: float = 1000) -> float:
    """
    Calculate competitor density factor.
    
    More competitors = higher density = lower score contribution.
    
    Args:
        competitors: Dict with competitor data
        radius: Search radius in meters
        
    Returns:
        Competitor density factor (0+, higher is worse)
    """
    count = competitors.get('count', 0)
    
    # Normalize by area (competitors per square km)
    area_sq_km = 3.14159 * (radius / 1000) ** 2
    density = count / max(area_sq_km, 0.1)
    
    return density


def calculate_opportunity_score(
    footfall: float,
    landmark_value: float,
    competitor_density: float
) -> int:
    """
    Calculate the final Opportunity Score.
    
    Formula: (Footfall  Landmark Value) / (Competitor Density + 1)
    Normalized to 0-100 scale.
    
    Args:
        footfall: Footfall proxy score (0-100)
        landmark_value: Landmark value score (0-50)
        competitor_density: Competitor density factor
        
    Returns:
        Opportunity Score (0-100)
    """
    # Calculate raw score
    numerator = footfall * (landmark_value / 50)  # Normalize landmark to 0-1
    denominator = competitor_density + 1  # Add 1 to avoid division by zero
    
    raw_score = numerator / denominator
    
    # Normalize to 0-100
    # Assuming max raw score is around 100 (high footfall, no competition)
    normalized_score = min(raw_score, 100)
    
    return round(normalized_score)


def get_score_interpretation(score: int) -> Dict:
    """
    Get human-readable interpretation of the opportunity score.
    
    Args:
        score: Opportunity score (0-100)
        
    Returns:
        Dict with category, color, recommendation
    """
    if score >= 70:
        return {
            'category': 'Prime Location',
            'color': 'green',
            'emoji': '',
            'recommendation': 'Excellent opportunity! This location shows strong potential with good footfall and manageable competition. Move fast before others discover it.',
            'action': 'Move fast!'
        }
    elif score >= 40:
        return {
            'category': 'Moderate Potential',
            'color': 'yellow',
            'emoji': '',
            'recommendation': 'This location has potential but may require differentiation. Consider your unique value proposition and marketing strategy.',
            'action': 'Needs differentiation'
        }
    else:
        return {
            'category': 'High Risk',
            'color': 'red',
            'emoji': '',
            'recommendation': 'This location shows challenging conditions with high competition or low footfall. Consider alternative locations or a very niche strategy.',
            'action': 'Reconsider or pivot'
        }


def analyze_location(
    landmarks: Dict,
    competitors: Dict,
    business_type: str
) -> Dict:
    """
    Perform complete location analysis.
    
    Args:
        landmarks: Landmark data from LatLong service
        competitors: Competitor data from LatLong service
        business_type: Type of business being analyzed
        
    Returns:
        Complete analysis results
    """
    # Calculate component scores
    footfall = calculate_footfall_proxy(landmarks, competitors)
    landmark_value = calculate_landmark_value(landmarks)
    competitor_density = calculate_competitor_density(competitors)
    
    # Calculate final score
    opportunity_score = calculate_opportunity_score(
        footfall,
        landmark_value,
        competitor_density
    )
    
    # Get interpretation
    interpretation = get_score_interpretation(opportunity_score)
    
    return {
        'opportunity_score': opportunity_score,
        'interpretation': interpretation,
        'breakdown': {
            'footfall_proxy': round(footfall, 1),
            'landmark_value': round(landmark_value, 1),
            'competitor_density': round(competitor_density, 2),
            'competitor_count': competitors.get('count', 0)
        },
        'landmarks_summary': {
            category: data.get('count', 0)
            for category, data in landmarks.get('by_category', {}).items()
        },
        'competitors': competitors
    }
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hotspot IQ - Location Intelligence</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  </head>
  <body class="bg-canvas-deep text-slate-50 font-sans">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/src/components/Dashboard/Charts/CompetitorChart.jsx">
/**
 * Competitor Chart Component
 * Bar chart showing competitor distribution by category
 */

import { useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  Cell,
} from 'recharts';

// Category colors
const CATEGORY_COLORS = {
  cafe: '#10b981',
  restaurant: '#f59e0b',
  retail: '#3b82f6',
  gym: '#8b5cf6',
  pharmacy: '#ec4899',
  salon: '#14b8a6',
  electronics: '#6366f1',
  clothing: '#f43f5e',
  default: '#64748b',
};

// Custom tooltip
const CustomTooltip = ({ active, payload }) => {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;
  return (
    <div className="bg-canvas-base border border-surface-border rounded-lg p-3 shadow-glass">
      <p className="text-slate-200 font-medium">{data.name}</p>
      <p className="text-sm text-slate-400">
        <span className="text-destructive-glow font-semibold">{data.count}</span> competitors
      </p>
    </div>
  );
};

export default function CompetitorChart({ competitors = [], isLoading }) {
  // Safely convert to array
  const competitorList = Array.isArray(competitors) ? competitors : [];
  
  // Group competitors by category
  const chartData = useMemo(() => {
    const grouped = competitorList.reduce((acc, competitor) => {
      const category = competitor.category?.toLowerCase() || 'other';
      if (!acc[category]) {
        acc[category] = { name: category, count: 0 };
      }
      acc[category].count++;
      return acc;
    }, {});

    return Object.values(grouped)
      .sort((a, b) => b.count - a.count)
      .slice(0, 6); // Top 6 categories
  }, [competitorList]);

  if (isLoading) {
    return (
      <div className="glass-panel p-4">
        <div className="h-4 bg-slate-700 rounded w-32 mb-4 animate-pulse" />
        <div className="h-48 bg-slate-700/30 rounded animate-pulse" />
      </div>
    );
  }

  if (competitorList.length === 0) {
    return (
      <div className="glass-panel p-4">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/store.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
          Competitor Distribution
        </h3>
        <div className="h-48 flex items-center justify-center text-slate-500">
          <div className="text-center">
            <img src="/icons/star.svg" alt="" className="w-8 h-8 mx-auto mb-2" style={{ filter: 'invert(74%) sepia(52%) saturate(579%) hue-rotate(93deg) brightness(95%) contrast(88%)' }} />
            <p>No competitors to show</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="glass-panel p-4">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <img src="/icons/store.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
        Competitor Distribution
      </h3>
      
      <div className="h-48">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            layout="vertical"
            margin={{ top: 0, right: 0, bottom: 0, left: 0 }}
          >
            <XAxis 
              type="number" 
              hide 
              domain={[0, 'dataMax + 1']}
            />
            <YAxis
              type="category"
              dataKey="name"
              width={80}
              tick={{ fill: '#94a3b8', fontSize: 12 }}
              axisLine={false}
              tickLine={false}
              tickFormatter={(value) => 
                value.charAt(0).toUpperCase() + value.slice(1)
              }
            />
            <Tooltip content={<CustomTooltip />} cursor={false} />
            <Bar
              dataKey="count"
              radius={[0, 4, 4, 0]}
              maxBarSize={24}
            >
              {chartData.map((entry, index) => (
                <Cell
                  key={`cell-${index}`}
                  fill={CATEGORY_COLORS[entry.name] || CATEGORY_COLORS.default}
                  fillOpacity={0.8}
                />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </div>
      
      {/* Legend */}
      <div className="flex flex-wrap gap-2 mt-3 pt-3 border-t border-surface-border">
        {chartData.map((item) => (
          <div key={item.name} className="flex items-center gap-1.5 text-xs">
            <div
              className="w-2.5 h-2.5 rounded-sm"
              style={{ backgroundColor: CATEGORY_COLORS[item.name] || CATEGORY_COLORS.default }}
            />
            <span className="text-slate-500 capitalize">{item.name}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/Charts/LandmarkRadar.jsx">
/**
 * Landmark Radar Chart Component
 * Radar chart showing landmark category distribution
 */

import { useMemo } from 'react';
import {
  RadarChart,
  PolarGrid,
  PolarAngleAxis,
  PolarRadiusAxis,
  Radar,
  ResponsiveContainer,
  Tooltip,
} from 'recharts';

// Category configuration
const CATEGORY_CONFIG = {
  metro_station: { label: 'Metro', maxScore: 5 },
  bus_stop: { label: 'Bus', maxScore: 10 },
  school: { label: 'School', maxScore: 8 },
  college: { label: 'College', maxScore: 5 },
  hospital: { label: 'Hospital', maxScore: 5 },
  mall: { label: 'Mall', maxScore: 3 },
  office: { label: 'Office', maxScore: 10 },
  residential: { label: 'Residential', maxScore: 15 },
  temple: { label: 'Temple', maxScore: 5 },
  park: { label: 'Park', maxScore: 5 },
};

// Custom tooltip
const CustomTooltip = ({ active, payload }) => {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;
  return (
    <div className="bg-canvas-base border border-surface-border rounded-lg p-3 shadow-glass">
      <p className="text-slate-200 font-medium">{data.fullLabel}</p>
      <p className="text-sm text-slate-400">
        <span className="text-primary-glow font-semibold">{data.count}</span> nearby
      </p>
    </div>
  );
};

export default function LandmarkRadar({ landmarks = [], isLoading }) {
  // Safely convert to array
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  
  // Process landmarks into radar data
  const chartData = useMemo(() => {
    // Count landmarks by category
    const counts = landmarkList.reduce((acc, landmark) => {
      const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'other';
      acc[category] = (acc[category] || 0) + 1;
      return acc;
    }, {});

    // Convert to chart format with normalized values
    return Object.entries(CATEGORY_CONFIG).map(([key, config]) => {
      const count = counts[key] || 0;
      const normalized = Math.min(100, (count / config.maxScore) * 100);
      return {
        category: config.label,
        fullLabel: config.label,
        value: normalized,
        count,
      };
    });
  }, [landmarkList]);

  if (isLoading) {
    return (
      <div className="glass-panel p-4">
        <div className="h-4 bg-slate-700 rounded w-32 mb-4 animate-pulse" />
        <div className="h-64 bg-slate-700/30 rounded-full animate-pulse mx-auto w-64" />
      </div>
    );
  }

  if (landmarkList.length === 0) {
    return (
      <div className="glass-panel p-4">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Landmark Coverage
        </h3>
        <div className="h-64 flex items-center justify-center text-slate-500">
          <div className="text-center">
            <img src="/icons/marker.svg" alt="" className="w-8 h-8 mx-auto mb-2 opacity-50" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
            <p>No landmarks detected</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="glass-panel p-4">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <img src="/icons/star.svg" alt="" className="w-4 h-4" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
        Landmark Coverage
      </h3>
      
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <RadarChart data={chartData} margin={{ top: 20, right: 30, bottom: 20, left: 30 }}>
            <PolarGrid 
              stroke="#334155" 
              strokeOpacity={0.5}
            />
            <PolarAngleAxis
              dataKey="category"
              tick={{ fill: '#94a3b8', fontSize: 11 }}
              tickLine={false}
            />
            <PolarRadiusAxis
              angle={90}
              domain={[0, 100]}
              tick={false}
              axisLine={false}
            />
            <Tooltip content={<CustomTooltip />} />
            <Radar
              name="Coverage"
              dataKey="value"
              stroke="#10b981"
              fill="#10b981"
              fillOpacity={0.3}
              strokeWidth={2}
            />
          </RadarChart>
        </ResponsiveContainer>
      </div>
      
      {/* Summary */}
      <div className="mt-3 pt-3 border-t border-surface-border">
        <div className="flex items-center justify-between text-xs">
          <span className="text-slate-500">Total landmarks detected</span>
          <span className="text-primary-glow font-semibold">{landmarkList.length}</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/index.js">
export { default as ScoreCard } from './ScoreCard';
export { default as CompetitorCard } from './CompetitorCard';
export { default as LandmarksCard } from './LandmarksCard';
export { default as AnalysisPanel } from './AnalysisPanel';
export { default as MetricsGrid } from './MetricsGrid';
export { default as LoadingProgress } from './LoadingProgress';
export { default as RecommendedSpotsCard } from './RecommendedSpotsCard';
export * from './Charts';
</file>

<file path="frontend/src/components/Dashboard/LoadingProgress.jsx">
/**
 * LoadingProgress Component - Compact Top-Right Loader
 * Glass-morphic floating card showing dynamic step-by-step progress
 */

// Define all analysis steps in order
const ANALYSIS_STEPS = [
  { id: 'validation', label: 'Validating location', icon: '' },
  { id: 'boundary', label: 'Area boundary loaded', icon: '' },
  { id: 'analysis', label: 'Analyzing location', icon: '' },
  { id: 'competitors', label: 'Competitors found', icon: '' },
  { id: 'landmarks', label: 'Landmarks identified', icon: '' },
  { id: 'digipin', label: 'Location code retrieved', icon: '' },
  { id: 'spots', label: 'Optimal spots found', icon: '' },
];

// Get step index for comparison
const getStepIndex = (stepId) => {
  const index = ANALYSIS_STEPS.findIndex(s => s.id === stepId);
  return index === -1 ? -1 : index;
};

export default function LoadingProgress({ status, isLoading }) {
  if (!isLoading && status.step === '') return null;

  const { step, message, progress, details } = status;

  // Don't render if complete and not loading
  if (step === 'complete' && !isLoading) return null;

  const currentStepIndex = getStepIndex(step);

  return (
    <div className="fixed top-6 right-6 z-50 animate-fadeIn">
      <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 shadow-2xl shadow-black/30 min-w-[300px] max-w-[340px]">
        {/* Header with spinner */}
        <div className="flex items-center gap-3 mb-3">
          {/* Spinning Emerald Ring */}
          {isLoading && step !== 'complete' && step !== 'error' && (
            <div className="relative w-10 h-10 flex-shrink-0">
              <div className="absolute inset-0 rounded-full border-2 border-emerald-500/20" />
              <div className="absolute inset-0 rounded-full border-2 border-transparent border-t-emerald-400 animate-spin" />
              <div className="absolute inset-2 rounded-full bg-emerald-500/10 flex items-center justify-center">
                <div className="w-2 h-2 rounded-full bg-emerald-400 animate-pulse" />
              </div>
            </div>
          )}
          
          {/* Completion icon */}
          {step === 'complete' && (
            <div className="w-10 h-10 rounded-full bg-emerald-500/20 border border-emerald-500/30 flex items-center justify-center flex-shrink-0">
              <svg className="w-5 h-5 text-emerald-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            </div>
          )}
          
          {/* Error icon */}
          {step === 'error' && (
            <div className="w-10 h-10 rounded-full bg-rose-500/20 border border-rose-500/30 flex items-center justify-center flex-shrink-0">
              <svg className="w-5 h-5 text-rose-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </div>
          )}

          {/* Status text */}
          <div className="flex-1 min-w-0">
            <p className="text-sm font-medium text-white truncate">
              {step === 'complete' ? 'Analysis Complete!' : step === 'error' ? 'Analysis Failed' : 'Processing...'}
            </p>
            <p className="text-xs text-slate-400 truncate">{message}</p>
          </div>

          {/* Progress percentage */}
          <div className="text-right flex-shrink-0">
            <span className="text-lg font-bold text-emerald-400">{progress}%</span>
          </div>
        </div>

        {/* Progress Bar */}
        <div className="h-1.5 bg-slate-800 rounded-full overflow-hidden mb-3">
          <div 
            className="h-full bg-gradient-to-r from-emerald-500 via-cyan-400 to-emerald-500 transition-all duration-500 ease-out rounded-full"
            style={{ width: `${progress}%` }}
          />
        </div>

        {/* Step-by-step checklist */}
        <div className="space-y-1.5 max-h-[200px] overflow-y-auto">
          {ANALYSIS_STEPS.map((analysisStep, index) => {
            const stepIndex = getStepIndex(analysisStep.id);
            const isCompleted = currentStepIndex > stepIndex || step === 'complete';
            const isCurrent = currentStepIndex === stepIndex && step !== 'complete' && step !== 'error';
            const isPending = currentStepIndex < stepIndex && step !== 'complete';
            
            // Get dynamic detail from the details array for completed steps
            const detail = details.find(d => d.includes(analysisStep.icon));
            const displayLabel = detail ? detail.replace(analysisStep.icon, '').trim() : analysisStep.label;
            
            return (
              <div 
                key={analysisStep.id} 
                className={`flex items-center gap-2.5 text-xs py-1 px-2 rounded-lg transition-all duration-300 ${
                  isCompleted ? 'bg-emerald-500/10 text-emerald-400' :
                  isCurrent ? 'bg-cyan-500/10 text-cyan-400' :
                  'bg-transparent text-slate-500'
                }`}
              >
                {/* Status indicator */}
                <div className="flex-shrink-0 w-5 h-5 flex items-center justify-center">
                  {isCompleted ? (
                    <div className="w-4 h-4 rounded-full bg-emerald-500/30 border border-emerald-400/50 flex items-center justify-center">
                      <svg className="w-2.5 h-2.5 text-emerald-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
                      </svg>
                    </div>
                  ) : isCurrent ? (
                    <div className="w-4 h-4 rounded-full border-2 border-cyan-400/50 border-t-cyan-400 animate-spin" />
                  ) : (
                    <div className="w-3 h-3 rounded-full border border-slate-600 bg-slate-800/50" />
                  )}
                </div>
                
                {/* Icon */}
                <span className="flex-shrink-0">{analysisStep.icon}</span>
                
                {/* Label */}
                <span className={`truncate ${isCompleted ? 'font-medium' : ''}`}>
                  {displayLabel}
                </span>
              </div>
            );
          })}
        </div>

        {/* Completion hint */}
        {step === 'complete' && (
          <p className="text-xs text-emerald-400/80 mt-3 pt-2 border-t border-white/5">
             Click anywhere to view detailed results 
          </p>
        )}
        
        {/* Error hint */}
        {step === 'error' && (
          <p className="text-xs text-rose-400/80 mt-3 pt-2 border-t border-white/5">
             Please try again with a different location.
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/MetricsGrid.jsx">
/**
 * Metrics Grid Component
 * Displays key metrics in a compact grid layout
 */

// Icon paths for metrics
const METRIC_ICONS = {
  footfall: '/icons/marker.svg',
  competitors: '/icons/store.svg',
  landmarks: '/icons/building.svg',
  density: '/icons/marker.svg',
};

// Icon color filters
const ICON_FILTERS = {
  primary: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)',
  destructive: 'invert(42%) sepia(93%) saturate(1352%) hue-rotate(326deg) brightness(99%) contrast(97%)',
  accent: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)',
  warning: 'invert(74%) sepia(57%) saturate(579%) hue-rotate(10deg) brightness(103%) contrast(101%)',
};

export default function MetricsGrid({ analysis, isLoading }) {
  const metrics = [
    {
      id: 'footfall',
      label: 'Footfall Index',
      value: analysis?.footfall_index || 0,
      max: 100,
      icon: METRIC_ICONS.footfall,
      color: 'primary',
      description: 'Estimated foot traffic potential',
    },
    {
      id: 'competitors',
      label: 'Competitors',
      value: analysis?.competitors?.length || 0,
      suffix: ' nearby',
      icon: METRIC_ICONS.competitors,
      color: 'destructive',
      description: 'Same category businesses',
    },
    {
      id: 'landmarks',
      label: 'Landmarks',
      value: analysis?.landmarks?.length || 0,
      suffix: ' found',
      icon: METRIC_ICONS.landmarks,
      color: 'accent',
      description: 'Key locations nearby',
    },
    {
      id: 'density',
      label: 'Competition Density',
      value: analysis?.competitor_density?.toFixed(1) || '0.0',
      suffix: '/km',
      icon: METRIC_ICONS.density,
      color: 'warning',
      description: 'Competitors per square km',
    },
  ];

  const getColorClasses = (color) => {
    const colors = {
      primary: 'text-primary-glow bg-primary-glow/10 border-primary-glow/30',
      destructive: 'text-destructive-glow bg-destructive-glow/10 border-destructive-glow/30',
      accent: 'text-accent-glow bg-accent-glow/10 border-accent-glow/30',
      warning: 'text-warning-glow bg-warning-glow/10 border-warning-glow/30',
    };
    return colors[color] || colors.primary;
  };

  if (isLoading) {
    return (
      <div className="grid grid-cols-2 gap-3">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="glass-card p-4 animate-pulse">
            <div className="flex items-center gap-2 mb-2">
              <div className="w-8 h-8 bg-slate-700 rounded-lg" />
              <div className="h-4 bg-slate-700 rounded w-20" />
            </div>
            <div className="h-6 bg-slate-700 rounded w-16 mb-1" />
            <div className="h-3 bg-slate-700/50 rounded w-24" />
          </div>
        ))}
      </div>
    );
  }

  return (
    <div className="grid grid-cols-2 gap-3">
      {metrics.map((metric) => (
        <div
          key={metric.id}
          className="glass-card p-4 hover:bg-surface-elevated transition-colors group"
        >
          {/* Header */}
          <div className="flex items-center gap-2 mb-2">
            <div className={`w-8 h-8 rounded-lg flex items-center justify-center border ${getColorClasses(metric.color)}`}>
              <img 
                src={metric.icon} 
                alt="" 
                className="w-5 h-5"
                style={{ filter: ICON_FILTERS[metric.color] }}
              />
            </div>
            <span className="text-xs text-slate-500 font-medium uppercase tracking-wide">
              {metric.label}
            </span>
          </div>
          
          {/* Value */}
          <div className="flex items-baseline gap-1">
            <span className={`text-2xl font-bold ${getColorClasses(metric.color).split(' ')[0]}`}>
              {metric.value}
            </span>
            {metric.suffix && (
              <span className="text-sm text-slate-500">{metric.suffix}</span>
            )}
            {metric.max && (
              <span className="text-sm text-slate-600">/{metric.max}</span>
            )}
          </div>
          
          {/* Description (on hover) */}
          <p className="text-xs text-slate-600 mt-1 group-hover:text-slate-500 transition-colors">
            {metric.description}
          </p>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/RecommendedSpotsCard.jsx">
/**
 * Recommended Spots Card Component
 * Displays optimal locations for setting up a business based on analysis
 */

import { useState } from 'react';

// Rating badge component
const RatingBadge = ({ rating, color }) => {
  const colorClasses = {
    green: 'bg-emerald-500/20 text-emerald-400 border-emerald-500/30',
    cyan: 'bg-cyan-500/20 text-cyan-400 border-cyan-500/30',
    yellow: 'bg-amber-500/20 text-amber-400 border-amber-500/30',
    orange: 'bg-orange-500/20 text-orange-400 border-orange-500/30',
  };
  
  return (
    <span className={`px-2 py-0.5 text-xs font-medium rounded-full border ${colorClasses[color] || colorClasses.cyan}`}>
      {rating}
    </span>
  );
};

// Individual spot card
const SpotItem = ({ spot, index, isExpanded, onToggle, onViewOnMap }) => {
  const rankColors = {
    1: 'from-emerald-500 to-emerald-600',
    2: 'from-cyan-500 to-cyan-600',
    3: 'from-blue-500 to-blue-600',
    4: 'from-purple-500 to-purple-600',
    5: 'from-slate-500 to-slate-600',
  };

  return (
    <div 
      className={`rounded-lg border transition-all duration-200 ${
        isExpanded 
          ? 'bg-surface-elevated border-primary-glow/30' 
          : 'bg-surface-secondary border-surface-border hover:border-slate-600'
      }`}
    >
      {/* Header - always visible */}
      <button
        onClick={onToggle}
        className="w-full flex items-center gap-3 p-3 text-left"
      >
        {/* Rank badge */}
        <div className={`w-8 h-8 rounded-lg bg-gradient-to-br ${rankColors[spot.rank] || rankColors[5]} flex items-center justify-center text-white font-bold text-sm shadow-lg`}>
          {spot.rank}
        </div>
        
        {/* Location info */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-slate-200 font-medium">Spot #{spot.rank}</span>
            <RatingBadge rating={spot.rating} color={spot.rating_color} />
          </div>
          <p className="text-xs text-slate-500 font-mono truncate">
            {spot.lat}, {spot.lng}
          </p>
        </div>
        
        {/* Score */}
        <div className="text-right">
          <div className="text-lg font-bold text-primary-glow">{Math.round(spot.score)}</div>
          <div className="text-[10px] text-slate-500 uppercase tracking-wide">Score</div>
        </div>
        
        {/* Expand indicator */}
        <svg 
          className={`w-4 h-4 text-slate-500 transition-transform ${isExpanded ? 'rotate-180' : ''}`} 
          fill="none" 
          viewBox="0 0 24 24" 
          stroke="currentColor"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      
      {/* Expanded content */}
      {isExpanded && (
        <div className="px-3 pb-3 space-y-3 border-t border-surface-border pt-3">
          {/* Stats row */}
          <div className="grid grid-cols-2 gap-2">
            <div className="bg-surface-secondary rounded-lg p-2 text-center">
              <div className="text-rose-400 font-semibold">{spot.nearby_competitors}</div>
              <div className="text-[10px] text-slate-500">Competitors Nearby</div>
            </div>
            <div className="bg-surface-secondary rounded-lg p-2 text-center">
              <div className="text-cyan-400 font-semibold">{spot.nearby_landmarks}</div>
              <div className="text-[10px] text-slate-500">Landmarks</div>
            </div>
          </div>
          
          {/* Distance to nearest competitor */}
          {spot.min_competitor_distance && (
            <div className="flex items-center gap-2 text-xs">
              <span className="text-slate-500">Nearest competitor:</span>
              <span className={`font-medium ${spot.min_competitor_distance > 300 ? 'text-emerald-400' : 'text-amber-400'}`}>
                {spot.min_competitor_distance}m away
              </span>
            </div>
          )}
          
          {/* Reasons */}
          <div className="space-y-1.5">
            <p className="text-xs text-slate-400 font-medium">Why this spot:</p>
            <ul className="space-y-1">
              {spot.reasons.map((reason, i) => (
                <li key={i} className="flex items-start gap-2 text-xs text-slate-300">
                  <svg className="w-3 h-3 text-emerald-400 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
          
          {/* Action button */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              onViewOnMap(spot);
            }}
            className="w-full py-2 bg-primary-glow/10 hover:bg-primary-glow/20 text-primary-glow text-xs font-medium rounded-lg transition-colors flex items-center justify-center gap-2"
          >
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            View on Map
          </button>
        </div>
      )}
    </div>
  );
};

export default function RecommendedSpotsCard({ spots = [], isLoading, onViewSpot }) {
  const [expandedIndex, setExpandedIndex] = useState(0); // First spot expanded by default

  if (isLoading) {
    return (
      <div className="glass-panel p-5">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Recommended Locations
        </h3>
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="bg-surface-secondary rounded-lg p-4 animate-pulse">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 rounded-lg bg-slate-700" />
                <div className="flex-1">
                  <div className="h-4 bg-slate-700 rounded w-24 mb-2" />
                  <div className="h-3 bg-slate-700/50 rounded w-32" />
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (!spots || spots.length === 0) {
    return (
      <div className="glass-panel p-5">
        <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Recommended Locations
        </h3>
        <div className="text-center py-8">
          <img src="/icons/search.svg" alt="" className="w-12 h-12 mx-auto mb-3 opacity-50" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
          <p className="text-slate-400 text-sm">
            No optimal spots found in this area.
          </p>
          <p className="text-slate-500 text-xs mt-1">
            Try expanding the search radius or selecting a different area.
          </p>
        </div>
      </div>
    );
  }

  const topSpot = spots[0];

  return (
    <div className="glass-panel p-5">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
          Recommended Locations
        </h3>
        <span className="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-xs rounded-full font-medium">
          {spots.length} spots found
        </span>
      </div>
      
      {/* Best spot highlight */}
      {topSpot && (
        <div className="mb-4 p-3 rounded-lg bg-gradient-to-r from-emerald-500/10 to-cyan-500/10 border border-emerald-500/20">
          <div className="flex items-center gap-2 mb-1">
            <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(74%) sepia(52%) saturate(579%) hue-rotate(93deg) brightness(95%) contrast(88%)' }} />
            <span className="text-emerald-400 font-semibold text-sm">Best Location Found</span>
          </div>
          <p className="text-xs text-slate-300">
            {topSpot.reasons[0] || 'Optimal balance of low competition and good footfall'}
          </p>
        </div>
      )}
      
      {/* Spots list */}
      <div className="space-y-2 max-h-[400px] overflow-y-auto custom-scrollbar">
        {spots.map((spot, index) => (
          <SpotItem
            key={`spot-${spot.rank}`}
            spot={spot}
            index={index}
            isExpanded={expandedIndex === index}
            onToggle={() => setExpandedIndex(expandedIndex === index ? -1 : index)}
            onViewOnMap={onViewSpot}
          />
        ))}
      </div>
      
      {/* Legend */}
      <div className="mt-4 pt-3 border-t border-surface-border">
        <p className="text-[10px] text-slate-500 text-center">
          Spots are ranked by opportunity score: low competition + high footfall = better
        </p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/Dashboard/ScoreCard.jsx">
/**
 * Score Card Component
 * Displays the Opportunity Score with a radial progress ring
 */

export default function ScoreCard({ score, label, isLoading }) {
  // Score should be 0-100
  const normalizedScore = Math.min(100, Math.max(0, score || 0));
  
  // Calculate stroke-dasharray for progress ring
  const radius = 45;
  const circumference = 2 * Math.PI * radius;
  const strokeDashoffset = circumference - (normalizedScore / 100) * circumference;
  
  // Determine color based on score
  const getScoreColor = (score) => {
    if (score >= 70) return '#10b981'; // Green - Excellent
    if (score >= 50) return '#06b6d4'; // Cyan - Good
    if (score >= 30) return '#f59e0b'; // Amber - Fair
    return '#f43f5e'; // Rose - Poor
  };
  
  const getScoreLabel = (score) => {
    if (score >= 70) return 'Excellent';
    if (score >= 50) return 'Good';
    if (score >= 30) return 'Fair';
    return 'Poor';
  };
  
  const scoreColor = getScoreColor(normalizedScore);
  const scoreLabel = getScoreLabel(normalizedScore);

  return (
    <div className="glass-panel p-5">
      <h3 className="text-sm font-medium text-slate-400 mb-4 flex items-center gap-2">
        <img src="/icons/star.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
        Opportunity Score
      </h3>
      
      <div className="flex items-center gap-6">
        {/* Radial Progress Ring */}
        <div className="relative w-28 h-28">
          <svg className="w-full h-full transform -rotate-90">
            {/* Background circle */}
            <circle
              cx="56"
              cy="56"
              r={radius}
              stroke="currentColor"
              strokeWidth="8"
              fill="none"
              className="text-slate-700"
            />
            {/* Progress circle */}
            <circle
              cx="56"
              cy="56"
              r={radius}
              stroke={isLoading ? '#475569' : scoreColor}
              strokeWidth="8"
              fill="none"
              strokeLinecap="round"
              strokeDasharray={circumference}
              strokeDashoffset={isLoading ? circumference : strokeDashoffset}
              className="transition-all duration-1000 ease-out"
              style={{
                filter: isLoading ? 'none' : `drop-shadow(0 0 8px ${scoreColor}80)`,
              }}
            />
          </svg>
          
          {/* Center text */}
          <div className="absolute inset-0 flex flex-col items-center justify-center">
            {isLoading ? (
              <div className="w-8 h-8 border-2 border-slate-600 border-t-primary-glow rounded-full animate-spin" />
            ) : (
              <>
                <span 
                  className="text-3xl font-bold transition-colors duration-500"
                  style={{ color: scoreColor }}
                >
                  {normalizedScore}
                </span>
                <span className="text-xs text-slate-500">/100</span>
              </>
            )}
          </div>
        </div>
        
        {/* Score details */}
        <div className="flex-1 space-y-2">
          {isLoading ? (
            <div className="space-y-2">
              <div className="h-5 bg-slate-700 rounded animate-pulse w-24" />
              <div className="h-4 bg-slate-700/50 rounded animate-pulse w-32" />
            </div>
          ) : (
            <>
              <p 
                className="text-lg font-semibold transition-colors duration-500"
                style={{ color: scoreColor }}
              >
                {scoreLabel}
              </p>
              {label && (
                <p className="text-sm text-slate-400">{label}</p>
              )}
            </>
          )}
        </div>
      </div>
      
      {/* Score breakdown hint */}
      {!isLoading && score !== undefined && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <p className="text-xs text-slate-500">
            Based on footfall, competitor density & nearby landmarks
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Filters/ProximityFilters.jsx">
/**
 * Proximity Filters Component
 * Step 2 in the user flow - Select what you want nearby
 */

import { useState } from 'react';
import { PROXIMITY_ICONS } from '../common/Icon';

// Proximity filter options with SVG icons
const PROXIMITY_FILTERS = [
  { id: 'near_metro', label: 'Metro', icon: PROXIMITY_ICONS.near_metro, popular: true },
  { id: 'near_bus', label: 'Bus Stop', icon: PROXIMITY_ICONS.near_bus, popular: false },
  { id: 'near_school', label: 'School', icon: PROXIMITY_ICONS.near_school, popular: false },
  { id: 'near_college', label: 'College', icon: PROXIMITY_ICONS.near_college, popular: true },
  { id: 'near_hospital', label: 'Hospital', icon: PROXIMITY_ICONS.near_hospital, popular: false },
  { id: 'near_mall', label: 'Mall', icon: PROXIMITY_ICONS.near_mall, popular: true },
  { id: 'near_office', label: 'Office/IT', icon: PROXIMITY_ICONS.near_office, popular: true },
  { id: 'near_residential', label: 'Residential', icon: PROXIMITY_ICONS.near_residential, popular: false },
  { id: 'near_temple', label: 'Temple', icon: PROXIMITY_ICONS.near_temple, popular: false },
  { id: 'near_park', label: 'Park', icon: PROXIMITY_ICONS.near_park, popular: false },
  { id: 'near_atm', label: 'ATM/Bank', icon: PROXIMITY_ICONS.near_atm, popular: false },
  { id: 'near_bar', label: 'Bar/Pub', icon: PROXIMITY_ICONS.near_bar, popular: false },
];

export default function ProximityFilters({ value = [], onChange, disabled }) {
  const [showAll, setShowAll] = useState(false);

  const toggleFilter = (filterId) => {
    if (disabled) return;
    
    const newFilters = value.includes(filterId)
      ? value.filter((f) => f !== filterId)
      : [...value, filterId];
    
    onChange(newFilters);
  };

  const selectPopular = () => {
    const popularFilters = PROXIMITY_FILTERS.filter((f) => f.popular).map((f) => f.id);
    onChange(popularFilters);
  };

  const clearAll = () => {
    onChange([]);
  };

  // Show only first 6 filters by default, or all if expanded
  const visibleFilters = showAll ? PROXIMITY_FILTERS : PROXIMITY_FILTERS.slice(0, 6);

  return (
    <div className="space-y-3 relative z-20">
      <div className="flex items-center justify-between">
        <label className="block text-sm font-medium text-slate-400">
          Step 2: What do you want nearby?
        </label>
        <span className="text-xs text-slate-500">
          {value.length} selected
        </span>
      </div>

      {/* Filter Chips Grid */}
      <div className={`grid grid-cols-3 gap-2 ${disabled ? 'opacity-50 pointer-events-none' : ''}`}>
        {visibleFilters.map((filter) => {
          const isActive = value.includes(filter.id);
          return (
            <button
              key={filter.id}
              type="button"
              onClick={() => toggleFilter(filter.id)}
              className={`
                chip flex flex-col items-center justify-center gap-1 py-2
                ${isActive ? 'chip-active' : 'chip-inactive'}
              `}
            >
              <img 
                src={filter.icon} 
                alt="" 
                className="w-5 h-5"
                style={{ filter: isActive 
                  ? 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' 
                  : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)'
                }}
              />
              <span className="text-xs truncate w-full text-center">{filter.label}</span>
            </button>
          );
        })}
      </div>

      {/* Show More / Less Toggle */}
      {PROXIMITY_FILTERS.length > 6 && (
        <button
          type="button"
          onClick={() => setShowAll(!showAll)}
          className="text-xs text-slate-500 hover:text-slate-300 transition-colors"
        >
          {showAll ? ' Show less' : `Show ${PROXIMITY_FILTERS.length - 6} more `}
        </button>
      )}

      {/* Quick Actions */}
      <div className="flex gap-2">
        <button
          type="button"
          onClick={selectPopular}
          disabled={disabled}
          className="flex-1 text-xs py-1.5 px-2 rounded border border-surface-border text-slate-400 hover:text-primary-bright hover:border-primary-glow transition-colors disabled:opacity-50 flex items-center justify-center gap-1"
        >
          <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
          </svg>
          Select Popular
        </button>
        <button
          type="button"
          onClick={clearAll}
          disabled={disabled || value.length === 0}
          className="flex-1 text-xs py-1.5 px-2 rounded border border-surface-border text-slate-400 hover:text-destructive-bright hover:border-destructive-glow transition-colors disabled:opacity-50 flex items-center justify-center gap-1"
        >
          <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
          Clear All
        </button>
      </div>

      {/* Optional hint */}
      <p className="text-xs text-slate-500">
        Optional  Filters affect score calculation
      </p>
    </div>
  );
}
</file>

<file path="frontend/src/components/Map/index.js">
export { default as MapView } from './MapView';
export { default as HeatmapOverlay } from './HeatmapOverlay';
</file>

<file path="backend/services/__init__.py">
"""
Hotspot IQ - Services Package
"""

from .latlong_service import latlong_service, LatLongService
from .competitor_service import (
    get_competitor_count,
    get_competitors_detailed,
    get_available_categories,
    get_cafe_count,
    get_restaurant_count,
    get_gym_count,
    get_pharmacy_count,
)
from .validation_service import (
    validate_location,
    validate_and_fetch_data,
    ValidationError,
    check_roadway_access,
    check_area_viability,
    check_road_quality,
)

__all__ = [
    'latlong_service',
    'LatLongService',
    'get_competitor_count',
    'get_competitors_detailed',
    'get_available_categories',
    'get_cafe_count',
    'get_restaurant_count',
    'get_gym_count',
    'get_pharmacy_count',
    'validate_location',
    'validate_and_fetch_data',
    'ValidationError',
    'check_roadway_access',
    'check_area_viability',
    'check_road_quality',
]
</file>

<file path="frontend/src/components/Dashboard/LandmarksCard.jsx">
/**
 * Landmarks Card Component
 * Displays nearby landmarks grouped by category with footfall indicators
 */

import { useState } from 'react';

// Landmark category icons and weights - using SVG icons
const CATEGORY_CONFIG = {
  metro_station: { icon: '/icons/metro.svg', label: 'Metro Station', weight: 5 },
  metro: { icon: '/icons/metro.svg', label: 'Metro Station', weight: 5 },
  bus_stop: { icon: '/icons/bus.svg', label: 'Bus Stop', weight: 3 },
  bus: { icon: '/icons/bus.svg', label: 'Bus Stop', weight: 3 },
  railway_station: { icon: '/icons/metro.svg', label: 'Railway', weight: 5 },
  railway: { icon: '/icons/metro.svg', label: 'Railway', weight: 5 },
  school: { icon: '/icons/school.svg', label: 'School', weight: 4 },
  college: { icon: '/icons/college.svg', label: 'College', weight: 4 },
  university: { icon: '/icons/college.svg', label: 'University', weight: 4 },
  hospital: { icon: '/icons/hospital.svg', label: 'Hospital', weight: 4 },
  clinic: { icon: '/icons/hospital.svg', label: 'Clinic', weight: 3 },
  mall: { icon: '/icons/mall.svg', label: 'Mall', weight: 5 },
  office: { icon: '/icons/office.svg', label: 'Office', weight: 4 },
  residential: { icon: '/icons/house.svg', label: 'Residential', weight: 3 },
  temple: { icon: '/icons/temple.svg', label: 'Temple/Church', weight: 3 },
  church: { icon: '/icons/temple.svg', label: 'Church', weight: 3 },
  mosque: { icon: '/icons/temple.svg', label: 'Mosque', weight: 3 },
  park: { icon: '/icons/park.svg', label: 'Park', weight: 2 },
  atm: { icon: '/icons/bank.svg', label: 'ATM', weight: 2 },
  bank: { icon: '/icons/bank.svg', label: 'Bank', weight: 3 },
  bar: { icon: '/icons/bar.svg', label: 'Bar/Pub', weight: 3 },
  pub: { icon: '/icons/bar.svg', label: 'Bar/Pub', weight: 3 },
  restaurant: { icon: '/icons/restaurant.svg', label: 'Restaurant', weight: 3 },
  cafe: { icon: '/icons/cafe.svg', label: 'Cafe', weight: 3 },
  hotel: { icon: '/icons/building.svg', label: 'Hotel', weight: 4 },
  pharmacy: { icon: '/icons/pharmacy.svg', label: 'Pharmacy', weight: 3 },
  gym: { icon: '/icons/gym.svg', label: 'Gym', weight: 3 },
  supermarket: { icon: '/icons/mall.svg', label: 'Supermarket', weight: 3 },
  nearby: { icon: '/icons/marker.svg', label: 'Nearby Places', weight: 2 },
  // Default fallback
  default: { icon: '/icons/marker.svg', label: 'Other', weight: 1 },
};

export default function LandmarksCard({ landmarks = [], isLoading }) {
  const [showAllLandmarks, setShowAllLandmarks] = useState(false);
  
  // Ensure landmarks is an array
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  
  // Group landmarks by category
  const groupedLandmarks = landmarkList.reduce((acc, landmark) => {
    const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
    if (!acc[category]) {
      acc[category] = [];
    }
    acc[category].push(landmark);
    return acc;
  }, {});

  // Sort categories by weight (highest first)
  const sortedCategories = Object.entries(groupedLandmarks).sort((a, b) => {
    const configA = CATEGORY_CONFIG[a[0]] || CATEGORY_CONFIG.default;
    const configB = CATEGORY_CONFIG[b[0]] || CATEGORY_CONFIG.default;
    return configB.weight - configA.weight;
  });

  // Calculate total footfall value
  const totalFootfallValue = landmarkList.reduce((total, landmark) => {
    const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
    const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
    return total + config.weight;
  }, 0);

  const getFootfallLevel = (value) => {
    if (value >= 30) return { label: 'High', color: 'text-primary-glow' };
    if (value >= 15) return { label: 'Medium', color: 'text-accent-glow' };
    return { label: 'Low', color: 'text-warning-glow' };
  };

  return (
    <div className="glass-panel p-5">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <img src="/icons/building.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)' }} />
          Nearby Landmarks
        </h3>
        {!isLoading && (
          <span className="text-xs bg-primary-glow/20 text-primary-glow px-2 py-1 rounded-full">
            {landmarkList.length} found
          </span>
        )}
      </div>

      {isLoading ? (
        <div className="space-y-3">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="flex items-center gap-3">
              <div className="w-8 h-8 bg-slate-700 rounded-lg animate-pulse" />
              <div className="flex-1">
                <div className="h-4 bg-slate-700 rounded animate-pulse w-20 mb-1" />
                <div className="h-3 bg-slate-700/50 rounded animate-pulse w-12" />
              </div>
            </div>
          ))}
        </div>
      ) : landmarkList.length === 0 ? (
        <div className="text-center py-6">
          <img src="/icons/marker.svg" alt="" className="w-8 h-8 mx-auto mb-2 opacity-50" style={{ filter: 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
          <p className="text-slate-400 text-sm">No landmarks nearby</p>
          <p className="text-slate-500 text-xs mt-1">May indicate low footfall area</p>
        </div>
      ) : (
        <div className="space-y-2">
          {/* Category Summary */}
          <div className="space-y-2 max-h-48 overflow-y-auto">
            {sortedCategories.map(([category, items]) => {
              const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
              return (
                <div 
                  key={category}
                  className="flex items-center gap-3 p-2 rounded-lg hover:bg-surface-secondary transition-colors"
                >
                  {/* Category icon */}
                  <div className="w-8 h-8 bg-surface-secondary rounded-lg flex items-center justify-center">
                    <img 
                      src={config.icon} 
                      alt="" 
                      className="w-5 h-5"
                      style={{ filter: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)' }}
                    />
                  </div>
                  
                  {/* Category info */}
                  <div className="flex-1 min-w-0">
                    <p className="text-slate-200 text-sm">{config.label}</p>
                    <p className="text-slate-500 text-xs">{items.length} nearby</p>
                  </div>
                  
                  {/* Weight indicator */}
                  <div className="flex gap-0.5">
                    {[1, 2, 3, 4, 5].map((dot) => (
                      <div
                        key={dot}
                        className={`w-1.5 h-1.5 rounded-full ${
                          dot <= config.weight ? 'bg-primary-glow' : 'bg-slate-700'
                        }`}
                      />
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
          
          {/* Show All Landmarks Button */}
          {showAllLandmarks ? (
            <div className="mt-3 pt-3 border-t border-surface-border">
              <button
                onClick={() => setShowAllLandmarks(false)}
                className="text-xs text-primary-glow hover:text-primary-glow/80 mb-2"
              >
                 Hide individual landmarks
              </button>
              <div className="space-y-1 max-h-48 overflow-y-auto">
                {landmarkList.map((landmark, idx) => {
                  const category = landmark.category?.toLowerCase().replace(/\s+/g, '_') || 'default';
                  const config = CATEGORY_CONFIG[category] || CATEGORY_CONFIG.default;
                  return (
                    <div key={idx} className="flex items-center gap-2 p-1.5 text-xs rounded hover:bg-surface-secondary">
                      <img 
                        src={config.icon} 
                        alt="" 
                        className="w-4 h-4 flex-shrink-0"
                        style={{ filter: 'invert(70%) sepia(98%) saturate(500%) hue-rotate(152deg) brightness(97%) contrast(90%)' }}
                      />
                      <span className="text-slate-300 truncate flex-1">{landmark.name}</span>
                      {landmark.distance && (
                        <span className="text-slate-500">{landmark.distance}m</span>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <button
              onClick={() => setShowAllLandmarks(true)}
              className="w-full text-xs text-primary-glow hover:text-primary-glow/80 mt-2 py-1"
            >
               Show all {landmarkList.length} landmarks
            </button>
          )}
        </div>
      )}
      
      {/* Footfall value indicator */}
      {!isLoading && landmarkList.length > 0 && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <div className="flex items-center justify-between text-xs">
            <span className="text-slate-500">Footfall Potential</span>
            <span className={getFootfallLevel(totalFootfallValue).color}>
              {getFootfallLevel(totalFootfallValue).label}
              <span className="text-slate-600 ml-1">({totalFootfallValue} pts)</span>
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Filters/BusinessTypeSelector.jsx">
/**
 * Business Type Selector Component - Icon Grid Design
 * Glass-morphic 2-column grid of Icon Cards
 */

import { useState, useRef, useEffect } from 'react';
import { BUSINESS_ICONS } from '../common/Icon';

// Business type options with SVG icons
const BUSINESS_TYPES = [
  { id: 'cafe', label: 'Cafe', icon: BUSINESS_ICONS.cafe },
  { id: 'restaurant', label: 'Restaurant', icon: BUSINESS_ICONS.restaurant },
  { id: 'retail', label: 'Retail', icon: BUSINESS_ICONS.retail },
  { id: 'gym', label: 'Gym', icon: BUSINESS_ICONS.gym },
  { id: 'pharmacy', label: 'Pharmacy', icon: BUSINESS_ICONS.pharmacy },
  { id: 'salon', label: 'Salon', icon: BUSINESS_ICONS.salon },
  { id: 'electronics', label: 'Electronics', icon: BUSINESS_ICONS.electronics },
  { id: 'clothing', label: 'Clothing', icon: BUSINESS_ICONS.clothing },
  { id: 'bookstore', label: 'Bookstore', icon: BUSINESS_ICONS.bookstore },
  { id: 'other', label: 'Other', icon: BUSINESS_ICONS.other },
];

export default function BusinessTypeSelector({ value, onChange, disabled }) {
  const [customType, setCustomType] = useState('');
  const [showCustomInput, setShowCustomInput] = useState(false);

  const handleSelect = (type) => {
    if (disabled) return;
    
    if (type.id === 'other') {
      setShowCustomInput(true);
      onChange(type.id);
    } else {
      setShowCustomInput(false);
      onChange(type.id);
    }
  };

  const handleCustomSubmit = (e) => {
    e.preventDefault();
    if (customType.trim()) {
      onChange(customType.trim().toLowerCase());
      setShowCustomInput(false);
    }
  };

  const selectedType = BUSINESS_TYPES.find((t) => t.id === value);

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium text-slate-300">
          What are you opening?
        </label>
        {value && value !== 'other' && (
          <span className="text-xs text-emerald-400 bg-emerald-500/10 px-2 py-1 rounded-full border border-emerald-500/20">
            {selectedType?.label || value}
          </span>
        )}
      </div>

      {/* 2-Column Icon Grid */}
      <div className={`grid grid-cols-2 gap-2 ${disabled ? 'opacity-50 pointer-events-none' : ''}`}>
        {BUSINESS_TYPES.map((type) => {
          const isActive = value === type.id;
          return (
            <button
              key={type.id}
              type="button"
              onClick={() => handleSelect(type)}
              className={`
                relative flex flex-col items-center justify-center gap-2 p-3 rounded-xl
                transition-all duration-200 border
                ${isActive 
                  ? 'bg-emerald-500/20 border-emerald-500/50 ring-2 ring-emerald-500 shadow-lg shadow-emerald-500/10' 
                  : 'bg-slate-800/30 border-white/5 hover:bg-white/5 hover:border-white/10'
                }
              `}
            >
              <img 
                src={type.icon} 
                alt="" 
                className="w-7 h-7 transition-all duration-200"
                style={{ 
                  filter: isActive 
                    ? 'invert(80%) sepia(60%) saturate(1000%) hue-rotate(100deg) brightness(100%) contrast(90%)' 
                    : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)'
                }}
              />
              <span className={`text-xs font-medium transition-colors ${isActive ? 'text-emerald-400' : 'text-slate-400'}`}>
                {type.label}
              </span>
              
              {/* Active indicator dot */}
              {isActive && (
                <div className="absolute top-2 right-2 w-2 h-2 rounded-full bg-emerald-400 animate-pulse" />
              )}
            </button>
          );
        })}
      </div>

      {/* Custom Input (shown when 'Other' is selected) */}
      {showCustomInput && value === 'other' && (
        <form onSubmit={handleCustomSubmit} className="mt-3">
          <div className="flex gap-2">
            <input
              type="text"
              value={customType}
              onChange={(e) => setCustomType(e.target.value)}
              placeholder="Enter custom type..."
              className="flex-1 bg-black/50 border border-white/10 rounded-lg px-4 py-2.5 text-sm text-white placeholder-slate-500 focus:outline-none focus:border-emerald-500/50 focus:ring-1 focus:ring-emerald-500/30 transition-all"
              autoFocus
            />
            <button
              type="submit"
              className="px-4 py-2 bg-emerald-500 text-white text-sm font-medium rounded-lg hover:bg-emerald-400 transition-colors"
            >
              Set
            </button>
          </div>
        </form>
      )}

      {/* Validation hint */}
      {!value && (
        <p className="text-xs text-amber-400/80 flex items-center gap-1.5 mt-2">
          <svg className="w-3.5 h-3.5" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
          </svg>
          Required to identify competitors
        </p>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Layout/Header.jsx">
/**
 * Header Component - Floating Island Design
 * Glass-morphic Command Center aesthetic
 */

export default function Header({ isDarkMode, onToggleTheme }) {
  return (
    <header className="fixed top-4 left-1/2 -translate-x-1/2 w-[92%] max-w-6xl z-50">
      <div className={`backdrop-blur-xl ${isDarkMode ? 'bg-slate-900/80 border-white/10' : 'bg-white/80 border-slate-200'} border rounded-full px-4 py-2 flex items-center justify-between shadow-xl ${isDarkMode ? 'shadow-black/20' : 'shadow-slate-300/30'}`}>
        {/* Left: Logo & Brand */}
        <div className="flex items-center gap-2">
          {/* Logo Image */}
          <div className="w-8 h-8 flex items-center justify-center">
            <img 
              src="/hotspot-logo.png" 
              alt="Hotspot IQ" 
              className="w-8 h-8 object-contain"
              onError={(e) => {
                e.target.style.display = 'none';
                e.target.nextSibling.style.display = 'flex';
              }}
            />
            {/* Fallback gradient icon */}
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-emerald-400 to-cyan-500 items-center justify-center hidden">
              <svg className="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
            </div>
          </div>
          
          {/* Brand Text */}
          <div className="leading-tight">
            <h1 className="text-base font-bold tracking-tight">
              <span className="bg-gradient-to-r from-emerald-400 via-cyan-400 to-emerald-400 bg-clip-text text-transparent">
                Hotspot
              </span>
              <span className={isDarkMode ? 'text-white' : 'text-slate-800'}>IQ</span>
            </h1>
            <p className={`text-[9px] ${isDarkMode ? 'text-slate-500' : 'text-slate-400'} tracking-wider uppercase -mt-0.5`}>
              Location Intelligence
            </p>
          </div>
        </div>

        {/* Right: Navigation & Links */}
        <div className="flex items-center gap-3">
          {/* Nav Links */}
          <nav className="hidden md:flex items-center">
            <a href="#" className={`px-3 py-1.5 text-xs ${isDarkMode ? 'text-slate-400 hover:text-white hover:bg-white/5' : 'text-slate-500 hover:text-slate-800 hover:bg-slate-100'} rounded-full transition-all duration-200`}>
              Dashboard
            </a>
            <a href="#" className={`px-3 py-1.5 text-xs ${isDarkMode ? 'text-slate-400 hover:text-white hover:bg-white/5' : 'text-slate-500 hover:text-slate-800 hover:bg-slate-100'} rounded-full transition-all duration-200`}>
              Analytics
            </a>
            <a href="#" className={`px-3 py-1.5 text-xs ${isDarkMode ? 'text-slate-400 hover:text-white hover:bg-white/5' : 'text-slate-500 hover:text-slate-800 hover:bg-slate-100'} rounded-full transition-all duration-200`}>
              API Docs
            </a>
          </nav>

          {/* Divider */}
          <div className={`hidden md:block w-px h-5 ${isDarkMode ? 'bg-white/10' : 'bg-slate-200'}`} />

          {/* Powered By */}
          <div className="hidden sm:flex items-center gap-1.5 text-[11px]">
            <span className={isDarkMode ? 'text-slate-500' : 'text-slate-400'}>Powered by</span>
            <span className="text-emerald-500 font-semibold">LatLong.ai</span>
          </div>

          {/* Theme Toggle Button */}
          <button
            onClick={onToggleTheme}
            className={`w-8 h-8 flex items-center justify-center rounded-full ${isDarkMode ? 'bg-white/5 hover:bg-white/10 border-white/10 hover:border-white/20' : 'bg-slate-100 hover:bg-slate-200 border-slate-200 hover:border-slate-300'} border transition-all duration-200 group`}
            title={isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
          >
            {isDarkMode ? (
              // Sun icon for light mode
              <svg className="w-4 h-4 text-amber-400 group-hover:text-amber-300 transition-colors" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z" />
              </svg>
            ) : (
              // Moon icon for dark mode
              <svg className="w-4 h-4 text-slate-500 group-hover:text-slate-700 transition-colors" fill="currentColor" viewBox="0 0 24 24">
                <path fillRule="evenodd" d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z" clipRule="evenodd" />
              </svg>
            )}
          </button>

          {/* GitHub Link */}
          <a 
            href="https://github.com/Shubhojit-17/Hotspot-IQ" 
            target="_blank" 
            rel="noopener noreferrer"
            className={`w-7 h-7 flex items-center justify-center rounded-full ${isDarkMode ? 'bg-white/5 hover:bg-white/10 border-white/10 hover:border-white/20' : 'bg-slate-100 hover:bg-slate-200 border-slate-200 hover:border-slate-300'} border transition-all duration-200 group`}
          >
            <svg className={`w-4 h-4 ${isDarkMode ? 'text-slate-400 group-hover:text-white' : 'text-slate-500 group-hover:text-slate-800'} transition-colors`} fill="currentColor" viewBox="0 0 24 24">
              <path fillRule="evenodd" clipRule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33.85 0 1.71.11 2.5.33 1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z" />
            </svg>
          </a>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom Glassmorphism Utilities */
@layer components {
  .glass-panel {
    @apply bg-surface-primary backdrop-blur-[12px] border border-surface-border rounded-2xl shadow-glass;
  }

  .glass-card {
    @apply bg-surface-secondary backdrop-blur-[12px] border border-surface-border rounded-xl shadow-glass;
  }

  .glass-input {
    @apply bg-canvas-base border border-surface-border rounded-lg px-4 py-3 text-slate-50 placeholder-slate-500 focus:outline-none focus:border-primary-glow focus:shadow-glow-primary transition-all duration-200;
  }

  .btn-primary {
    @apply bg-primary-glow text-canvas-deep font-semibold px-6 py-3 rounded-lg hover:bg-primary-bright active:scale-[0.98] transition-all duration-200 shadow-glow-primary disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none;
  }

  .btn-ghost {
    @apply bg-transparent border border-surface-border text-slate-300 font-medium px-4 py-2 rounded-lg hover:bg-surface-elevated hover:text-slate-50 transition-all duration-200;
  }

  .chip {
    @apply px-3 py-1.5 rounded-full text-sm font-medium transition-all duration-200 cursor-pointer select-none;
  }

  .chip-inactive {
    @apply bg-transparent border border-surface-border text-slate-500 hover:border-slate-500 hover:text-slate-400;
  }

  .chip-active {
    @apply bg-primary-soft border border-primary-glow text-primary-bright shadow-glow-primary;
  }

  .score-high {
    @apply bg-primary-soft border border-primary-glow text-primary-bright;
  }

  .score-medium {
    @apply bg-warning-soft border border-warning-glow text-warning-glow;
  }

  .score-low {
    @apply bg-destructive-soft border border-destructive-glow text-destructive-bright;
  }
}

/* Leaflet Map Dark Theme Overrides */
.leaflet-container {
  background: #020617;
  font-family: 'Inter', sans-serif;
}

.leaflet-control-zoom {
  border: 1px solid rgba(255, 255, 255, 0.08) !important;
  background: rgba(15, 23, 42, 0.9) !important;
  backdrop-filter: blur(12px);
}

.leaflet-control-zoom a {
  background: transparent !important;
  color: #cbd5e1 !important;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08) !important;
}

.leaflet-control-zoom a:hover {
  background: rgba(51, 65, 85, 0.6) !important;
  color: #f8fafc !important;
}

.leaflet-popup-content-wrapper {
  background: rgba(15, 23, 42, 0.95);
  color: #f8fafc;
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  backdrop-filter: blur(12px);
}

.leaflet-popup-tip {
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

/* Custom Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(15, 23, 42, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(100, 116, 139, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(100, 116, 139, 0.7);
}

/* Animations */
@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

.skeleton {
  background: linear-gradient(
    90deg,
    rgba(51, 65, 85, 0.3) 25%,
    rgba(51, 65, 85, 0.5) 50%,
    rgba(51, 65, 85, 0.3) 75%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

/* Pulse Ring Animation for Map Marker */
@keyframes pulseRing {
  0% {
    transform: scale(1);
    opacity: 0.8;
  }
  100% {
    transform: scale(2.5);
    opacity: 0;
  }
}

.marker-pulse-ring {
  animation: pulseRing 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Slide-in animation for dropdowns and panels */
@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.animate-slide-in-up {
  animation: slideInUp 0.2s ease-out;
}

.animate-slide-in-right {
  animation: slideInRight 0.3s ease-out;
}

.animate-fade-in {
  animation: fadeIn 0.2s ease-out;
}

.animate-fadeIn {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slideIn {
  animation: slideIn 0.3s ease-out forwards;
}

/* Toast slide down animation */
@keyframes slideDown {
  from {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

.animate-slide-down {
  animation: slideDown 0.3s ease-out forwards;
}

/* Custom marker styles */
.custom-marker {
  background: transparent !important;
  border: none !important;
}

/* Recommended spot markers - ALWAYS visible and distinct */
.recommended-spot-marker {
  background: transparent !important;
  border: none !important;
  z-index: 9999 !important;
}

/* Recommended spots should NOT scale down as much - stay prominent */
.map-zoom-7 .recommended-spot-marker > div,
.map-zoom-8 .recommended-spot-marker > div {
  transform: scale(0.6) !important;
}

.map-zoom-9 .recommended-spot-marker > div,
.map-zoom-10 .recommended-spot-marker > div {
  transform: scale(0.7) !important;
}

.map-zoom-11 .recommended-spot-marker > div,
.map-zoom-12 .recommended-spot-marker > div {
  transform: scale(0.8) !important;
}

.map-zoom-13 .recommended-spot-marker > div,
.map-zoom-14 .recommended-spot-marker > div,
.map-zoom-15 .recommended-spot-marker > div,
.map-zoom-16 .recommended-spot-marker > div,
.map-zoom-17 .recommended-spot-marker > div,
.map-zoom-18 .recommended-spot-marker > div,
.map-zoom-19 .recommended-spot-marker > div,
.map-zoom-20 .recommended-spot-marker > div {
  transform: scale(1) !important;
}

/* Dynamic marker sizing based on zoom level */
/* Range: 10% (min) to 80% (max) for regular markers */
.leaflet-marker-icon {
  transition: transform 0.15s ease-out;
}

/* Zoom-based marker scaling using CSS classes */
/* Very zoomed out - minimum 10% size */
.map-zoom-7 .custom-marker > div,
.map-zoom-8 .custom-marker > div {
  transform: scale(0.1) !important;
}

.map-zoom-9 .custom-marker > div {
  transform: scale(0.15) !important;
}

.map-zoom-10 .custom-marker > div {
  transform: scale(0.2) !important;
}

.map-zoom-11 .custom-marker > div {
  transform: scale(0.3) !important;
}

.map-zoom-12 .custom-marker > div {
  transform: scale(0.4) !important;
}

.map-zoom-13 .custom-marker > div {
  transform: scale(0.5) !important;
}

.map-zoom-14 .custom-marker > div {
  transform: scale(0.6) !important;
}

.map-zoom-15 .custom-marker > div {
  transform: scale(0.7) !important;
}

/* Max size capped at 80% - zoom 16 and above */
.map-zoom-16 .custom-marker > div,
.map-zoom-17 .custom-marker > div,
.map-zoom-18 .custom-marker > div,
.map-zoom-19 .custom-marker > div,
.map-zoom-20 .custom-marker > div {
  transform: scale(0.8) !important;
}

/* ============================================== */
/* LIGHT MODE STYLES                              */
/* ============================================== */

/* Base light mode - when 'dark' class is NOT on html */
:root:not(.dark) {
  --canvas-deep: #f8fafc;
  --canvas-base: #f1f5f9;
  --surface-primary: rgba(255, 255, 255, 0.9);
  --surface-secondary: rgba(248, 250, 252, 0.9);
  --surface-border: rgba(0, 0, 0, 0.1);
  --text-primary: #0f172a;
  --text-secondary: #475569;
  --text-muted: #64748b;
}

/* Dark mode variables */
.dark {
  --canvas-deep: #020617;
  --canvas-base: #0f172a;
  --surface-primary: rgba(15, 23, 42, 0.8);
  --surface-secondary: rgba(30, 41, 59, 0.7);
  --surface-border: rgba(255, 255, 255, 0.08);
  --text-primary: #f8fafc;
  --text-secondary: #cbd5e1;
  --text-muted: #64748b;
}

/* Light mode glass panels */
:root:not(.dark) .glass-panel {
  background: rgba(255, 255, 255, 0.85) !important;
  border-color: rgba(0, 0, 0, 0.08) !important;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

:root:not(.dark) .glass-card {
  background: rgba(255, 255, 255, 0.9) !important;
  border-color: rgba(0, 0, 0, 0.08) !important;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
}

/* Light mode inputs */
:root:not(.dark) .glass-input {
  background: rgba(255, 255, 255, 0.95) !important;
  border-color: rgba(0, 0, 0, 0.15) !important;
  color: #0f172a !important;
}

:root:not(.dark) .glass-input::placeholder {
  color: #94a3b8 !important;
}

:root:not(.dark) .glass-input:focus {
  border-color: #10b981 !important;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2) !important;
}

/* Light mode buttons */
:root:not(.dark) .btn-ghost {
  border-color: rgba(0, 0, 0, 0.15) !important;
  color: #334155 !important;
}

:root:not(.dark) .btn-ghost:hover {
  background: rgba(0, 0, 0, 0.05) !important;
  color: #0f172a !important;
}

/* Light mode chips */
:root:not(.dark) .chip-inactive {
  border-color: rgba(0, 0, 0, 0.15) !important;
  color: #64748b !important;
}

:root:not(.dark) .chip-inactive:hover {
  border-color: #94a3b8 !important;
  color: #475569 !important;
}

/* Light mode leaflet map controls */
:root:not(.dark) .leaflet-container {
  background: #f1f5f9;
}

:root:not(.dark) .leaflet-control-zoom {
  border: 1px solid rgba(0, 0, 0, 0.1) !important;
  background: rgba(255, 255, 255, 0.95) !important;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

:root:not(.dark) .leaflet-control-zoom a {
  background: transparent !important;
  color: #334155 !important;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
}

:root:not(.dark) .leaflet-control-zoom a:hover {
  background: rgba(0, 0, 0, 0.05) !important;
  color: #0f172a !important;
}

:root:not(.dark) .leaflet-popup-content-wrapper {
  background: rgba(255, 255, 255, 0.98);
  color: #0f172a;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

:root:not(.dark) .leaflet-popup-tip {
  background: rgba(255, 255, 255, 0.98);
  border: 1px solid rgba(0, 0, 0, 0.1);
}

/* Light mode scrollbar */
:root:not(.dark) ::-webkit-scrollbar-track {
  background: rgba(241, 245, 249, 0.8);
}

:root:not(.dark) ::-webkit-scrollbar-thumb {
  background: rgba(148, 163, 184, 0.5);
}

:root:not(.dark) ::-webkit-scrollbar-thumb:hover {
  background: rgba(148, 163, 184, 0.7);
}

/* Light mode skeleton loading */
:root:not(.dark) .skeleton {
  background: linear-gradient(
    90deg,
    rgba(226, 232, 240, 0.5) 25%,
    rgba(226, 232, 240, 0.8) 50%,
    rgba(226, 232, 240, 0.5) 75%
  );
  background-size: 200% 100%;
}

/* Light mode text colors - override common text utilities */
:root:not(.dark) .text-slate-50,
:root:not(.dark) .text-slate-100 {
  color: #0f172a !important;
}

:root:not(.dark) .text-slate-200,
:root:not(.dark) .text-slate-300 {
  color: #334155 !important;
}

:root:not(.dark) .text-slate-400,
:root:not(.dark) .text-slate-500 {
  color: #64748b !important;
}

/* Light mode background overrides for common patterns */
:root:not(.dark) .bg-canvas-deep {
  background-color: #f8fafc !important;
}

:root:not(.dark) .bg-canvas-base {
  background-color: #f1f5f9 !important;
}

:root:not(.dark) .bg-surface-primary {
  background-color: rgba(255, 255, 255, 0.9) !important;
}

:root:not(.dark) .bg-surface-secondary {
  background-color: rgba(248, 250, 252, 0.9) !important;
}

:root:not(.dark) .bg-surface-elevated {
  background-color: rgba(241, 245, 249, 0.9) !important;
}

/* Light mode border overrides */
:root:not(.dark) .border-surface-border {
  border-color: rgba(0, 0, 0, 0.1) !important;
}

:root:not(.dark) .border-slate-700,
:root:not(.dark) .border-slate-800 {
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Light mode gradient backgrounds */
:root:not(.dark) .bg-gradient-to-b.from-slate-900 {
  background: linear-gradient(to bottom, #f1f5f9, #f8fafc) !important;
}

:root:not(.dark) .bg-gradient-to-r.from-slate-800 {
  background: linear-gradient(to right, #f8fafc, #f1f5f9) !important;
}

/* Light mode divide colors */
:root:not(.dark) .divide-slate-700 > :not([hidden]) ~ :not([hidden]),
:root:not(.dark) .divide-slate-800 > :not([hidden]) ~ :not([hidden]) {
  border-color: rgba(0, 0, 0, 0.08) !important;
}

/* Light mode ring colors */
:root:not(.dark) .ring-slate-800,
:root:not(.dark) .ring-surface-border {
  --tw-ring-color: rgba(0, 0, 0, 0.1) !important;
}

/* Light mode hover states */
:root:not(.dark) .hover\:bg-surface-elevated:hover {
  background-color: rgba(226, 232, 240, 0.8) !important;
}

:root:not(.dark) .hover\:bg-slate-800:hover {
  background-color: rgba(226, 232, 240, 0.6) !important;
}

/* Light mode focus states */
:root:not(.dark) .focus\:border-primary-glow:focus {
  border-color: #10b981 !important;
}

/* Score cards stay consistent */
:root:not(.dark) .score-high {
  background: rgba(16, 185, 129, 0.15) !important;
}

:root:not(.dark) .score-medium {
  background: rgba(245, 158, 11, 0.15) !important;
}

:root:not(.dark) .score-low {
  background: rgba(244, 63, 94, 0.15) !important;
}

/* ============================================== */
/* SIDEBAR & PANEL LIGHT MODE OVERRIDES           */
/* ============================================== */

/* Left sidebar panel - backdrop blur with light background */
:root:not(.dark) .backdrop-blur-xl.bg-slate-900\/80 {
  background: rgba(255, 255, 255, 0.9) !important;
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Right sidebar/floating panels */
:root:not(.dark) .backdrop-blur-md.bg-slate-900\/90,
:root:not(.dark) .backdrop-blur-lg.bg-slate-900\/90 {
  background: rgba(255, 255, 255, 0.95) !important;
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Panel borders */
:root:not(.dark) .border-white\/10,
:root:not(.dark) .border-white\/5 {
  border-color: rgba(0, 0, 0, 0.08) !important;
}

/* Text color overrides for panels */
:root:not(.dark) .text-white {
  color: #0f172a !important;
}

:root:not(.dark) .text-white\/80,
:root:not(.dark) .text-white\/70,
:root:not(.dark) .text-white\/60 {
  color: #334155 !important;
}

:root:not(.dark) .text-white\/50,
:root:not(.dark) .text-white\/40 {
  color: #64748b !important;
}

/* Slider track */
:root:not(.dark) .bg-slate-700\/50 {
  background: rgba(203, 213, 225, 0.6) !important;
}

:root:not(.dark) .bg-slate-700 {
  background: #cbd5e1 !important;
}

:root:not(.dark) .bg-slate-700\/30 {
  background: rgba(203, 213, 225, 0.4) !important;
}

/* Background overlays */
:root:not(.dark) .bg-slate-900\/50,
:root:not(.dark) .bg-slate-900\/60,
:root:not(.dark) .bg-slate-900\/70,
:root:not(.dark) .bg-slate-900\/80,
:root:not(.dark) .bg-slate-900\/90 {
  background: rgba(255, 255, 255, 0.9) !important;
}

:root:not(.dark) .bg-slate-800,
:root:not(.dark) .bg-slate-800\/50,
:root:not(.dark) .bg-slate-800\/60,
:root:not(.dark) .bg-slate-800\/70,
:root:not(.dark) .bg-slate-800\/80 {
  background: rgba(241, 245, 249, 0.9) !important;
}

/* Panel shadows for light mode */
:root:not(.dark) .shadow-2xl.shadow-black\/30 {
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15) !important;
}

/* Business type selector cards */
:root:not(.dark) .bg-slate-800\/30 {
  background: rgba(241, 245, 249, 0.7) !important;
}

:root:not(.dark) .hover\:bg-slate-800\/50:hover {
  background: rgba(226, 232, 240, 0.8) !important;
}

/* Active/selected states */
:root:not(.dark) .bg-emerald-500\/10 {
  background: rgba(16, 185, 129, 0.15) !important;
}

:root:not(.dark) .border-emerald-500\/20 {
  border-color: rgba(16, 185, 129, 0.3) !important;
}

/* Floating stats panel (bottom right) */
:root:not(.dark) .bg-gradient-to-br.from-slate-800\/95 {
  background: linear-gradient(to bottom right, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95)) !important;
}

/* Score display backgrounds */
:root:not(.dark) .bg-slate-900\/80 {
  background: rgba(255, 255, 255, 0.9) !important;
}

/* Ring and circle backgrounds */
:root:not(.dark) .text-slate-700 {
  color: #cbd5e1 !important;
}

/* Preserve emerald/primary colors in light mode */
:root:not(.dark) .text-emerald-400,
:root:not(.dark) .text-emerald-500 {
  color: #059669 !important;
}

:root:not(.dark) .text-cyan-400,
:root:not(.dark) .text-cyan-500 {
  color: #0891b2 !important;
}

/* Toggle buttons and switches */
:root:not(.dark) .bg-slate-600,
:root:not(.dark) .bg-slate-600\/50 {
  background: #94a3b8 !important;
}

:root:not(.dark) .hover\:bg-slate-700:hover {
  background: #cbd5e1 !important;
}

/* Mini stat cards */
:root:not(.dark) .bg-slate-800\/40 {
  background: rgba(241, 245, 249, 0.8) !important;
}

/* Analysis panel header */
:root:not(.dark) .from-slate-800 {
  background: linear-gradient(to right, #f8fafc, #f1f5f9) !important;
}

/* Dividers */
:root:not(.dark) .bg-slate-700\/50 {
  background: rgba(203, 213, 225, 0.5) !important;
}

/* Competitor/Landmark toggle buttons */
:root:not(.dark) .bg-cyan-500\/20 {
  background: rgba(6, 182, 212, 0.15) !important;
}

:root:not(.dark) .bg-orange-500\/20 {
  background: rgba(249, 115, 22, 0.15) !important;
}

:root:not(.dark) .border-cyan-500\/30 {
  border-color: rgba(6, 182, 212, 0.3) !important;
}

:root:not(.dark) .border-orange-500\/30 {
  border-color: rgba(249, 115, 22, 0.3) !important;
}

/* Input placeholder in light mode */
:root:not(.dark) input::placeholder,
:root:not(.dark) textarea::placeholder {
  color: #94a3b8 !important;
}

/* Range slider thumb */
:root:not(.dark) input[type="range"] {
  background: rgba(203, 213, 225, 0.6) !important;
}

/* Loading skeleton pulse */
:root:not(.dark) .animate-pulse {
  background-color: rgba(203, 213, 225, 0.5) !important;
}

/* Fix for accent colored text that should stay vibrant */
:root:not(.dark) .text-amber-400,
:root:not(.dark) .text-amber-500 {
  color: #d97706 !important;
}

:root:not(.dark) .text-rose-400,
:root:not(.dark) .text-rose-500 {
  color: #e11d48 !important;
}

:root:not(.dark) .text-violet-400,
:root:not(.dark) .text-violet-500 {
  color: #7c3aed !important;
}

/* Keep primary button text white */
:root:not(.dark) .bg-gradient-to-r.from-emerald-500 .text-white,
:root:not(.dark) .bg-emerald-500 .text-white,
:root:not(.dark) button.bg-gradient-to-r {
  color: white !important;
}

/* Button with gradient should keep white text */
:root:not(.dark) .from-emerald-500.to-cyan-500 {
  color: white !important;
}

/* Search input specific overrides */
:root:not(.dark) .bg-black\/50 {
  background: rgba(255, 255, 255, 0.95) !important;
}

:root:not(.dark) .bg-black\/70 {
  background: rgba(255, 255, 255, 0.98) !important;
}

:root:not(.dark) input.text-white {
  color: #0f172a !important;
}

/* Search dropdown */
:root:not(.dark) .bg-slate-900\/95 {
  background: rgba(255, 255, 255, 0.98) !important;
}

/* Dropdown items hover */
:root:not(.dark) .hover\:bg-slate-800\/50:hover {
  background: rgba(226, 232, 240, 0.7) !important;
}

:root:not(.dark) .bg-emerald-500\/10 {
  background: rgba(16, 185, 129, 0.12) !important;
}

/* Floating stats panel specific */
:root:not(.dark) .rounded-2xl.backdrop-blur-md {
  background: rgba(255, 255, 255, 0.95) !important;
}

/* Mini badges/pills */
:root:not(.dark) .bg-slate-700\/60 {
  background: rgba(203, 213, 225, 0.6) !important;
}

:root:not(.dark) .bg-slate-700\/40 {
  background: rgba(203, 213, 225, 0.4) !important;
}

/* Right panel specific styles */
:root:not(.dark) .space-y-2 .text-xs.text-slate-500 {
  color: #64748b !important;
}

:root:not(.dark) .space-y-1 .text-xs.text-slate-500 {
  color: #64748b !important;
}

/* Ensure all form inputs are readable */
:root:not(.dark) input[type="text"],
:root:not(.dark) input[type="search"] {
  color: #0f172a !important;
}

/* Map overlay controls */
:root:not(.dark) .bg-slate-800\/90 {
  background: rgba(255, 255, 255, 0.95) !important;
}

:root:not(.dark) .bg-slate-900 {
  background: #f8fafc !important;
}

/* Chip/tag active states */
:root:not(.dark) .bg-emerald-500\/20 {
  background: rgba(16, 185, 129, 0.18) !important;
}

:root:not(.dark) .bg-cyan-500\/10 {
  background: rgba(6, 182, 212, 0.12) !important;
}

:root:not(.dark) .bg-orange-500\/10 {
  background: rgba(249, 115, 22, 0.12) !important;
}

/* Dashboard cards text */
:root:not(.dark) .font-semibold.text-white {
  color: #0f172a !important;
}

:root:not(.dark) .font-medium.text-white {
  color: #1e293b !important;
}

/* Stats numbers should be dark */
:root:not(.dark) .text-2xl.font-bold.text-white,
:root:not(.dark) .text-3xl.font-bold.text-white,
:root:not(.dark) .text-xl.font-bold.text-white {
  color: #0f172a !important;
}

/* Keep primary colored text vibrant */
:root:not(.dark) .text-primary-glow,
:root:not(.dark) .text-primary-bright {
  color: #059669 !important;
}

/* Fix floating panel in bottom right */
:root:not(.dark) .fixed.bottom-6.right-6 .backdrop-blur-md {
  background: rgba(255, 255, 255, 0.95) !important;
  border-color: rgba(0, 0, 0, 0.1) !important;
}

/* Business type selector inactive cards */
:root:not(.dark) .border-white\/5 {
  border-color: rgba(0, 0, 0, 0.08) !important;
}

:root:not(.dark) .hover\:bg-white\/5:hover {
  background: rgba(0, 0, 0, 0.03) !important;
}

:root:not(.dark) .hover\:border-white\/10:hover {
  border-color: rgba(0, 0, 0, 0.12) !important;
}

/* Placeholder text */
:root:not(.dark) .placeholder-slate-500::placeholder {
  color: #94a3b8 !important;
}

/* Right panel toggle buttons container */
:root:not(.dark) .bg-slate-800\/60 {
  background: rgba(241, 245, 249, 0.8) !important;
}

/* Bottom right stats - ensure dark text */
:root:not(.dark) .text-lg.font-bold {
  color: #0f172a !important;
}

:root:not(.dark) .text-sm.font-semibold {
  color: #1e293b !important;
}

/* Legend/key colors - keep them visible */
:root:not(.dark) .bg-emerald-400,
:root:not(.dark) .bg-emerald-500 {
  background-color: #10b981 !important;
}

:root:not(.dark) .bg-amber-400,
:root:not(.dark) .bg-amber-500 {
  background-color: #f59e0b !important;
}

:root:not(.dark) .bg-rose-400,
:root:not(.dark) .bg-rose-500 {
  background-color: #f43f5e !important;
}

/* Make sure analyze button keeps white text */
:root:not(.dark) button.bg-gradient-to-r.from-emerald-500.to-cyan-500,
:root:not(.dark) .bg-gradient-to-r.from-emerald-500.to-cyan-500 button {
  color: white !important;
}

/* Generic white text in buttons should be preserved for colored backgrounds */
:root:not(.dark) .bg-emerald-500 .text-white,
:root:not(.dark) .bg-cyan-500 .text-white,
:root:not(.dark) .bg-gradient-to-r .text-white {
  color: white !important;
}

/* Fix the analyze button specifically */
:root:not(.dark) button[class*="from-emerald-500"][class*="to-cyan-500"] {
  color: white !important;
}
</file>

<file path="backend/requirements.txt">
flask==3.0.0
flask-cors==4.0.0
python-dotenv==1.0.0
requests==2.31.0
pandas>=2.1.0
openai==1.6.0
duckduckgo-search==4.1.0
overpy==0.7
huggingface_hub>=0.20.0
</file>

<file path="backend/routes/analysis_routes.py">
"""
Hotspot IQ - Analysis Routes
Handles location analysis, isochrone, and scoring endpoints.
"""

import re
import math
from flask import Blueprint, request, jsonify
from services.latlong_service import latlong_service
from services.places_service import fetch_competitors, fetch_landmarks
from utils.score_calculator import analyze_location, find_recommended_spots
from services.relevance_service import get_relevance_score, get_marker_style, RELEVANCE_MATRIX
from services.validation_service import validate_and_fetch_data, ValidationError

analysis_bp = Blueprint('analysis', __name__)


# Category detection keywords for landmarks
LANDMARK_CATEGORY_KEYWORDS = {
    'metro_station': ['metro', 'subway'],
    'bus_stop': ['bus stop', 'bus stand', 'bus station'],
    'railway_station': ['railway', 'train station', 'rail'],
    'school': ['school', 'vidyalaya', 'vidya'],
    'college': ['college', 'university', 'institute', 'iit', 'nit'],
    'hospital': ['hospital', 'medical', 'clinic', 'healthcare'],
    'mall': ['mall', 'plaza', 'shopping'],
    'office': ['office', 'corporate', 'tech park', 'business'],
    'residential': ['apartment', 'residency', 'housing', 'colony'],
    'temple': ['temple', 'mandir', 'church', 'mosque', 'gurudwara', 'masjid'],
    'park': ['park', 'garden', 'ground'],
    'atm': ['atm', 'bank'],
    'bar': ['bar', 'pub', 'brewery'],
    'restaurant': ['restaurant', 'dhaba', 'food', 'kitchen', 'cafe', 'diner'],
    'hotel': ['hotel', 'lodge', 'guest house', 'inn', 'oyo', 'capital o'],
}


def detect_landmark_category(name: str) -> str:
    """Detect category from landmark name."""
    name_lower = name.lower()
    for category, keywords in LANDMARK_CATEGORY_KEYWORDS.items():
        if any(kw in name_lower for kw in keywords):
            return category
    return 'default'


def parse_landmarks_from_text(landmark_text, business_type=''):
    """
    Parse landmark info from reverse geocode response.
    Example inputs: 
        "< 0.5km from Cafe Noir, < 0.5km from Farzi Cafe"
        "~ 0.5km from SDH Danapur, ~ 0.5km from Pizza Corner"
    
    Returns:
        tuple: (all_landmarks, competitors_only)
    """
    if not landmark_text:
        return [], []
    
    all_landmarks = []
    competitors = []
    
    # Business type keywords to identify competitors
    competitor_keywords = {
        'cafe': ['cafe', 'coffee', 'tea', 'bakery', 'starbucks', 'barista', 'roasters', 'brew', 'chai'],
        'restaurant': ['restaurant', 'food', 'kitchen', 'dhaba', 'biryani', 'pizza', 'burger', 'diner', 'sweets', 'corner', 'hotel', 'eatery', 'cuisine', 'tandoor', 'grill', 'chinese', 'mughlai'],
        'gym': ['gym', 'fitness', 'yoga', 'sports', 'crossfit', 'health club', 'workout'],
        'pharmacy': ['pharmacy', 'medical', 'chemist', 'medicine', 'drugstore', 'pharma', 'medico'],
        'salon': ['salon', 'spa', 'beauty', 'hair', 'parlour', 'parlor', 'unisex', 'barber'],
        'retail': ['store', 'mart', 'shop', 'retail', 'boutique', 'emporium', 'showroom'],
        'grocery': ['grocery', 'kirana', 'supermarket', 'mart', 'provision', 'general store'],
    }
    
    # Parse each landmark mention
    parts = landmark_text.split(',')
    for part in parts:
        part = part.strip()
        # Extract distance and name - handle variations like:
        # "< 0.5km from X", "~ 0.5km from X", "> 0.5km from X", "0.5km from X"
        match = re.match(r'[<>~]?\s*([\d.]+)\s*km\s+from\s+(.+)', part, re.IGNORECASE)
        if match:
            distance_km = float(match.group(1))
            name = match.group(2).strip()
            
            # Determine category based on name
            category = 'landmark'
            keywords = competitor_keywords.get(business_type, [])
            is_competitor = any(kw in name.lower() for kw in keywords)
            
            if is_competitor:
                category = business_type
            
            landmark = {
                'name': name,
                'distance': int(distance_km * 1000),  # Convert to meters
                'category': category,
                'is_competitor': is_competitor
            }
            
            # Add to all landmarks list
            all_landmarks.append(landmark)
            
            # Also track competitors separately
            if is_competitor:
                competitors.append(landmark)
    
    return all_landmarks, competitors


@analysis_bp.route('/analyze', methods=['POST'])
def analyze():
    """
    POST /api/analyze
    
    Performs comprehensive location analysis including opportunity score.
    Now uses area-based validation to consider the entire radius, not just center.
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    lat = data.get('lat')
    lng = data.get('lng')
    business_type = data.get('business_type', 'other')
    filters = data.get('filters', [])
    is_major_area = data.get('is_major', False)
    
    # Use larger radius for major areas (2500m) vs regular locations (1000m)
    default_radius = 2500 if is_major_area else 1000
    radius = data.get('radius', default_radius)
    
    print(f" Analysis Request: lat={lat}, lng={lng}, business_type={business_type}, is_major={is_major_area}, radius={radius}m")
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng are required'}), 400
    
    if not business_type:
        return jsonify({'error': 'business_type is required'}), 400
    
    # Store original center for reference
    center_lat, center_lng = lat, lng
    
    # === AREA-BASED VALIDATION ===
    # Validate the entire radius area, not just the center point
    # This allows analysis even when center is in water, if there's land nearby
    print(f"\n Running area-based validation (radius={radius}m)...")
    is_valid, validation_result = validate_and_fetch_data(lat, lng, business_type, radius=radius)
    
    if not is_valid:
        error_message = validation_result.get('message', 'Location validation failed')
        error_type = validation_result.get('error_type', 'validation_error')
        print(f" Area validation failed: {error_message}")
        return jsonify({
            'error': error_message,
            'error_type': error_type,
            'validation_failed': True
        }), 400
    
    # Use the analysis point (best land location found within radius)
    # This could be the center if it was valid, or a nearby land point if center was in water
    analysis_point = validation_result.get('analysis_point', {})
    if analysis_point.get('lat') and analysis_point.get('lng'):
        lat, lng = analysis_point['lat'], analysis_point['lng']
        print(f" Using analysis point: ({lat}, {lng})")
    
    # Also check for snapped location (on-road point)
    snapped_location = validation_result.get('snapped_location', {})
    if snapped_location.get('lat') and snapped_location.get('lng'):
        snap_lat, snap_lng = snapped_location['lat'], snapped_location['lng']
        
        # Calculate distance between analysis point and snapped
        R = 6371000  # Earth radius in meters
        dlat = math.radians(snap_lat - lat)
        dlng = math.radians(snap_lng - lng)
        a = math.sin(dlat/2)**2 + math.cos(math.radians(lat)) * math.cos(math.radians(snap_lat)) * math.sin(dlng/2)**2
        snap_distance = R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        # Use snapped if it's close to analysis point (within 100m)
        if snap_distance < 100:
            lat, lng = snap_lat, snap_lng
            print(f" Using snapped location: ({lat}, {lng}) - {snap_distance:.1f}m from analysis point")
    
    print(f" Area validation passed!")
    print(f"   Center: ({center_lat}, {center_lng})")
    print(f"   Analysis point: ({lat}, {lng})")
    # === END VALIDATION ===
    
    # Get reverse geocode for address info (includes landmark text)
    # Use the analysis point for more accurate address
    address_info = latlong_service.reverse_geocode(lat, lng)
    
    # Parse landmarks from reverse geocode landmark field
    parsed_landmarks, _ = parse_landmarks_from_text(
        address_info.get('landmark', ''), 
        business_type
    )
    
    # Get landmarks from multiple sample points to cover the full radius
    # Sample points: center + 4 cardinal directions + 4 diagonal directions
    sample_offsets = [
        (0, 0),  # Center
        (0.7, 0), (-0.7, 0), (0, 0.7), (0, -0.7),  # Cardinal directions at 70% radius
        (0.5, 0.5), (-0.5, 0.5), (0.5, -0.5), (-0.5, -0.5),  # Diagonals at 50% radius
    ]
    
    # Convert radius to lat/lng offsets - use original center for sampling
    lat_offset_per_m = 1 / 111000  # ~1 degree per 111km
    lng_offset_per_m = 1 / (111000 * math.cos(math.radians(center_lat)))
    
    nearby_landmarks = []
    landmark_names_seen = set()
    
    # Use center_lat/center_lng for sampling to cover the whole selected area
    for lat_mult, lng_mult in sample_offsets:
        sample_lat = center_lat + (lat_mult * radius * lat_offset_per_m)
        sample_lng = center_lng + (lng_mult * radius * lng_offset_per_m)
        
        # Get landmarks at this sample point
        sample_landmarks = latlong_service.get_landmarks(sample_lat, sample_lng)
        
        for lm in sample_landmarks:
            lm_name = lm.get('name', '').lower()
            if lm_name and lm_name not in landmark_names_seen:
                landmark_names_seen.add(lm_name)
                nearby_landmarks.append(lm)
    
    # Fetch competitors using the new places_service (covers entire radius from center)
    print(f" Fetching competitors: category={business_type}, radius={radius}m from center")
    osm_competitors = fetch_competitors(center_lat, center_lng, radius, business_type)
    
    # Fetch landmarks using places_service for better area coverage
    osm_landmarks = fetch_landmarks(center_lat, center_lng, radius)
    
    # Also fetch landmarks from LatLong POI API for additional data
    latlong_poi_categories = ['hospital', 'school', 'hotel', 'bank', 'atm', 'mall', 'restaurant']
    latlong_pois = []
    for poi_cat in latlong_poi_categories:
        try:
            poi_result = latlong_service.get_poi(center_lat, center_lng, poi_cat, radius)
            for poi in poi_result.get('pois', []):
                latlong_pois.append({
                    'name': poi.get('name', ''),
                    'category': poi_cat,
                    'lat': poi.get('lat', center_lat),
                    'lng': poi.get('lng', center_lng)
                })
        except Exception as e:
            print(f" Error fetching POI {poi_cat}: {e}")
    
    print(f" Found {len(latlong_pois)} POIs from LatLong API")
    
    # Combine all landmarks - start with parsed landmarks
    all_landmarks = []
    existing_names = set()
    
    # Add parsed landmarks with detected categories
    for lm in parsed_landmarks:
        lm_name = lm.get('name', '')
        if lm_name.lower() not in existing_names:
            # Detect category from name
            lm['category'] = detect_landmark_category(lm_name)
            all_landmarks.append(lm)
            existing_names.add(lm_name.lower())
    
    # Add landmarks from Landmarks API with detected categories
    for lm in nearby_landmarks:
        lm_name = lm.get('name', '')
        if lm_name.lower() not in existing_names:
            lm['category'] = detect_landmark_category(lm_name)
            all_landmarks.append(lm)
            existing_names.add(lm_name.lower())
    
    # Add landmarks from OpenStreetMap (for better area coverage)
    for lm in osm_landmarks:
        lm_name = lm.get('name', '')
        if lm_name.lower() not in existing_names:
            # Convert places_service format to expected format
            all_landmarks.append({
                'name': lm_name,
                'lat': lm.get('lat'),
                'lng': lm.get('lng'),
                'category': lm.get('type', 'landmark')
            })
            existing_names.add(lm_name.lower())
    
    # Add landmarks from LatLong POI API
    for poi in latlong_pois:
        poi_name = poi.get('name', '')
        if poi_name.lower() not in existing_names:
            all_landmarks.append(poi)
            existing_names.add(poi_name.lower())
    
    print(f" Total landmarks combined: {len(all_landmarks)}")
    
    # Format competitors with distance calculation from center
    all_competitors = []
    for comp in osm_competitors:
        # Calculate approximate distance in meters from center
        R = 6371000  # Earth's radius in meters
        lat1, lon1 = math.radians(center_lat), math.radians(center_lng)
        lat2, lon2 = math.radians(comp.get('lat', center_lat)), math.radians(comp.get('lng', center_lng))
        dlat, dlon = lat2 - lat1, lon2 - lon1
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        distance = int(R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)))
        
        all_competitors.append({
            'name': comp.get('name', 'Unknown'),
            'category': business_type,
            'lat': comp.get('lat'),
            'lng': comp.get('lng'),
            'distance': distance,
            'is_competitor': True
        })
    
    # Sort competitors by distance
    all_competitors.sort(key=lambda x: x.get('distance', 9999))
    
    # Get Digipin using analysis point for accurate pincode
    digipin_info = latlong_service.get_digipin(lat, lng)
    
    # Build landmarks structure for analysis
    landmarks_data = {
        'by_category': {'nearby': {'count': len(all_landmarks), 'pois': all_landmarks}},
        'total_count': len(all_landmarks),
        'all_pois': all_landmarks
    }
    
    # Build competitors structure
    competitors_data = {
        'count': len(all_competitors),
        'nearby': all_competitors
    }
    
    # Perform analysis
    analysis_result = analyze_location(landmarks_data, competitors_data, business_type)
    
    # Find recommended spots for business setup (search from center of selected area)
    print(f" Finding recommended spots in the area...")
    recommended_spots = find_recommended_spots(
        center_lat=center_lat,
        center_lng=center_lng,
        radius=radius,
        competitors=all_competitors,
        landmarks=all_landmarks,
        max_spots=5
    )
    print(f" Found {len(recommended_spots)} recommended spots")
    
    # Compile response - return ALL competitors for heatmap accuracy
    response = {
        'location': {
            'lat': lat,  # Analysis point (best usable location found)
            'lng': lng,
            'center_lat': center_lat,  # Original selected center
            'center_lng': center_lng,
            'address': address_info,
            'digipin': digipin_info.get('digipin', '')
        },
        'business_type': business_type,
        'radius': radius,
        'filters_applied': filters,
        'recommended_spots': recommended_spots,  # NEW: Recommended business locations
        'competitors': {
            'count': len(all_competitors),
            'nearby': all_competitors  # Return ALL competitors for heatmap
        },
        'landmarks': {
            'total': len(all_landmarks),
            'by_category': {'nearby': len(all_landmarks)},
            'list': all_landmarks  # Return all landmarks
        },
        'footfall_proxy': 'high' if analysis_result['breakdown']['footfall_proxy'] > 60 else 'medium' if analysis_result['breakdown']['footfall_proxy'] > 30 else 'low'
    }
    
    return jsonify(response)


@analysis_bp.route('/isochrone', methods=['POST'])
def get_isochrone():
    """
    POST /api/isochrone
    
    Returns GeoJSON polygon for isochrone visualization.
    
    Request body:
    {
        "lat": 12.9716,
        "lng": 77.5946,
        "distance_km": 1.0
    }
    
    Also accepts legacy format with time_minutes (converts to distance):
    {
        "lat": 12.9716,
        "lng": 77.5946,
        "mode": "bike",
        "time_minutes": 15
    }
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    lat = data.get('lat')
    lng = data.get('lng')
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng are required'}), 400
    
    # Support both new API (distance_km) and legacy (time_minutes + mode)
    distance_km = data.get('distance_km')
    
    if distance_km is None:
        # Convert from legacy time-based format
        mode = data.get('mode', 'bike')
        time_minutes = data.get('time_minutes', 15)
        
        # Validate mode and time
        speeds = {'walk': 5, 'bike': 15, 'car': 30}  # km/h
        speed = speeds.get(mode, 15)
        distance_km = (speed * time_minutes) / 60
    
    # Validate distance
    if distance_km < 0.1 or distance_km > 50:
        return jsonify({'error': 'distance_km must be between 0.1 and 50'}), 400
    
    result = latlong_service.get_isochrone(lat, lng, distance_km)
    
    return jsonify(result)


@analysis_bp.route('/poi', methods=['GET'])
def get_poi():
    """
    GET /api/poi?lat={lat}&lng={lng}&category={category}&radius={radius}
    
    Returns Points of Interest by category.
    """
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    category = request.args.get('category', '')
    radius = request.args.get('radius', 1000, type=int)
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng are required'}), 400
    
    if not category:
        return jsonify({'error': 'category is required'}), 400
    
    result = latlong_service.get_poi(lat, lng, category, radius)
    
    return jsonify(result)


@analysis_bp.route('/supply-chain', methods=['POST'])
def check_supply_chain():
    """
    POST /api/supply-chain
    
    Checks logistics feasibility between store and warehouse.
    
    Request body:
    {
        "store_lat": 12.9716,
        "store_lng": 77.5946,
        "warehouse_lat": 13.0827,
        "warehouse_lng": 77.5877
    }
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    store_lat = data.get('store_lat')
    store_lng = data.get('store_lng')
    warehouse_lat = data.get('warehouse_lat')
    warehouse_lng = data.get('warehouse_lng')
    
    if None in [store_lat, store_lng, warehouse_lat, warehouse_lng]:
        return jsonify({'error': 'All coordinates are required'}), 400
    
    # Calculate distance matrix
    result = latlong_service.distance_matrix(
        origins=[{'lat': warehouse_lat, 'lng': warehouse_lng}],
        destinations=[{'lat': store_lat, 'lng': store_lng}]
    )
    
    # Parse result (simplified - actual implementation depends on API response)
    rows = result.get('rows', [])
    if rows and rows[0].get('elements'):
        element = rows[0]['elements'][0]
        distance_km = element.get('distance', {}).get('value', 0) / 1000
        duration_mins = element.get('duration', {}).get('value', 0) / 60
    else:
        # Fallback: estimate using straight-line distance
        import math
        dlat = store_lat - warehouse_lat
        dlng = store_lng - warehouse_lng
        distance_km = math.sqrt(dlat**2 + dlng**2) * 111  # Rough km conversion
        duration_mins = distance_km * 2  # Assume 30 km/h average
    
    # Determine feasibility
    if duration_mins < 30:
        feasibility = 'excellent'
        message = 'Excellent logistics - Quick delivery possible'
        recommendation = 'This location is well-positioned for efficient supply chain operations.'
    elif duration_mins < 45:
        feasibility = 'acceptable'
        message = 'Acceptable logistics - Standard delivery times'
        recommendation = 'Delivery times are manageable but consider optimizing routes.'
    else:
        feasibility = 'warning'
        message = 'High Logistics Cost - Drive time exceeds 45 minutes'
        recommendation = 'Consider a closer warehouse or factor in higher delivery costs.'
    
    return jsonify({
        'distance_km': round(distance_km, 1),
        'drive_time_minutes': round(duration_mins),
        'feasibility': feasibility,
        'message': message,
        'recommendation': recommendation
    })


@analysis_bp.route('/relevance', methods=['GET'])
def get_relevance_data():
    """
    Get relevance scores for marker styling based on business type.
    Query params:
        - business_type: The selected business type (optional)
        - landmark_type: Specific landmark type to get score for (optional)
    Returns relevance matrix or specific score with marker style.
    """
    business_type = request.args.get('business_type', 'other').lower()
    landmark_type = request.args.get('landmark_type')
    
    if landmark_type:
        # Return specific score and style
        score = get_relevance_score(business_type, landmark_type)
        style = get_marker_style(business_type, landmark_type)
        return jsonify({
            'business_type': business_type,
            'landmark_type': landmark_type,
            'relevance_score': score,
            'marker_style': style
        })
    else:
        # Return all scores for the business type
        if business_type in RELEVANCE_MATRIX:
            scores = RELEVANCE_MATRIX[business_type]
        else:
            scores = RELEVANCE_MATRIX['other']
        
        # Calculate styles for each landmark type
        styles = {}
        for ltype, score in scores.items():
            styles[ltype] = get_marker_style(business_type, ltype)
        
        return jsonify({
            'business_type': business_type,
            'relevance_scores': scores,
            'marker_styles': styles
        })


@analysis_bp.route('/validate-location', methods=['POST'])
def validate_location_endpoint():
    """
    POST /api/validate-location
    
    Validates if a location is suitable for business analysis.
    Performs roadway access, area viability, and road quality checks.
    
    Request body:
    {
        "lat": 12.9716,
        "lng": 77.5946,
        "business_type": "cafe"
    }
    
    Response (success):
    {
        "valid": true,
        "snapped_location": {"lat": 12.9716, "lng": 77.5946},
        "checks": {...},
        "message": "Location validated successfully"
    }
    
    Response (failure):
    {
        "valid": false,
        "error": "No such possible business places present in the area.",
        "error_type": "ghost_town",
        "validation_failed": true
    }
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'Request body is required'}), 400
    
    lat = data.get('lat')
    lng = data.get('lng')
    business_type = data.get('business_type', 'other')
    
    if lat is None or lng is None:
        return jsonify({'error': 'lat and lng are required'}), 400
    
    # Run validation
    is_valid, result = validate_and_fetch_data(lat, lng, business_type)
    
    if not is_valid:
        return jsonify({
            'valid': False,
            'error': result.get('message', 'Location validation failed'),
            'error_type': result.get('error_type', 'validation_error'),
            'validation_failed': True
        }), 400
    
    return jsonify(result)
</file>

<file path="frontend/src/components/Dashboard/CompetitorCard.jsx">
/**
 * Competitor Card Component
 * Displays nearby competitors with distance information
 */

import { useState } from 'react';

export default function CompetitorCard({ competitors = [], isLoading }) {
  const [showAll, setShowAll] = useState(false);
  
  // Ensure competitors is an array
  const competitorList = Array.isArray(competitors) ? competitors : [];
  
  // Sort by distance (closest first)
  const sortedCompetitors = [...competitorList].sort((a, b) => 
    (a.distance || 9999) - (b.distance || 9999)
  );
  
  // Show first 20 or all based on toggle
  const displayCount = showAll ? sortedCompetitors.length : Math.min(20, sortedCompetitors.length);
  const displayedCompetitors = sortedCompetitors.slice(0, displayCount);

  const getDistanceColor = (distance) => {
    if (distance <= 200) return 'text-destructive-glow';
    if (distance <= 500) return 'text-warning-glow';
    return 'text-slate-400';
  };

  const getDistanceLabel = (distance) => {
    if (distance >= 1000) {
      return `${(distance / 1000).toFixed(1)}km`;
    }
    return `${distance}m`;
  };

  return (
    <div className="glass-panel p-5">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-slate-400 flex items-center gap-2">
          <img src="/icons/store.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(42%) sepia(93%) saturate(1352%) hue-rotate(326deg) brightness(99%) contrast(97%)' }} />
          Nearby Competitors
        </h3>
        {!isLoading && (
          <span className="text-xs bg-destructive-glow/20 text-destructive-glow px-2 py-1 rounded-full">
            {competitors.length} found
          </span>
        )}
      </div>

      {isLoading ? (
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="flex items-center gap-3">
              <div className="w-8 h-8 bg-slate-700 rounded-full animate-pulse" />
              <div className="flex-1">
                <div className="h-4 bg-slate-700 rounded animate-pulse w-3/4 mb-1" />
                <div className="h-3 bg-slate-700/50 rounded animate-pulse w-1/2" />
              </div>
            </div>
          ))}
        </div>
      ) : competitors.length === 0 ? (
        <div className="text-center py-6">
          <img src="/icons/star.svg" alt="" className="w-8 h-8 mx-auto mb-2" style={{ filter: 'invert(74%) sepia(52%) saturate(579%) hue-rotate(93deg) brightness(95%) contrast(88%)' }} />
          <p className="text-slate-400 text-sm">No competitors nearby!</p>
          <p className="text-slate-500 text-xs mt-1">Great opportunity zone</p>
        </div>
      ) : (
        <div className="space-y-2">
          <div className="max-h-80 overflow-y-auto space-y-2 pr-1">
            {displayedCompetitors.map((competitor, index) => (
              <div 
                key={index}
                className="flex items-start gap-3 p-2 rounded-lg hover:bg-surface-secondary transition-colors"
              >
                {/* Index badge */}
                <div className="w-6 h-6 bg-destructive-glow/20 text-destructive-glow rounded-full flex items-center justify-center text-xs font-medium flex-shrink-0">
                  {index + 1}
                </div>
                
                {/* Competitor info */}
                <div className="flex-1 min-w-0">
                  <p className="text-slate-200 text-sm truncate">{competitor.name}</p>
                  <p className="text-slate-500 text-xs truncate">{competitor.category}</p>
                </div>
                
                {/* Distance */}
                {competitor.distance !== undefined && (
                  <span className={`text-xs font-mono flex-shrink-0 ${getDistanceColor(competitor.distance)}`}>
                    {getDistanceLabel(competitor.distance)}
                  </span>
                )}
              </div>
            ))}
          </div>
          
          {/* Show more/less toggle */}
          {sortedCompetitors.length > 20 && (
            <button
              onClick={() => setShowAll(!showAll)}
              className="w-full text-center text-xs text-primary-glow hover:text-primary-glow/80 py-2 transition-colors"
            >
              {showAll 
                ? ` Show less` 
                : ` Show all ${sortedCompetitors.length} competitors`}
            </button>
          )}
        </div>
      )}
      
      {/* Competition density indicator */}
      {!isLoading && competitors.length > 0 && (
        <div className="mt-4 pt-4 border-t border-surface-border">
          <div className="flex items-center justify-between text-xs">
            <span className="text-slate-500">Competition Level</span>
            <span className={
              competitors.length >= 10 ? 'text-destructive-glow' :
              competitors.length >= 5 ? 'text-warning-glow' :
              'text-primary-glow'
            }>
              {competitors.length >= 10 ? 'High' : competitors.length >= 5 ? 'Medium' : 'Low'}
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/Search/SearchBar.jsx">
/**
 * Search Bar Component - Spotlight Style
 * Glass-morphic search with glowing border effect
 */

import { useState, useEffect, useRef, useCallback } from 'react';
import { searchLocations } from '../../services/api';

// Debounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

export default function SearchBar({ onLocationSelect, disabled, selectedLocation }) {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  
  const inputRef = useRef(null);
  const dropdownRef = useRef(null);
  
  const debouncedQuery = useDebounce(query, 300);

  // Update query when selectedLocation changes (e.g., from map click)
  useEffect(() => {
    if (selectedLocation?.name) {
      setQuery(selectedLocation.name);
      setIsOpen(false);
      setSuggestions([]);
    }
  }, [selectedLocation]);

  // Fetch suggestions when debounced query changes
  useEffect(() => {
    const fetchSuggestions = async () => {
      if (debouncedQuery.length < 2) {
        setSuggestions([]);
        setIsOpen(false);
        return;
      }

      setIsLoading(true);
      try {
        const results = await searchLocations(debouncedQuery);
        setSuggestions(results);
        setIsOpen(results.length > 0);
        setSelectedIndex(-1);
      } catch (error) {
        console.error('Search error:', error);
        setSuggestions([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchSuggestions();
  }, [debouncedQuery]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target) &&
        !inputRef.current.contains(event.target)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Handle keyboard navigation
  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      setIsOpen(false);
      setSelectedIndex(-1);
      return;
    }

    if (e.key === 'Enter') {
      e.preventDefault();
      // If we have a selected suggestion, use it
      if (isOpen && selectedIndex >= 0 && suggestions[selectedIndex]) {
        handleSelect(suggestions[selectedIndex]);
      } 
      // If we have suggestions but none selected, use the first one
      else if (isOpen && suggestions.length > 0) {
        handleSelect(suggestions[0]);
      }
      // If no suggestions but we have a query, create a manual location
      else if (query.trim().length >= 2) {
        // Trigger a fresh search or use the query as-is
        onLocationSelect({
          name: query.trim(),
          lat: null,
          lng: null,
          needsGeocode: true,
        });
      }
      return;
    }

    if (!isOpen) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex((prev) => 
          prev < suggestions.length - 1 ? prev + 1 : prev
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex((prev) => (prev > 0 ? prev - 1 : -1));
        break;
      default:
        break;
    }
  };

  const handleSelect = (location) => {
    setQuery(location.name);
    setIsOpen(false);
    setSuggestions([]);
    onLocationSelect(location);
  };

  const handleClear = () => {
    setQuery('');
    setSuggestions([]);
    setIsOpen(false);
    inputRef.current?.focus();
  };

  return (
    <div className="space-y-2 relative z-10">
      <label className="text-sm font-medium text-slate-300">
        Which area to analyze?
      </label>
      <p className="text-xs text-slate-500 -mt-1">
        Search for a locality, neighborhood, or city
      </p>

      <div className="relative">
        {/* Spotlight Search Input */}
        <div className={`relative group ${isOpen ? 'ring-2 ring-emerald-500/50' : ''} rounded-xl transition-all duration-300`}>
          {/* Glow effect on focus */}
          <div className={`absolute -inset-0.5 bg-gradient-to-r from-emerald-500/20 via-cyan-500/20 to-emerald-500/20 rounded-xl blur-sm transition-opacity duration-300 ${isOpen ? 'opacity-100' : 'opacity-0 group-hover:opacity-50'}`} />
          
          <div className="relative flex items-center">
            <span className="absolute left-4 text-slate-500">
              <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            </span>
            <input
              ref={inputRef}
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={handleKeyDown}
              onFocus={() => suggestions.length > 0 && setIsOpen(true)}
              disabled={disabled}
              placeholder="Koramangala, Indiranagar, Bandra..."
              className={`
                w-full bg-black/50 border border-white/10 rounded-xl pl-12 pr-12 py-3.5
                text-white placeholder-slate-500 text-sm
                focus:outline-none focus:border-emerald-500/50 focus:bg-black/70
                transition-all duration-200
                ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
              `}
            />
            
            {/* Loading / Clear Button */}
            <div className="absolute right-4">
              {isLoading ? (
                <svg className="w-5 h-5 text-emerald-400 animate-spin" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
              ) : query ? (
                <button
                  type="button"
                  onClick={handleClear}
                  className="text-slate-500 hover:text-white transition-colors p-1"
                >
                  <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              ) : null}
            </div>
          </div>
        </div>

        {/* Suggestions Dropdown */}
        {isOpen && suggestions.length > 0 && (
          <div
            ref={dropdownRef}
            className="absolute z-50 w-full mt-2 backdrop-blur-xl bg-slate-900/95 border border-white/10 rounded-xl shadow-2xl overflow-hidden animate-slide-in-up"
          >
            <ul className="max-h-64 overflow-y-auto">
              {suggestions.map((suggestion, index) => (
                <li key={suggestion.place_id || index}>
                  <button
                    type="button"
                    onClick={() => handleSelect(suggestion)}
                    className={`
                      w-full flex items-start gap-3 px-4 py-3 text-left
                      transition-colors duration-150
                      ${selectedIndex === index ? 'bg-emerald-500/10' : 'hover:bg-white/5'}
                    `}
                  >
                    {/* Show different icon for major areas vs others */}
                    <span className="mt-0.5">
                      {suggestion.is_major ? (
                        <svg className="w-4 h-4 text-emerald-400" fill="currentColor" viewBox="0 0 20 20">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                        </svg>
                      ) : suggestion.is_area ? (
                        <svg className="w-4 h-4 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                        </svg>
                      ) : (
                        <svg className="w-4 h-4 text-cyan-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                      )}
                    </span>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <p className="text-slate-200 truncate">{suggestion.name}</p>
                        {suggestion.is_major && (
                          <span className="text-[10px] bg-emerald-500/20 text-emerald-400 px-1.5 py-0.5 rounded-full whitespace-nowrap border border-emerald-500/20">
                            Major Area
                          </span>
                        )}
                      </div>
                      {suggestion.is_area && !suggestion.is_major && (
                        <p className="text-xs text-slate-500 mt-0.5">Locality</p>
                      )}
                    </div>
                  </button>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* No results message */}
        {isOpen && query.length >= 2 && suggestions.length === 0 && !isLoading && (
          <div className="absolute z-50 w-full mt-2 backdrop-blur-xl bg-slate-900/95 border border-white/10 rounded-xl shadow-2xl p-4 text-center text-slate-400 animate-fade-in">
            <p>No locations found for "{query}"</p>
            <p className="text-xs mt-1 text-slate-500">Try a different area name or click on the map</p>
          </div>
        )}
      </div>

      {/* Hints */}
      {disabled ? (
        <p className="text-xs text-amber-400/80 flex items-center gap-1.5 mt-2">
          <svg className="w-3.5 h-3.5" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
          </svg>
          Select a business type first
        </p>
      ) : (
        <p className="text-xs text-slate-500 flex items-center gap-1.5 mt-2">
          <svg className="w-3.5 h-3.5 text-emerald-400" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
          </svg>
          You can also click anywhere on the map to select a location
        </p>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/hooks/useAnalysis.js">
/**
 * useAnalysis Hook
 * Manages location analysis state and API calls with progressive loading
 */

import { useState, useCallback } from 'react';
import { analyzeLocation, getIsochrone, getDigipin } from '../services/api';

/**
 * Helper to normalize landmarks from API response
 * API returns: { list: [...], by_category: {...}, total: N }
 * We need: [{ name, category, lat, lng }, ...]
 */
function normalizeAllLandmarks(landmarksData) {
  if (!landmarksData) return [];

  // If it's already an array, return it
  if (Array.isArray(landmarksData)) return landmarksData;

  // Check for 'list' property first (our API structure)
  if (Array.isArray(landmarksData.list)) {
    return landmarksData.list;
  }

  // If it has by_category with arrays, flatten all categories into one array
  if (landmarksData.by_category && typeof landmarksData.by_category === 'object') {
    const allLandmarks = [];
    Object.entries(landmarksData.by_category).forEach(([category, items]) => {
      if (Array.isArray(items)) {
        items.forEach(item => {
          allLandmarks.push({
            ...item,
            category: category,
          });
        });
      }
    });
    if (allLandmarks.length > 0) return allLandmarks;
  }

  return [];
}

export default function useAnalysis() {
  const [analysis, setAnalysis] = useState(null);
  const [isochrone, setIsochrone] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Progressive loading status
  const [loadingStatus, setLoadingStatus] = useState({
    step: '',
    message: '',
    progress: 0,
    details: []
  });

  const updateStatus = (step, message, progress, detail = null) => {
    setLoadingStatus(prev => ({
      step,
      message,
      progress,
      details: detail ? [...prev.details, detail] : prev.details
    }));
  };

  const analyze = useCallback(async (location, businessType, filters, radius = 1000) => {
    if (!location || !businessType) {
      setError('Location and business type are required');
      return { success: false, isValidationError: false };
    }

    // Validate that we have coordinates
    if (location.lat == null || location.lng == null) {
      setError('Location coordinates are missing. Please select a different location.');
      return { success: false, isValidationError: false };
    }

    // Clear previous analysis data immediately (clears markers)
    setAnalysis(null);
    setIsochrone(null);
    setError(null);

    setIsLoading(true);
    setLoadingStatus({ step: 'init', message: 'Starting analysis...', progress: 0, details: [] });

    try {
      // Determine isochrone radius based on whether it's a major area
      const isMajorArea = location.is_major || false;
      // Use provided radius (converted to km) or fallback to defaults
      const isochroneRadius = radius ? (radius / 1000) : (isMajorArea ? 2.5 : 1.5);

      // Step 1: Initialize & Validate Location
      updateStatus('validation', 'Checking location validity...', 10, ' Location validated');
      await new Promise(r => setTimeout(r, 300)); // Brief delay for UI feedback

      // Step 2: Fetch isochrone (area boundary)
      updateStatus('boundary', 'Drawing search boundary...', 20);
      let isochroneData = null;
      try {
        isochroneData = await getIsochrone(location.lat, location.lng, isochroneRadius);
        updateStatus('boundary', 'Area boundary ready', 25, ' Area boundary loaded');
      } catch (err) {
        console.warn('Isochrone fetch failed:', err);
        updateStatus('boundary', 'Using circular boundary', 25, ' Using default circular area');
      }

      // Step 3: Run main analysis (includes validation + competitors + landmarks)
      updateStatus('analysis', 'Searching for businesses & landmarks...', 35);

      const analysisData = await analyzeLocation(
        location.lat,
        location.lng,
        businessType,
        filters,
        isMajorArea,
        radius
      );

      // Extract counts for status
      const competitorCount = analysisData.competitors?.count || 0;
      const nearbyList = analysisData.competitors?.nearby || [];
      const landmarkCount = analysisData.landmarks?.total || 0;
      const landmarkCategories = Object.keys(analysisData.landmarks?.by_category || {}).length;

      // Update with competitor results
      updateStatus('competitors', `Found ${competitorCount} competitors`, 55,
        ` ${competitorCount} ${businessType}${competitorCount !== 1 ? 's' : ''} found nearby`);

      await new Promise(r => setTimeout(r, 400));

      // Update with landmark results  
      updateStatus('landmarks', `Identified ${landmarkCount} landmarks`, 70,
        ` ${landmarkCount} landmarks in ${landmarkCategories} categories`);

      await new Promise(r => setTimeout(r, 300));

      // Step 4: Get DIGIPIN (optional)
      updateStatus('digipin', 'Retrieving location code...', 80);
      let digipin = null;
      try {
        const digipinData = await getDigipin(location.lat, location.lng);
        digipin = digipinData?.digipin;
        if (digipin) {
          updateStatus('digipin', 'DIGIPIN retrieved', 85, ` DIGIPIN: ${digipin.substring(0, 10)}...`);
        } else {
          updateStatus('digipin', 'DIGIPIN not available', 85, ' Location code retrieved');
        }
      } catch {
        updateStatus('digipin', 'DIGIPIN skipped', 85, ' Location code skipped');
      }

      await new Promise(r => setTimeout(r, 200));

      // Step 5: Find recommended spots
      const spotsCount = analysisData.recommended_spots?.length || 0;
      updateStatus('spots', `Analyzing ${spotsCount} optimal locations...`, 95,
        ` ${spotsCount} recommended spot${spotsCount !== 1 ? 's' : ''} identified`);
      await new Promise(r => setTimeout(r, 200));

      // Log raw response for debugging
      console.log(' Raw API Response:', JSON.stringify(analysisData, null, 2));

      // Normalize the API response to match frontend expectations
      const normalizedAnalysis = {
        // Recommended spots (new feature)
        recommended_spots: analysisData.recommended_spots || [],
        // Extract competitors from nested structure
        competitors: {
          count: analysisData.competitors?.count || 0,
          nearby: Array.isArray(analysisData.competitors?.nearby)
            ? analysisData.competitors.nearby
            : []
        },
        // Extract landmarks
        landmarks: {
          total: analysisData.landmarks?.total || 0,
          list: normalizeAllLandmarks(analysisData.landmarks),
          by_category: analysisData.landmarks?.by_category || {}
        },
        // Additional data
        footfall_proxy: analysisData.footfall_proxy || 'medium',
        location: location,
        digipin: digipin || analysisData.location?.digipin || '',
        address: analysisData.location?.address || {},
        business_type: analysisData.business_type || businessType,
      };

      // Log normalized data for debugging
      console.log(' Normalized Analysis:', {
        recommended_spots: normalizedAnalysis.recommended_spots,
        competitors: normalizedAnalysis.competitors,
        landmarks: normalizedAnalysis.landmarks
      });

      // Complete! - Show summary
      const summaryMsg = `${competitorCount} competitors, ${landmarkCount} landmarks, ${spotsCount} spots`;
      updateStatus('complete', summaryMsg, 100);

      setAnalysis(normalizedAnalysis);
      setIsochrone(isochroneData);

      return { success: true, isValidationError: false };
    } catch (err) {
      console.error('Analysis error:', err);

      // Check if this is a validation error (location invalid)
      const isValidationError = err.isValidationError || false;
      const errorMessage = err.message || 'Failed to analyze location';

      setError(errorMessage);
      setLoadingStatus(prev => ({
        ...prev,
        step: 'error',
        message: ` ${errorMessage}`,
        progress: 0
      }));

      // Keep analysis and isochrone null (no markers on map)
      setAnalysis(null);
      setIsochrone(null);

      return {
        success: false,
        isValidationError,
        errorType: err.errorType,
        errorMessage
      };
    } finally {
      setIsLoading(false);
    }
  }, []);

  const clearAnalysis = useCallback(() => {
    setAnalysis(null);
    setIsochrone(null);
    setError(null);
    setLoadingStatus({ step: '', message: '', progress: 0, details: [] });
  }, []);

  return {
    analysis,
    isochrone,
    isLoading,
    error,
    loadingStatus,
    analyze,
    clearAnalysis,
  };
}
</file>

<file path="frontend/src/services/api.js">
/**
 * Hotspot IQ - API Service Layer
 * Handles all communication with the Flask backend
 */

import axios from 'axios';

// Create axios instance with base configuration
const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api',
  timeout: 120000, // 2 minutes to handle longer analysis calls
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for logging
api.interceptors.request.use(
  (config) => {
    console.log(` API Request: ${config.method?.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    console.error('API Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    console.error('API Response Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

/**
 * Search for locations using autocomplete
 * @param {string} query - Search term
 * @returns {Promise<Array>} Location suggestions
 */
export const searchLocations = async (query) => {
  if (!query || query.length < 2) return [];

  try {
    const response = await api.get('/autocomplete', { params: { query, limit: 10 } });
    const suggestions = response.data.suggestions || [];

    // LatLong autocomplete returns { name, geoid } without coordinates
    // We need to geocode to get coordinates when user selects a location
    return suggestions.map(s => ({
      name: s.name,
      place_id: s.place_id || s.geoid?.toString() || s.name,
      geoid: s.geoid,
      // lat/lng may be null from autocomplete - will be geocoded on selection
      lat: s.lat,
      lng: s.lng
    }));
  } catch (error) {
    console.error('Search error:', error);
    throw error;
  }
};

/**
 * Geocode a location name to get coordinates
 * @param {string} address - Location name/address
 * @returns {Promise<Object>} Location with coordinates
 */
export const geocodeLocation = async (address) => {
  try {
    const response = await api.get('/geocode', { params: { address } });
    return response.data;
  } catch (error) {
    console.error('Geocode error:', error);
    throw error;
  }
};

/**
 * Reverse geocode coordinates to get address
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} radius - Optional radius in meters for area-based geocoding
 * @returns {Promise<Object>} Address details { address, area_name, pincode, landmark }
 */
export const reverseGeocode = async (lat, lng, radius = 0) => {
  try {
    const params = { lat, lng };
    if (radius > 0) {
      params.radius = radius;
    }
    const response = await api.get('/reverse-geocode', { params });
    return response.data;
  } catch (error) {
    console.error('Reverse geocode error:', error);
    throw error;
  }
};

/**
 * Analyze a location for business potential
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {string} businessType - Type of business
 * @param {Array<string>} filters - Proximity filters
 * @param {boolean} isMajor - Whether this is a major area (larger radius)
 * @returns {Promise<Object>} Analysis results
 * @throws {Error} With validation error message if location is invalid
 */
export const analyzeLocation = async (lat, lng, businessType, filters = [], isMajor = false, radius = 1000) => {
  try {
    const response = await api.post('/analyze', {
      lat,
      lng,
      business_type: businessType,
      filters,
      is_major: isMajor,
      radius,
    });
    return response.data;
  } catch (error) {
    console.error('Analysis error:', error);

    // Extract validation error from backend response
    if (error.response?.data) {
      const data = error.response.data;

      // Check if this is a validation failure
      if (data.validation_failed || data.error_type) {
        const validationError = new Error(data.error || data.message || 'Location validation failed');
        validationError.isValidationError = true;
        validationError.errorType = data.error_type;
        throw validationError;
      }

      // Regular error with message from backend
      if (data.error) {
        throw new Error(data.error);
      }
    }

    throw error;
  }
};

/**
 * Get isochrone polygon for reachability
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} distanceKm - Distance in kilometers (default: 1.0)
 * @returns {Promise<Object>} GeoJSON Feature
 * 
 * Also supports legacy mode/time format which is converted on backend:
 * @param {string} mode - Travel mode (walk, bike, car) - optional
 * @param {number} timeMinutes - Travel time in minutes - optional
 */
export const getIsochrone = async (lat, lng, distanceKmOrMode = 1.0, timeMinutes = null) => {
  try {
    let payload = { lat, lng };

    // Support both new format (distance_km) and legacy (mode + time_minutes)
    if (typeof distanceKmOrMode === 'number' && timeMinutes === null) {
      payload.distance_km = distanceKmOrMode;
    } else if (typeof distanceKmOrMode === 'string') {
      payload.mode = distanceKmOrMode;
      payload.time_minutes = timeMinutes || 15;
    } else {
      payload.distance_km = distanceKmOrMode;
    }

    const response = await api.post('/isochrone', payload);
    return response.data;
  } catch (error) {
    console.error('Isochrone error:', error);
    throw error;
  }
};

/**
 * Get Digipin for a location
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @returns {Promise<Object>} Digipin data
 */
export const getDigipin = async (lat, lng) => {
  try {
    const response = await api.get('/digipin', { params: { lat, lng } });
    return response.data;
  } catch (error) {
    console.error('Digipin error:', error);
    throw error;
  }
};

/**
 * Send chat message to AI assistant
 * @param {string} message - User message
 * @param {Object} context - Location context
 * @returns {Promise<Object>} AI response
 */
export const chat = async (message, context = {}) => {
  try {
    const response = await api.post('/chat', {
      message,
      context,
    });
    return response.data;
  } catch (error) {
    console.error('Chat error:', error);
    throw error;
  }
};

/**
 * Check supply chain feasibility
 * @param {number} storeLat - Store latitude
 * @param {number} storeLng - Store longitude
 * @param {number} warehouseLat - Warehouse latitude
 * @param {number} warehouseLng - Warehouse longitude
 * @returns {Promise<Object>} Supply chain analysis
 */
export const checkSupplyChain = async (storeLat, storeLng, warehouseLat, warehouseLng) => {
  try {
    const response = await api.post('/supply-chain', {
      store_lat: storeLat,
      store_lng: storeLng,
      warehouse_lat: warehouseLat,
      warehouse_lng: warehouseLng,
    });
    return response.data;
  } catch (error) {
    console.error('Supply chain error:', error);
    throw error;
  }
};

/**
 * Health check
 * @returns {Promise<Object>} Health status
 */
export const healthCheck = async () => {
  try {
    const response = await api.get('/health');
    return response.data;
  } catch (error) {
    console.error('Health check failed:', error);
    throw error;
  }
};



export default api;
</file>

<file path="frontend/src/components/Dashboard/AnalysisPanel.jsx">
/**
 * Analysis Panel Component
 * Combines all analysis cards in a slide-out panel
 */

import RecommendedSpotsCard from './RecommendedSpotsCard';
import CompetitorCard from './CompetitorCard';
import LandmarksCard from './LandmarksCard';

export default function AnalysisPanel({
  analysis,
  isLoading,
  isOpen,
  onClose,
  onViewSpot,
  onOpenChat
}) {
  if (!isOpen) return null;

  return (
    <>
      {/* Clickable backdrop - transparent, no blur to keep map visible */}
      <div
        className="fixed inset-0 z-40"
        onClick={onClose}
      />

      {/* Panel */}
      <div className="fixed right-0 top-0 h-full w-full max-w-md bg-slate-950/95 backdrop-blur-md border-l border-white/10 z-50 overflow-hidden flex flex-col animate-slide-in-right shadow-2xl shadow-black/50">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-white/10 bg-slate-900">
          <div>
            <h2 className="text-lg font-semibold text-slate-100">
              Location Analysis
            </h2>
            {analysis?.location && (
              <p className="text-sm text-slate-400 truncate max-w-[280px]">
                {analysis.location.name || analysis.address?.formatted_address || `${analysis.location.lat?.toFixed(4)}, ${analysis.location.lng?.toFixed(4)}`}
              </p>
            )}
          </div>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-surface-secondary transition-colors text-slate-400 hover:text-slate-200"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {/* Summary stats */}
          {!isLoading && analysis && (
            <div className="grid grid-cols-3 gap-2">
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-emerald-400">
                  {analysis?.recommended_spots?.length || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Optimal Spots
                </div>
              </div>
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-rose-400">
                  {analysis?.competitors?.count || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Competitors
                </div>
              </div>
              <div className="glass-panel p-3 text-center">
                <div className="text-2xl font-bold text-cyan-400">
                  {analysis?.landmarks?.total || 0}
                </div>
                <div className="text-[10px] text-slate-500 uppercase tracking-wide">
                  Landmarks
                </div>
              </div>
            </div>
          )}

          {/* Recommended Spots - Primary focus */}
          <RecommendedSpotsCard
            spots={analysis?.recommended_spots || []}
            isLoading={isLoading}
            onViewSpot={onViewSpot}
          />

          {/* Competitors */}
          <CompetitorCard
            competitors={analysis?.competitors?.nearby || []}
            isLoading={isLoading}
          />

          {/* Landmarks */}
          <LandmarksCard
            landmarks={analysis?.landmarks?.list || []}
            isLoading={isLoading}
          />

          {/* DIGIPIN */}
          {!isLoading && analysis?.location?.digipin && (
            <div className="glass-panel p-4">
              <h3 className="text-sm font-medium text-slate-400 mb-2 flex items-center gap-2">
                <img src="/icons/location-pin.svg" alt="" className="w-5 h-5" style={{ filter: 'invert(68%) sepia(51%) saturate(1016%) hue-rotate(359deg) brightness(101%) contrast(96%)' }} />
                DIGIPIN
              </h3>
              <div className="bg-surface-secondary rounded-lg p-3">
                <p className="font-mono text-primary-glow text-lg tracking-wider text-center">
                  {analysis.location.digipin}
                </p>
              </div>
              <p className="text-xs text-slate-500 mt-2 text-center">
                India Post digital address
              </p>
            </div>
          )}
        </div>

        {/* Footer actions */}
        <div className="p-4 border-t border-surface-border bg-surface-elevated">
          <div className="grid grid-cols-2 gap-3">
            <button className="px-4 py-2 bg-surface-secondary text-slate-300 rounded-lg hover:bg-slate-700 transition-colors text-sm">
              Export Report
            </button>
            <button
              onClick={onOpenChat}
              className="btn-primary text-sm"
            >
              Ask AI Assistant
            </button>
          </div>
        </div>
      </div>
    </>
  );
}
</file>

<file path="frontend/src/components/Map/MapView.jsx">
/**
 * Map Container Component
 * The main map canvas using React-Leaflet
 */

import { useEffect, useRef, useState, useMemo } from 'react';
import { MapContainer, TileLayer, Marker, Popup, useMap, Circle } from 'react-leaflet';
import L from 'leaflet';
import HeatmapOverlay from './HeatmapOverlay';

// Fix for default marker icons in React-Leaflet
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
});

// =====================================================
// CONTEXTUAL VISIBILITY - Relevance Matrix
// =====================================================
// Maps business types to landmark categories with relevance scores (0.1 to 1.0)
// Higher score = more relevant for business success
const RELEVANCE_MATRIX = {
  cafe: {
    office: 0.95, school: 0.7, college: 0.9, university: 0.9, hospital: 0.5,
    mall: 0.8, metro_station: 0.9, bus_stop: 0.75, railway_station: 0.85,
    residential: 0.7, park: 0.8, temple: 0.4, bar: 0.85, restaurant: 0.6,
    hotel: 0.7, atm: 0.5, gym: 0.65, pharmacy: 0.3, default: 0.5
  },
  restaurant: {
    office: 0.95, school: 0.5, college: 0.85, university: 0.85, hospital: 0.6,
    mall: 0.85, metro_station: 0.8, bus_stop: 0.65, railway_station: 0.75,
    residential: 0.85, park: 0.6, temple: 0.65, bar: 0.9, restaurant: 0.4,
    hotel: 0.9, atm: 0.5, gym: 0.55, pharmacy: 0.3, default: 0.5
  },
  retail: {
    office: 0.7, school: 0.6, college: 0.75, university: 0.75, hospital: 0.5,
    mall: 0.95, metro_station: 0.9, bus_stop: 0.8, railway_station: 0.85,
    residential: 0.95, park: 0.5, temple: 0.6, bar: 0.4, restaurant: 0.6,
    hotel: 0.7, atm: 0.8, gym: 0.5, pharmacy: 0.6, default: 0.6
  },
  gym: {
    office: 0.9, school: 0.3, college: 0.85, university: 0.85, hospital: 0.4,
    mall: 0.7, metro_station: 0.75, bus_stop: 0.6, railway_station: 0.65,
    residential: 0.95, park: 0.85, temple: 0.2, bar: 0.3, restaurant: 0.5,
    hotel: 0.7, atm: 0.5, gym: 0.2, pharmacy: 0.6, default: 0.5
  },
  pharmacy: {
    office: 0.6, school: 0.7, college: 0.65, university: 0.65, hospital: 0.95,
    mall: 0.7, metro_station: 0.75, bus_stop: 0.7, railway_station: 0.7,
    residential: 0.95, park: 0.4, temple: 0.5, bar: 0.2, restaurant: 0.4,
    hotel: 0.6, atm: 0.6, gym: 0.5, pharmacy: 0.3, default: 0.5
  },
  salon: {
    office: 0.75, school: 0.3, college: 0.7, university: 0.7, hospital: 0.4,
    mall: 0.9, metro_station: 0.7, bus_stop: 0.6, railway_station: 0.65,
    residential: 0.95, park: 0.4, temple: 0.5, bar: 0.6, restaurant: 0.6,
    hotel: 0.8, atm: 0.5, gym: 0.7, pharmacy: 0.4, default: 0.5
  },
  electronics: {
    office: 0.85, school: 0.5, college: 0.9, university: 0.9, hospital: 0.4,
    mall: 0.95, metro_station: 0.85, bus_stop: 0.7, railway_station: 0.8,
    residential: 0.8, park: 0.3, temple: 0.3, bar: 0.3, restaurant: 0.5,
    hotel: 0.6, atm: 0.7, gym: 0.4, pharmacy: 0.3, default: 0.5
  },
  clothing: {
    office: 0.6, school: 0.5, college: 0.85, university: 0.85, hospital: 0.3,
    mall: 0.95, metro_station: 0.85, bus_stop: 0.7, railway_station: 0.8,
    residential: 0.85, park: 0.4, temple: 0.5, bar: 0.5, restaurant: 0.6,
    hotel: 0.7, atm: 0.7, gym: 0.5, pharmacy: 0.3, default: 0.5
  },
  bookstore: {
    office: 0.7, school: 0.95, college: 0.95, university: 0.95, hospital: 0.4,
    mall: 0.75, metro_station: 0.7, bus_stop: 0.6, railway_station: 0.7,
    residential: 0.7, park: 0.6, temple: 0.4, bar: 0.2, restaurant: 0.5,
    hotel: 0.5, atm: 0.5, gym: 0.3, pharmacy: 0.3, default: 0.5
  },
  other: {
    office: 0.6, school: 0.5, college: 0.5, university: 0.5, hospital: 0.5,
    mall: 0.7, metro_station: 0.7, bus_stop: 0.6, railway_station: 0.65,
    residential: 0.7, park: 0.5, temple: 0.5, bar: 0.5, restaurant: 0.5,
    hotel: 0.5, atm: 0.5, gym: 0.5, pharmacy: 0.5, default: 0.5
  }
};

// Get relevance score for a business type and landmark category
const getRelevanceScore = (businessType, landmarkCategory) => {
  const bt = businessType?.toLowerCase() || 'other';
  const lc = landmarkCategory?.toLowerCase().replace(/\s+/g, '_') || 'default';

  const businessScores = RELEVANCE_MATRIX[bt] || RELEVANCE_MATRIX['other'];
  return businessScores[lc] ?? businessScores['default'] ?? 0.5;
};

// Calculate marker style based on relevance
const getMarkerStyle = (businessType, landmarkCategory) => {
  const score = getRelevanceScore(businessType, landmarkCategory);

  // Opacity: 0.35 (low relevance) to 1.0 (high relevance)
  const opacity = 0.35 + (score * 0.65);

  // Scale: 0.7 (low relevance) to 1.15 (high relevance)
  const scale = 0.7 + (score * 0.45);

  // Size: 24px (low relevance) to 36px (high relevance)
  const size = Math.round(24 + (score * 12));

  // Z-index: 100 (low relevance) to 900 (high relevance)
  const zIndex = Math.round(100 + (score * 800));

  return { opacity, scale, size, zIndex, score };
};

// Landmark category to icon mapping
const LANDMARK_ICON_MAP = {
  metro_station: '/icons/metro.svg',
  metro: '/icons/metro.svg',
  bus_stop: '/icons/bus.svg',
  bus: '/icons/bus.svg',
  railway_station: '/icons/metro.svg',
  railway: '/icons/metro.svg',
  school: '/icons/school.svg',
  college: '/icons/college.svg',
  university: '/icons/college.svg',
  hospital: '/icons/hospital.svg',
  clinic: '/icons/hospital.svg',
  mall: '/icons/mall.svg',
  office: '/icons/office.svg',
  residential: '/icons/house.svg',
  temple: '/icons/temple.svg',
  church: '/icons/temple.svg',
  mosque: '/icons/temple.svg',
  park: '/icons/park.svg',
  atm: '/icons/bank.svg',
  bank: '/icons/bank.svg',
  bar: '/icons/bar.svg',
  pub: '/icons/bar.svg',
  restaurant: '/icons/restaurant.svg',
  cafe: '/icons/cafe.svg',
  hotel: '/icons/building.svg',
  pharmacy: '/icons/pharmacy.svg',
  gym: '/icons/gym.svg',
  supermarket: '/icons/mall.svg',
  default: '/icons/marker.svg',
};

// Custom marker icons with SVG - supports dynamic size/opacity for contextual visibility
// Size scaling is handled via CSS classes based on zoom level
const createCustomIcon = (color, iconPath, baseSize = 32, opacity = 1, zIndex = 500) => {
  const iconSize = baseSize;
  const innerIconSize = Math.round(baseSize * 0.5);

  return L.divIcon({
    className: 'custom-marker',
    html: `
      <div style="
        width: ${iconSize}px;
        height: ${iconSize}px;
        background: ${color};
        border: 2px solid white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        opacity: ${opacity};
        z-index: ${zIndex};
        position: relative;
      ">
        <div style="
          width: ${innerIconSize}px;
          height: ${innerIconSize}px;
          background-color: white;
          -webkit-mask: url('${iconPath}') center/contain no-repeat;
          mask: url('${iconPath}') center/contain no-repeat;
        "></div>
      </div>
    `,
    iconSize: [iconSize, iconSize],
    iconAnchor: [iconSize / 2, iconSize / 2],
    popupAnchor: [0, -iconSize / 2],
  });
};

// Cache for landmark icons - keyed by category + business type
const landmarkIconCache = {};

// Get landmark icon based on category with contextual visibility styling
const getLandmarkIcon = (category, businessType = null) => {
  const normalizedCategory = category?.toLowerCase().replace(/\s+/g, '_') || 'default';
  const bt = businessType?.toLowerCase() || 'other';
  const cacheKey = `${normalizedCategory}-${bt}`;

  // Return cached icon if available
  if (landmarkIconCache[cacheKey]) {
    return landmarkIconCache[cacheKey];
  }

  const iconPath = LANDMARK_ICON_MAP[normalizedCategory] || LANDMARK_ICON_MAP.default;

  // Get contextual visibility styling
  const style = getMarkerStyle(bt, normalizedCategory);

  // Create icon with contextual styling (CSS handles zoom scaling)
  const icon = createCustomIcon('#06b6d4', iconPath, style.size, style.opacity, style.zIndex);
  landmarkIconCache[cacheKey] = icon;
  return icon;
};

// Numbered recommended spot icon - HIGHLY DISTINCTIVE design
// These are the "best places to start business" markers - must stand out!
const createSpotIcon = (rank, color) => {
  // Much larger than other markers
  const size = 52;
  const fontSize = 18;
  
  // Bright, high-contrast colors for each rank
  const spotColors = {
    1: { bg: '#FFD700', text: '#000', glow: 'rgba(255, 215, 0, 0.8)', border: '#FFA500' },  // Gold
    2: { bg: '#C0C0C0', text: '#000', glow: 'rgba(192, 192, 192, 0.8)', border: '#A0A0A0' }, // Silver
    3: { bg: '#CD7F32', text: '#fff', glow: 'rgba(205, 127, 50, 0.8)', border: '#8B4513' },  // Bronze
    4: { bg: '#9333EA', text: '#fff', glow: 'rgba(147, 51, 234, 0.8)', border: '#7C3AED' },  // Purple
    5: { bg: '#EC4899', text: '#fff', glow: 'rgba(236, 72, 153, 0.8)', border: '#DB2777' },  // Pink
  };
  
  const colors = spotColors[rank] || spotColors[5];
  
  return L.divIcon({
    className: 'recommended-spot-marker',
    html: `
      <div class="spot-container" style="
        position: relative;
        width: ${size}px;
        height: ${size + 15}px;
      ">
        <!-- Pin pointer at bottom -->
        <div style="
          position: absolute;
          bottom: 0;
          left: 50%;
          transform: translateX(-50%);
          width: 0;
          height: 0;
          border-left: 10px solid transparent;
          border-right: 10px solid transparent;
          border-top: 15px solid ${colors.border};
          filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        "></div>
        
        <!-- Main circle with star icon -->
        <div style="
          position: absolute;
          top: 0;
          left: 0;
          width: ${size}px;
          height: ${size}px;
          background: linear-gradient(145deg, ${colors.bg}, ${colors.border});
          border: 4px solid white;
          border-radius: 50%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          box-shadow: 
            0 4px 15px ${colors.glow},
            0 0 30px ${colors.glow},
            inset 0 2px 4px rgba(255,255,255,0.4);
          animation: spot-pulse 1.5s ease-in-out infinite;
        ">
          <!-- Star icon -->
          <svg width="16" height="16" viewBox="0 0 24 24" fill="${colors.text}" style="margin-bottom: 1px;">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
          </svg>
          <!-- Rank number -->
          <span style="
            font-size: ${fontSize}px;
            font-weight: 900;
            color: ${colors.text};
            text-shadow: ${colors.text === '#000' ? 'none' : '0 1px 2px rgba(0,0,0,0.3)'};
            line-height: 1;
          ">${rank}</span>
        </div>
        
        <!-- Outer ring animation -->
        <div style="
          position: absolute;
          top: -6px;
          left: -6px;
          width: ${size + 12}px;
          height: ${size + 12}px;
          border: 2px solid ${colors.bg};
          border-radius: 50%;
          opacity: 0.6;
          animation: ring-pulse 1.5s ease-in-out infinite;
        "></div>
      </div>
      
      <style>
        @keyframes spot-pulse {
          0%, 100% { 
            transform: scale(1);
            box-shadow: 0 4px 15px ${colors.glow}, 0 0 30px ${colors.glow}, inset 0 2px 4px rgba(255,255,255,0.4);
          }
          50% { 
            transform: scale(1.05);
            box-shadow: 0 6px 25px ${colors.glow}, 0 0 50px ${colors.glow}, inset 0 2px 4px rgba(255,255,255,0.4);
          }
        }
        @keyframes ring-pulse {
          0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
          }
          50% { 
            transform: scale(1.15);
            opacity: 0.2;
          }
        }
      </style>
    `,
    iconSize: [size, size + 15],
    iconAnchor: [size / 2, size + 15],
    popupAnchor: [0, -size - 10],
  });
};

// Create competitor icon (CSS handles zoom scaling)
const createCompetitorIcon = () => {
  return createCustomIcon('#f43f5e', '/icons/store.svg', 32, 1, 500);
};

// landmarkIcon is now dynamically created per category using getLandmarkIcon()

// Component to handle map view changes - only flies to location ONCE when center changes
function MapController({ center, zoom, hasFlown, setHasFlown }) {
  const map = useMap();

  useEffect(() => {
    // Only fly to location once when a NEW location is selected
    if (center && !hasFlown) {
      map.flyTo(center, zoom || 15, {
        duration: 1.5,
      });
      setHasFlown(true);
    }
  }, [center, zoom, map, hasFlown, setHasFlown]);

  return null;
}

// Component to track zoom level and update markers via CSS class
function ZoomTracker({ onZoomChange }) {
  const map = useMap();

  useEffect(() => {
    const handleZoom = () => {
      const zoom = Math.round(map.getZoom());
      onZoomChange(zoom);
      
      // Update CSS class on map container for zoom-based styling
      const container = map.getContainer();
      // Remove old zoom classes
      container.className = container.className.replace(/map-zoom-\d+/g, '').trim();
      // Add new zoom class
      container.classList.add(`map-zoom-${zoom}`);
    };

    // Set initial zoom
    handleZoom();

    map.on('zoomend', handleZoom);
    return () => map.off('zoomend', handleZoom);
  }, [map, onZoomChange]);

  return null;
}

// Component to handle click events
function MapClickHandler({ onClick }) {
  const map = useMap();

  useEffect(() => {
    if (!onClick) return;

    const handleClick = (e) => {
      onClick({
        lat: e.latlng.lat,
        lng: e.latlng.lng,
      });
    };

    map.on('click', handleClick);
    return () => map.off('click', handleClick);
  }, [map, onClick]);

  return null;
}

export default function MapView({
  selectedLocation,
  competitors = [],
  landmarks = [],
  recommendedSpots = [],
  isochrone = null,
  onMapClick,
  onSpotClick,
  center = [12.9716, 77.5946], // Default: Bangalore
  zoom = 13,
  showHeatmap = true,
  showLandmarks = true,
  showCompetitors = true,
  setShowLandmarks,
  setShowCompetitors,
  businessType = null, // For contextual visibility
  radius = null, // Radius in meters
  analysis = null, // For stats panel
  onOpenPanel, // Callback to open analysis panel
  isLoading = false, // Loading state
  isDarkMode = true, // Dark/Light mode toggle
}) {
  const mapRef = useRef(null);
  const [heatmapEnabled, setHeatmapEnabled] = useState(true);
  const [showSpots, setShowSpots] = useState(true);
  const [contextualVisibility, setContextualVisibility] = useState(true); // Toggle for contextual visibility
  const [currentZoom, setCurrentZoom] = useState(zoom); // Track current zoom level for dynamic marker sizing
  const [hasFlown, setHasFlown] = useState(false); // Track if we've flown to location (prevent repeated flying)
  const [lastLocationKey, setLastLocationKey] = useState(null); // Track which location we flew to

  // Reset hasFlown when location changes to a NEW location
  useEffect(() => {
    const locationKey = selectedLocation ? `${selectedLocation.lat}-${selectedLocation.lng}` : null;
    if (locationKey !== lastLocationKey) {
      setHasFlown(false);
      setLastLocationKey(locationKey);
    }
  }, [selectedLocation, lastLocationKey]);

  // Clear landmark icon cache when business type changes (for contextual visibility)
  // Note: Zoom scaling is now handled via CSS, so no need to clear on zoom change
  useEffect(() => {
    // Clear cache to force re-creation of icons with new business type styling
    Object.keys(landmarkIconCache).forEach(key => delete landmarkIconCache[key]);
  }, [businessType, contextualVisibility]);

  // Safely convert to arrays
  const competitorList = Array.isArray(competitors) ? competitors : [];
  const landmarkList = Array.isArray(landmarks) ? landmarks : [];
  const spotList = Array.isArray(recommendedSpots) ? recommendedSpots : [];

  // Spot colors by rank
  const getSpotColor = (rank) => {
    const colors = {
      1: '#10b981', // Emerald
      2: '#06b6d4', // Cyan
      3: '#3b82f6', // Blue
      4: '#8b5cf6', // Purple
      5: '#6b7280', // Gray
    };
    return colors[rank] || colors[5];
  };

  // Circle area style
  const circleStyle = {
    color: '#10b981',
    weight: 2,
    opacity: 0.8,
    fillColor: '#10b981',
    fillOpacity: 0.1,
  };

  // Calculate radius for the circular area (meters)
  // Use provided radius prop if available, otherwise fallback to defaults
  const areaRadius = radius || (selectedLocation?.is_major ? 2500 : 1500);

  return (
    <div className="absolute inset-0 z-0">
      <MapContainer
        ref={mapRef}
        center={center}
        zoom={zoom}
        className="w-full h-full"
        zoomControl={true}
        attributionControl={false}
      >
        {/* Tile layer - switches between dark and light mode */}
        <TileLayer
          key={isDarkMode ? 'dark' : 'light'}
          url={isDarkMode 
            ? "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png"
            : "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png"
          }
          attribution='&copy; <a href="https://carto.com/">CARTO</a>'
        />

        {/* Map controllers */}
        <MapController
          center={selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null
            ? [selectedLocation.lat, selectedLocation.lng]
            : null}
          zoom={15}
          hasFlown={hasFlown}
          setHasFlown={setHasFlown}
        />
        <MapClickHandler onClick={onMapClick} />
        <ZoomTracker onZoomChange={setCurrentZoom} />

        {/* Circular area selection - covers the entire selected area */}
        {selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null && (
          <Circle
            center={[selectedLocation.lat, selectedLocation.lng]}
            radius={areaRadius}
            pathOptions={circleStyle}
          />
        )}

        {/* Competition Heatmap Overlay */}
        {selectedLocation && selectedLocation.lat != null && heatmapEnabled && showHeatmap && (
          <HeatmapOverlay
            center={{ lat: selectedLocation.lat, lng: selectedLocation.lng }}
            competitors={competitorList}
            landmarks={landmarkList}
            radius={areaRadius}
            enabled={heatmapEnabled}
          />
        )}

        {/* Recommended Spot markers - rendered LAST to be on top */}
        {showSpots && spotList
          .filter(s => s.lat != null && s.lng != null)
          .map((spot) => (
            <Marker
              key={`spot-${spot.rank}`}
              position={[spot.lat, spot.lng]}
              icon={createSpotIcon(spot.rank, getSpotColor(spot.rank))}
              zIndexOffset={1000 + (6 - spot.rank) * 100}
              eventHandlers={{
                click: () => onSpotClick && onSpotClick(spot)
              }}
            >
              <Popup>
                <div className="text-slate-900 min-w-[200px]">
                  <div className="flex items-center gap-2 mb-2">
                    <div className="w-8 h-8 rounded-full flex items-center justify-center text-white font-bold" 
                         style={{ background: spot.rank === 1 ? '#FFD700' : spot.rank === 2 ? '#C0C0C0' : spot.rank === 3 ? '#CD7F32' : spot.rank === 4 ? '#9333EA' : '#EC4899' }}>
                      {spot.rank}
                    </div>
                    <div>
                      <span className="font-bold text-base">Best Location #{spot.rank}</span>
                      <p className="text-xs text-slate-500">Recommended for your business</p>
                    </div>
                  </div>
                  <p className="text-xs font-mono text-slate-500 mb-2">
                    {spot.lat.toFixed(6)}, {spot.lng.toFixed(6)}
                  </p>
                  <div className="flex items-center gap-2 mb-2">
                    <span className={`px-2 py-0.5 text-xs rounded-full font-medium ${spot.rating === 'Excellent' ? 'bg-emerald-100 text-emerald-700' :
                        spot.rating === 'Good' ? 'bg-cyan-100 text-cyan-700' :
                          spot.rating === 'Moderate' ? 'bg-amber-100 text-amber-700' :
                            'bg-orange-100 text-orange-700'
                      }`}>
                      {spot.rating}
                    </span>
                    <span className="text-xs text-slate-600">Score: {Math.round(spot.score)}</span>
                  </div>
                  <ul className="text-xs text-slate-600 space-y-0.5">
                    {spot.reasons?.slice(0, 2).map((reason, i) => (
                      <li key={i} className="flex items-start gap-1">
                        <svg className="w-3 h-3 text-emerald-500 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                          <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                        </svg>
                        <span>{reason}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              </Popup>
            </Marker>
          ))}

        {/* Competitor markers - only show those with coordinates */}
        {showCompetitors && competitorList
          .filter(c => c.lat != null && c.lng != null)
          .map((competitor, index) => (
            <Marker
              key={`competitor-${index}`}
              position={[competitor.lat, competitor.lng]}
              icon={createCompetitorIcon()}
            >
              <Popup>
                <div className="text-slate-900">
                  <p className="font-semibold">{competitor.name}</p>
                  <p className="text-xs text-slate-500">{competitor.category}</p>
                  {competitor.distance && (
                    <p className="text-xs text-rose-600 mt-1">
                      {competitor.distance}m away
                    </p>
                  )}
                </div>
              </Popup>
            </Marker>
          ))}

        {/* Landmark markers - only show those with coordinates */}
        {/* Uses contextual visibility to adjust opacity/size based on business relevance */}
        {showLandmarks && landmarkList
          .filter(l => l.lat != null && l.lng != null)
          .map((landmark, index) => {
            const relevance = getRelevanceScore(businessType, landmark.category);
            return (
              <Marker
              key={`landmark-${index}`}
              position={[landmark.lat, landmark.lng]}
              icon={getLandmarkIcon(landmark.category, contextualVisibility ? businessType : null)}
                zIndexOffset={contextualVisibility ? Math.round(relevance * 800) : 0}
              >
                <Popup>
                  <div className="text-slate-900">
                    <p className="font-semibold">{landmark.name}</p>
                    <p className="text-xs text-slate-500">{landmark.category}</p>
                    {contextualVisibility && businessType && (
                      <div className="mt-2 pt-2 border-t border-slate-200">
                        <div className="flex items-center gap-2">
                          <span className="text-xs text-slate-400">Relevance:</span>
                          <div className="flex-1 h-1.5 bg-slate-200 rounded-full overflow-hidden">
                            <div
                              className={`h-full rounded-full ${relevance >= 0.8 ? 'bg-emerald-500' :
                                  relevance >= 0.6 ? 'bg-cyan-500' :
                                    relevance >= 0.4 ? 'bg-amber-500' :
                                      'bg-slate-400'
                                }`}
                              style={{ width: `${relevance * 100}%` }}
                            />
                          </div>
                          <span className={`text-xs font-medium ${relevance >= 0.8 ? 'text-emerald-600' :
                              relevance >= 0.6 ? 'text-cyan-600' :
                                relevance >= 0.4 ? 'text-amber-600' :
                                  'text-slate-500'
                            }`}>
                            {Math.round(relevance * 100)}%
                          </span>
                        </div>
                        <p className="text-[10px] text-slate-400 mt-1">
                          {relevance >= 0.8 ? 'High impact for your business' :
                            relevance >= 0.6 ? 'Moderate impact' :
                              relevance >= 0.4 ? 'Some relevance' :
                                'Low relevance for this business type'}
                        </p>
                      </div>
                    )}
                  </div>
                </Popup>
              </Marker>
            );
          })}
      </MapContainer>

      {/* Unified Bottom-Right Controls - Single Column Stack */}
      {selectedLocation && !isLoading && (
        <div className="absolute bottom-6 right-6 z-[1000] flex flex-col gap-3 w-[300px]">
          
          {/* Row 1: Quick Stats Panel */}
          {analysis && onOpenPanel && (
            <button
              onClick={onOpenPanel}
              className="w-full backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 hover:bg-slate-800/90 transition-all cursor-pointer group shadow-xl"
            >
              <div className="flex items-center gap-4">
                <div className="text-center">
                  <p className="text-3xl font-bold text-emerald-400">
                    {analysis.recommended_spots?.length || 0}
                  </p>
                  <p className="text-xs text-slate-500">Spots</p>
                </div>
                <div className="w-px h-10 bg-white/10" />
                <div className="text-left text-sm">
                  <p className="text-slate-300">
                    <span className="text-rose-400 font-semibold">{analysis.competitors?.count || 0}</span> competitors
                  </p>
                  <p className="text-slate-300">
                    <span className="text-cyan-400 font-semibold">{analysis.landmarks?.total || 0}</span> landmarks
                  </p>
                </div>
                <div className="text-slate-500 group-hover:text-white group-hover:translate-x-0.5 transition-all ml-auto">
                  <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </div>
              </div>
            </button>
          )}

          {/* Row 2: Landmarks & Competitors Toggle */}
          {setShowLandmarks && setShowCompetitors && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-2 flex gap-2 shadow-xl">
              <button
                onClick={() => setShowLandmarks(!showLandmarks)}
                className={`flex-1 px-4 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${showLandmarks
                  ? 'bg-cyan-500 text-white shadow-md shadow-cyan-500/25'
                  : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                  }`}
              >
                <img src="/icons/building.svg" alt="" className="w-4 h-4"
                  style={{ filter: showLandmarks ? 'brightness(0) invert(1)' : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }}
                />
                <span>Landmarks</span>
              </button>
              <button
                onClick={() => setShowCompetitors(!showCompetitors)}
                className={`flex-1 px-4 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${showCompetitors
                  ? 'bg-rose-500 text-white shadow-md shadow-rose-500/25'
                  : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                  }`}
              >
                <img src="/icons/store.svg" alt="" className="w-4 h-4"
                  style={{ filter: showCompetitors ? 'brightness(0) invert(1)' : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }}
                />
                <span>Competitors</span>
              </button>
            </div>
          )}

          {/* Row 3: Heatmap, Spots, Smart View Toggle */}
          {competitorList.length > 0 && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-2 flex flex-wrap gap-2 shadow-xl">
              <button
                onClick={() => setHeatmapEnabled(!heatmapEnabled)}
                className={`flex-1 min-w-[80px] px-3 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${heatmapEnabled
                    ? 'bg-amber-500 text-white shadow-md shadow-amber-500/25'
                    : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                  }`}
              >
                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                </svg>
                <span>Heatmap</span>
              </button>
              {spotList.length > 0 && (
                <button
                  onClick={() => setShowSpots(!showSpots)}
                  className={`flex-1 min-w-[80px] px-3 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${showSpots
                      ? 'bg-emerald-500 text-white shadow-md shadow-emerald-500/25'
                      : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                    }`}
                >
                  <img src="/icons/star.svg" alt="" className="w-4 h-4" style={{ filter: showSpots ? 'brightness(0) invert(1)' : 'invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%)' }} />
                  <span>{spotList.length} Spots</span>
                </button>
              )}
              {businessType && landmarkList.length > 0 && (
                <button
                  onClick={() => setContextualVisibility(!contextualVisibility)}
                  className={`flex-1 min-w-[80px] px-3 py-2.5 rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 ${contextualVisibility
                      ? 'bg-violet-500 text-white shadow-md shadow-violet-500/25'
                      : 'bg-slate-800/50 text-slate-400 hover:bg-slate-700/50 hover:text-slate-300'
                    }`}
                  title="Adjusts landmark visibility based on relevance to your business type"
                >
                  <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                  </svg>
                  <span>Smart</span>
                </button>
              )}
            </div>
          )}

          {/* Row 4: Heatmap Legend */}
          {heatmapEnabled && competitorList.length > 0 && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 shadow-xl">
              <p className="text-sm font-medium text-slate-300 mb-2">Competition Density</p>
              <div className="flex items-center gap-1">
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(34, 197, 94)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(134, 197, 94)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(255, 200, 0)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(255, 150, 0)' }} />
                <div className="w-5 h-5 rounded-md" style={{ background: 'rgb(255, 80, 50)' }} />
              </div>
              <div className="flex justify-between text-xs text-slate-500 mt-2">
                <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-emerald-500"></span>Low</span>
                <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-rose-500"></span>High</span>
              </div>
            </div>
          )}

          {/* Row 5: Smart View Legend */}
          {contextualVisibility && businessType && landmarkList.length > 0 && (
            <div className="backdrop-blur-xl bg-slate-900/90 border border-white/10 rounded-2xl p-4 shadow-xl">
              <p className="text-sm font-medium text-slate-300 mb-3 flex items-center gap-2">
                <svg className="w-4 h-4 text-violet-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                Smart: {businessType}
              </p>
              <div className="space-y-2">
                <div className="flex items-center gap-2 text-sm">
                  <div className="w-5 h-5 rounded-full bg-cyan-500 opacity-100 flex items-center justify-center">
                    <span className="text-white text-xs"></span>
                  </div>
                  <span className="text-slate-400">High relevance</span>
                </div>
                <div className="flex items-center gap-2 text-sm">
                  <div className="w-4 h-4 rounded-full bg-cyan-500 opacity-50 flex items-center justify-center">
                    <span className="text-white text-[8px]"></span>
                  </div>
                  <span className="text-slate-400">Low relevance</span>
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/App.jsx">
/**
 * App.jsx - Main Application Component
 * Hotspot IQ - Location Intelligence Platform
 */

import { useState, useCallback, useEffect } from 'react';

// Layout
import { Header } from './components/Layout';

// Components
import { BusinessTypeSelector } from './components/Filters';
import { SearchBar } from './components/Search';
import { MapView } from './components/Map';
import { AnalysisPanel, LoadingProgress } from './components/Dashboard';
import { ChatBot } from './components/Chat';

// Hooks
import { useAnalysis } from './hooks';

// API
import { geocodeLocation, reverseGeocode } from './services/api';

// Toast notification component
function Toast({ message, type = 'error', onClose }) {
  useEffect(() => {
    const timer = setTimeout(onClose, 8000); // Auto-close after 8 seconds
    return () => clearTimeout(timer);
  }, [onClose]);

  const bgColor = type === 'error'
    ? 'bg-red-500/95 border-red-400'
    : type === 'warning'
      ? 'bg-amber-500/95 border-amber-400'
      : 'bg-emerald-500/95 border-emerald-400';

  const icon = type === 'error' ? (
    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </svg>
  ) : type === 'warning' ? (
    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  ) : (
    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
    </svg>
  );

  return (
    <div className={`fixed top-20 left-1/2 transform -translate-x-1/2 z-50 ${bgColor} text-white px-6 py-4 rounded-xl shadow-2xl border-2 flex items-center gap-4 max-w-lg animate-slide-down`}>
      {icon}
      <div className="flex-1">
        <p className="font-semibold text-sm uppercase tracking-wide opacity-90">
          {type === 'error' ? 'Location Invalid' : type === 'warning' ? 'Warning' : 'Success'}
        </p>
        <p className="text-white/95 mt-1">{message}</p>
      </div>
      <button
        onClick={onClose}
        className="text-white/80 hover:text-white transition-colors p-1"
      >
        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
  );
}

export default function App() {
  // Theme state - default to dark mode
  const [isDarkMode, setIsDarkMode] = useState(() => {
    // Check localStorage for saved preference, default to dark
    const saved = localStorage.getItem('hotspotiq-theme');
    return saved ? saved === 'dark' : true;
  });

  // Toggle theme and save preference
  const toggleTheme = useCallback(() => {
    setIsDarkMode(prev => {
      const newMode = !prev;
      localStorage.setItem('hotspotiq-theme', newMode ? 'dark' : 'light');
      return newMode;
    });
  }, []);

  // Apply theme class to document
  useEffect(() => {
    if (isDarkMode) {
      document.documentElement.classList.add('dark');
      document.documentElement.classList.remove('light');
    } else {
      document.documentElement.classList.add('light');
      document.documentElement.classList.remove('dark');
    }
  }, [isDarkMode]);

  // Step 1: Business Type
  const [businessType, setBusinessType] = useState(null);

  // Step 2: Proximity Filters
  const [selectedFilters, setSelectedFilters] = useState([]);
  // Step 2.5: Radius
  const [radius, setRadius] = useState(1000);

  // Step 3: Selected Location
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [isGeocoding, setIsGeocoding] = useState(false);
  // Toast notification state
  const [toast, setToast] = useState(null);
  // Analysis state
  const {
    analysis,
    isochrone,
    isLoading,
    error,
    loadingStatus,
    analyze,
    clearAnalysis
  } = useAnalysis();

  // Panel state
  const [isPanelOpen, setIsPanelOpen] = useState(false);
  // Map display toggles
  const [showLandmarks, setShowLandmarks] = useState(true);
  const [showCompetitors, setShowCompetitors] = useState(true);
  const [isChatOpen, setIsChatOpen] = useState(false);

  // Handle location selection - geocode if needed
  const handleLocationSelect = useCallback(async (location) => {
    // If location already has coordinates, use it directly
    if (location.lat != null && location.lng != null) {
      setSelectedLocation(location);
      return;
    }

    // Otherwise, geocode the location name to get coordinates
    setIsGeocoding(true);
    try {
      const geocoded = await geocodeLocation(location.name);
      if (geocoded && geocoded.lat && geocoded.lng) {
        setSelectedLocation({
          name: location.name,
          lat: geocoded.lat,
          lng: geocoded.lng,
          address: geocoded.address,
          geoid: location.geoid,
          is_major: location.is_major || false,  // Preserve major area flag
          is_area: location.is_area || false,
        });
      } else {
        console.error('Geocoding returned no coordinates');
        // Show an alert or set an error state
        alert('Could not find coordinates for this location. Please try a different search.');
      }
    } catch (error) {
      console.error('Geocode error:', error);
      alert('Could not find coordinates for this location. Please try a different search.');
    } finally {
      setIsGeocoding(false);
    }
  }, []);

  // Handle map click - reverse geocode to get address
  const handleMapClick = useCallback(async (coords) => {
    // Set immediately with coordinates for responsiveness
    const tempName = `${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}`;
    setSelectedLocation({
      name: tempName,
      lat: coords.lat,
      lng: coords.lng,
    });

    // Reverse geocode using the selected radius to get area name for the whole region
    try {
      // Use the current radius for area-based reverse geocoding
      const result = await reverseGeocode(coords.lat, coords.lng, radius);
      if (result) {
        // Use area_name for display (cleaner, shows just the locality)
        // Fall back to formatted_address if area_name is not available
        const displayName = result.area_name || result.formatted_address || tempName;
        setSelectedLocation({
          name: displayName,
          lat: coords.lat,
          lng: coords.lng,
          pincode: result.pincode,
          landmark: result.landmark,
          fullAddress: result.formatted_address, // Keep full address for reference
          areasInRadius: result.areas_in_radius, // All areas found in the radius
        });
      }
    } catch (error) {
      console.error('Reverse geocode failed:', error);
      // Keep the coordinate-based name if reverse geocode fails
    }
  }, [radius]);

  // Update area name when radius changes (if we have a selected location)
  useEffect(() => {
    const updateAreaName = async () => {
      if (!selectedLocation?.lat || !selectedLocation?.lng) return;
      
      try {
        const result = await reverseGeocode(selectedLocation.lat, selectedLocation.lng, radius);
        if (result?.area_name) {
          setSelectedLocation(prev => ({
            ...prev,
            name: result.area_name,
            areasInRadius: result.areas_in_radius,
          }));
        }
      } catch (error) {
        console.error('Failed to update area name for new radius:', error);
      }
    };
    
    // Debounce the update to avoid too many API calls while sliding
    const timeoutId = setTimeout(updateAreaName, 500);
    return () => clearTimeout(timeoutId);
  }, [radius, selectedLocation?.lat, selectedLocation?.lng]);

  // Handle analyze button click
  const handleAnalyze = useCallback(async () => {
    if (!selectedLocation || !businessType) return;

    // Ensure we have coordinates
    if (selectedLocation.lat == null || selectedLocation.lng == null) {
      setToast({
        message: 'Location coordinates are missing. Please select a location from the search results.',
        type: 'warning'
      });
      return;
    }

    // Clear any existing toast
    setToast(null);

    // Run analysis (this clears markers internally before fetching)
    const result = await analyze(selectedLocation, businessType, selectedFilters, radius);

    // Handle validation errors
    if (!result.success) {
      if (result.isValidationError) {
        // Show validation error toast - map remains clear
        setToast({
          message: result.errorMessage,
          type: 'error'
        });
        // Don't open the panel on validation error
        return;
      }
      // For other errors, show warning toast
      setToast({
        message: result.errorMessage || 'Analysis failed. Please try again.',
        type: 'warning'
      });
      return;
    }

    // Success - open the panel
    setIsPanelOpen(true);
  }, [selectedLocation, businessType, selectedFilters, analyze, radius]);

  // Handle viewing a recommended spot on the map
  const handleViewSpot = useCallback((spot) => {
    // This will cause the map to pan to the spot location
    // We can show a temporary marker or highlight
    console.log('View spot:', spot);
    // The spot marker is already on the map, just close the panel so user can see it
    setIsPanelOpen(false);
  }, []);

  // Check if ready to analyze - need coordinates
  const canAnalyze = businessType && selectedLocation && selectedLocation.lat != null && selectedLocation.lng != null && !isLoading && !isGeocoding;

  return (
    <div className="h-screen bg-canvas-base overflow-hidden">
      {/* Toast Notification for Validation Errors */}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          onClose={() => setToast(null)}
        />
      )}

      {/* Floating Header - Above everything */}
      <Header isDarkMode={isDarkMode} onToggleTheme={toggleTheme} />

      {/* Full-screen Map Layer */}
      <div className="absolute inset-0">
        <MapView
          selectedLocation={selectedLocation}
          competitors={analysis?.competitors?.nearby || []}
          landmarks={analysis?.landmarks?.list || []}
          recommendedSpots={analysis?.recommended_spots || []}
          isochrone={isochrone}
          onMapClick={handleMapClick}
          onSpotClick={handleViewSpot}
          showLandmarks={showLandmarks}
          showCompetitors={showCompetitors}
          setShowLandmarks={setShowLandmarks}
          setShowCompetitors={setShowCompetitors}
          businessType={businessType}
          radius={radius}
          analysis={analysis}
          onOpenPanel={() => setIsPanelOpen(true)}
          isLoading={isLoading}
          isDarkMode={isDarkMode}
        />
      </div>

      {/* Loading Progress - Fixed Top Right (above map controls) */}
      {(isLoading || loadingStatus.step === 'complete' || loadingStatus.step === 'error') && (
        <LoadingProgress status={loadingStatus} isLoading={isLoading} />
      )}

      {/* Command Panel - Left Sidebar */}
      <div className="fixed left-6 top-20 bottom-6 w-[340px] z-20 pointer-events-none">
        <div className="h-full backdrop-blur-xl bg-slate-900/80 border border-white/10 rounded-3xl shadow-2xl shadow-black/30 pointer-events-auto overflow-hidden flex flex-col">
          {/* Sidebar Header */}
          <div className="p-5 border-b border-white/5">
            <h2 className="text-lg font-semibold text-white flex items-center gap-2">
              <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-emerald-500 to-cyan-500 flex items-center justify-center">
                <svg className="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                </svg>
              </div>
              Location Analysis
            </h2>
            <p className="text-xs text-slate-500 mt-1">Configure your business search parameters</p>
          </div>

          {/* Scrollable Content */}
          <div className="flex-1 overflow-y-auto p-5 space-y-5">
            {/* Step 1: Location Search - Spotlight Style */}
            <div className="relative z-30">
              <SearchBar
                onLocationSelect={handleLocationSelect}
                disabled={false}
                selectedLocation={selectedLocation}
              />
            </div>

            {/* Step 2: Search Radius Slider */}
            <div className="space-y-3">
              <div className="flex justify-between items-center">
                <label className="text-sm font-medium text-slate-300">Search Radius</label>
                <span className="text-sm font-mono text-emerald-400 bg-emerald-500/10 px-3 py-1 rounded-full border border-emerald-500/20">
                  {radius >= 1000 ? `${(radius / 1000).toFixed(1)} km` : `${radius} m`}
                </span>
              </div>
              <input
                type="range"
                min="500"
                max="5000"
                step="100"
                value={radius}
                onChange={(e) => setRadius(parseInt(e.target.value))}
                className="w-full h-2 bg-slate-700/50 rounded-full appearance-none cursor-pointer accent-emerald-500"
              />
              <div className="flex justify-between text-[10px] text-slate-500">
                <span>0.5 km</span>
                <span>2.5 km</span>
                <span>5.0 km</span>
              </div>
            </div>

            {/* Step 3: Business Type - Icon Grid */}
            <div className="relative z-10">
              <BusinessTypeSelector
                value={businessType}
                onChange={(value) => {
                  setBusinessType(value);
                  clearAnalysis();
                }}
              />
            </div>
          </div>

          {/* Fixed Footer - Analyze Button */}
          <div className="p-5 border-t border-white/5 bg-slate-900/50">
            {selectedLocation ? (
              <button
                onClick={handleAnalyze}
                disabled={!canAnalyze}
                className={`
                  w-full py-4 rounded-xl text-base font-semibold transition-all duration-300
                  flex items-center justify-center gap-2
                  ${canAnalyze 
                    ? 'bg-gradient-to-r from-emerald-500 to-cyan-500 text-white hover:shadow-lg hover:shadow-emerald-500/25 hover:scale-[1.02] active:scale-[0.98]' 
                    : 'bg-slate-800 text-slate-500 cursor-not-allowed'}
                `}
              >
                {isLoading ? (
                  <>
                    <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    <span>Analyzing...</span>
                  </>
                ) : isGeocoding ? (
                  <>
                    <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    <span>Finding location...</span>
                  </>
                ) : (
                  <>
                    <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                    <span>Analyze Location</span>
                  </>
                )}
              </button>
            ) : (
              <div className="text-center text-sm text-slate-500 py-3">
                <p>Select a business type and location to begin</p>
              </div>
            )}
          </div>
        </div>
      </div>



      {/* Analysis Panel */}
      <AnalysisPanel
        analysis={analysis}
        isLoading={isLoading}
        isOpen={isPanelOpen}
        onClose={() => setIsPanelOpen(false)}
        onViewSpot={handleViewSpot}
        onOpenChat={() => setIsChatOpen(true)}
      />

      {/* Chat Bot */}
      <ChatBot
        selectedLocation={selectedLocation}
        businessType={businessType}
        analysis={analysis}
        isOpen={isChatOpen}
        onClose={() => setIsChatOpen(false)}
      />
    </div>
  );
}
</file>

</files>
